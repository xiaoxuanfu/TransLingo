/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web-streams-polyfill";
exports.ids = ["vendor-chunks/web-streams-polyfill"];
exports.modules = {

/***/ "(rsc)/../../node_modules/web-streams-polyfill/dist/ponyfill.es2018.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/web-streams-polyfill/dist/ponyfill.es2018.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * @license\n * web-streams-polyfill v3.3.2\n * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.\n * This code is released under the MIT license.\n * SPDX-License-Identifier: MIT\n */ (function(global1, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    /// <reference lib=\"es2015.symbol\" />\n    const SymbolPolyfill = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? Symbol : (description)=>`Symbol(${description})`;\n    function noop() {\n        return undefined;\n    }\n    function typeIsObject(x) {\n        return typeof x === \"object\" && x !== null || typeof x === \"function\";\n    }\n    const rethrowAssertionErrorRejection = noop;\n    function setFunctionName(fn, name) {\n        try {\n            Object.defineProperty(fn, \"name\", {\n                value: name,\n                configurable: true\n            });\n        } catch (_a) {\n        // This property is non-configurable in older browsers, so ignore if this throws.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n        }\n    }\n    const originalPromise = Promise;\n    const originalPromiseThen = Promise.prototype.then;\n    const originalPromiseReject = Promise.reject.bind(originalPromise);\n    // https://webidl.spec.whatwg.org/#a-new-promise\n    function newPromise(executor) {\n        return new originalPromise(executor);\n    }\n    // https://webidl.spec.whatwg.org/#a-promise-resolved-with\n    function promiseResolvedWith(value) {\n        return newPromise((resolve)=>resolve(value));\n    }\n    // https://webidl.spec.whatwg.org/#a-promise-rejected-with\n    function promiseRejectedWith(reason) {\n        return originalPromiseReject(reason);\n    }\n    function PerformPromiseThen(promise, onFulfilled, onRejected) {\n        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n        // approximation.\n        return originalPromiseThen.call(promise, onFulfilled, onRejected);\n    }\n    // Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned\n    // from that handler. To prevent this, return null instead of void from all handlers.\n    // http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it\n    function uponPromise(promise, onFulfilled, onRejected) {\n        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n    }\n    function uponFulfillment(promise, onFulfilled) {\n        uponPromise(promise, onFulfilled);\n    }\n    function uponRejection(promise, onRejected) {\n        uponPromise(promise, undefined, onRejected);\n    }\n    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n    }\n    function setPromiseIsHandledToTrue(promise) {\n        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n    }\n    let _queueMicrotask = (callback)=>{\n        if (typeof queueMicrotask === \"function\") {\n            _queueMicrotask = queueMicrotask;\n        } else {\n            const resolvedPromise = promiseResolvedWith(undefined);\n            _queueMicrotask = (cb)=>PerformPromiseThen(resolvedPromise, cb);\n        }\n        return _queueMicrotask(callback);\n    };\n    function reflectCall(F, V, args) {\n        if (typeof F !== \"function\") {\n            throw new TypeError(\"Argument is not a function\");\n        }\n        return Function.prototype.apply.call(F, V, args);\n    }\n    function promiseCall(F, V, args) {\n        try {\n            return promiseResolvedWith(reflectCall(F, V, args));\n        } catch (value) {\n            return promiseRejectedWith(value);\n        }\n    }\n    // Original from Chromium\n    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n    const QUEUE_MAX_ARRAY_SIZE = 16384;\n    /**\n     * Simple queue structure.\n     *\n     * Avoids scalability issues with using a packed array directly by using\n     * multiple arrays in a linked list and keeping the array size bounded.\n     */ class SimpleQueue {\n        constructor(){\n            this._cursor = 0;\n            this._size = 0;\n            // _front and _back are always defined.\n            this._front = {\n                _elements: [],\n                _next: undefined\n            };\n            this._back = this._front;\n            // The cursor is used to avoid calling Array.shift().\n            // It contains the index of the front element of the array inside the\n            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n            this._cursor = 0;\n            // When there is only one node, size === elements.length - cursor.\n            this._size = 0;\n        }\n        get length() {\n            return this._size;\n        }\n        // For exception safety, this method is structured in order:\n        // 1. Read state\n        // 2. Calculate required state mutations\n        // 3. Perform state mutations\n        push(element) {\n            const oldBack = this._back;\n            let newBack = oldBack;\n            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                newBack = {\n                    _elements: [],\n                    _next: undefined\n                };\n            }\n            // push() is the mutation most likely to throw an exception, so it\n            // goes first.\n            oldBack._elements.push(element);\n            if (newBack !== oldBack) {\n                this._back = newBack;\n                oldBack._next = newBack;\n            }\n            ++this._size;\n        }\n        // Like push(), shift() follows the read -> calculate -> mutate pattern for\n        // exception safety.\n        shift() {\n            const oldFront = this._front;\n            let newFront = oldFront;\n            const oldCursor = this._cursor;\n            let newCursor = oldCursor + 1;\n            const elements = oldFront._elements;\n            const element = elements[oldCursor];\n            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                newFront = oldFront._next;\n                newCursor = 0;\n            }\n            // No mutations before this point.\n            --this._size;\n            this._cursor = newCursor;\n            if (oldFront !== newFront) {\n                this._front = newFront;\n            }\n            // Permit shifted element to be garbage collected.\n            elements[oldCursor] = undefined;\n            return element;\n        }\n        // The tricky thing about forEach() is that it can be called\n        // re-entrantly. The queue may be mutated inside the callback. It is easy to\n        // see that push() within the callback has no negative effects since the end\n        // of the queue is checked for on every iteration. If shift() is called\n        // repeatedly within the callback then the next iteration may return an\n        // element that has been removed. In this case the callback will be called\n        // with undefined values until we either \"catch up\" with elements that still\n        // exist or reach the back of the queue.\n        forEach(callback) {\n            let i = this._cursor;\n            let node = this._front;\n            let elements = node._elements;\n            while(i !== elements.length || node._next !== undefined){\n                if (i === elements.length) {\n                    node = node._next;\n                    elements = node._elements;\n                    i = 0;\n                    if (elements.length === 0) {\n                        break;\n                    }\n                }\n                callback(elements[i]);\n                ++i;\n            }\n        }\n        // Return the element that would be returned if shift() was called now,\n        // without modifying the queue.\n        peek() {\n            const front = this._front;\n            const cursor = this._cursor;\n            return front._elements[cursor];\n        }\n    }\n    const AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\n    const ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\n    const CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\n    const PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n    const ReleaseSteps = SymbolPolyfill(\"[[ReleaseSteps]]\");\n    function ReadableStreamReaderGenericInitialize(reader, stream) {\n        reader._ownerReadableStream = stream;\n        stream._reader = reader;\n        if (stream._state === \"readable\") {\n            defaultReaderClosedPromiseInitialize(reader);\n        } else if (stream._state === \"closed\") {\n            defaultReaderClosedPromiseInitializeAsResolved(reader);\n        } else {\n            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n        }\n    }\n    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n    // check.\n    function ReadableStreamReaderGenericCancel(reader, reason) {\n        const stream = reader._ownerReadableStream;\n        return ReadableStreamCancel(stream, reason);\n    }\n    function ReadableStreamReaderGenericRelease(reader) {\n        const stream = reader._ownerReadableStream;\n        if (stream._state === \"readable\") {\n            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        } else {\n            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        }\n        stream._readableStreamController[ReleaseSteps]();\n        stream._reader = undefined;\n        reader._ownerReadableStream = undefined;\n    }\n    // Helper functions for the readers.\n    function readerLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderClosedPromiseInitialize(reader) {\n        reader._closedPromise = newPromise((resolve, reject)=>{\n            reader._closedPromise_resolve = resolve;\n            reader._closedPromise_reject = reject;\n        });\n    }\n    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseReject(reader, reason);\n    }\n    function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseResolve(reader);\n    }\n    function defaultReaderClosedPromiseReject(reader, reason) {\n        if (reader._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(reader._closedPromise);\n        reader._closedPromise_reject(reason);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n    }\n    function defaultReaderClosedPromiseResolve(reader) {\n        if (reader._closedPromise_resolve === undefined) {\n            return;\n        }\n        reader._closedPromise_resolve(undefined);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n    const NumberIsFinite = Number.isFinite || function(x) {\n        return typeof x === \"number\" && isFinite(x);\n    };\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n    const MathTrunc = Math.trunc || function(v) {\n        return v < 0 ? Math.ceil(v) : Math.floor(v);\n    };\n    // https://heycam.github.io/webidl/#idl-dictionaries\n    function isDictionary(x) {\n        return typeof x === \"object\" || typeof x === \"function\";\n    }\n    function assertDictionary(obj, context) {\n        if (obj !== undefined && !isDictionary(obj)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-callback-functions\n    function assertFunction(x, context) {\n        if (typeof x !== \"function\") {\n            throw new TypeError(`${context} is not a function.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-object\n    function isObject(x) {\n        return typeof x === \"object\" && x !== null || typeof x === \"function\";\n    }\n    function assertObject(x, context) {\n        if (!isObject(x)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    function assertRequiredArgument(x, position, context) {\n        if (x === undefined) {\n            throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n        }\n    }\n    function assertRequiredField(x, field, context) {\n        if (x === undefined) {\n            throw new TypeError(`${field} is required in '${context}'.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-unrestricted-double\n    function convertUnrestrictedDouble(value) {\n        return Number(value);\n    }\n    function censorNegativeZero(x) {\n        return x === 0 ? 0 : x;\n    }\n    function integerPart(x) {\n        return censorNegativeZero(MathTrunc(x));\n    }\n    // https://heycam.github.io/webidl/#idl-unsigned-long-long\n    function convertUnsignedLongLongWithEnforceRange(value, context) {\n        const lowerBound = 0;\n        const upperBound = Number.MAX_SAFE_INTEGER;\n        let x = Number(value);\n        x = censorNegativeZero(x);\n        if (!NumberIsFinite(x)) {\n            throw new TypeError(`${context} is not a finite number`);\n        }\n        x = integerPart(x);\n        if (x < lowerBound || x > upperBound) {\n            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n        }\n        if (!NumberIsFinite(x) || x === 0) {\n            return 0;\n        }\n        // TODO Use BigInt if supported?\n        // let xBigInt = BigInt(integerPart(x));\n        // xBigInt = BigInt.asUintN(64, xBigInt);\n        // return Number(xBigInt);\n        return x;\n    }\n    function assertReadableStream(x, context) {\n        if (!IsReadableStream(x)) {\n            throw new TypeError(`${context} is not a ReadableStream.`);\n        }\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamDefaultReader(stream) {\n        return new ReadableStreamDefaultReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadRequest(stream, readRequest) {\n        stream._reader._readRequests.push(readRequest);\n    }\n    function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readRequest = reader._readRequests.shift();\n        if (done) {\n            readRequest._closeSteps();\n        } else {\n            readRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadRequests(stream) {\n        return stream._reader._readRequests.length;\n    }\n    function ReadableStreamHasDefaultReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamDefaultReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A default reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */ class ReadableStreamDefaultReader {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"ReadableStreamDefaultReader\");\n            assertReadableStream(stream, \"First parameter\");\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed,\n         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */ read() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: false\n                    }),\n                _closeSteps: ()=>resolvePromise({\n                        value: undefined,\n                        done: true\n                    }),\n                _errorSteps: (e)=>rejectPromise(e)\n            };\n            ReadableStreamDefaultReaderRead(this, readRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */ releaseLock() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                throw defaultReaderBrandCheckException(\"releaseLock\");\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            ReadableStreamDefaultReaderRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        read: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStreamDefaultReader.prototype.cancel, \"cancel\");\n    setFunctionName(ReadableStreamDefaultReader.prototype.read, \"read\");\n    setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, \"releaseLock\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamDefaultReader\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamDefaultReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readRequests\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultReader;\n    }\n    function ReadableStreamDefaultReaderRead(reader, readRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n            readRequest._closeSteps();\n        } else if (stream._state === \"errored\") {\n            readRequest._errorSteps(stream._storedError);\n        } else {\n            stream._readableStreamController[PullSteps](readRequest);\n        }\n    }\n    function ReadableStreamDefaultReaderRelease(reader) {\n        ReadableStreamReaderGenericRelease(reader);\n        const e = new TypeError(\"Reader was released\");\n        ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n    }\n    function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\n        const readRequests = reader._readRequests;\n        reader._readRequests = new SimpleQueue();\n        readRequests.forEach((readRequest)=>{\n            readRequest._errorSteps(e);\n        });\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n    }\n    /// <reference lib=\"es2018.asynciterable\" />\n    /* eslint-disable @typescript-eslint/no-empty-function */ const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);\n    /// <reference lib=\"es2018.asynciterable\" />\n    class ReadableStreamAsyncIteratorImpl {\n        constructor(reader, preventCancel){\n            this._ongoingPromise = undefined;\n            this._isFinished = false;\n            this._reader = reader;\n            this._preventCancel = preventCancel;\n        }\n        next() {\n            const nextSteps = ()=>this._nextSteps();\n            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n            return this._ongoingPromise;\n        }\n        return(value) {\n            const returnSteps = ()=>this._returnSteps(value);\n            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n        }\n        _nextSteps() {\n            if (this._isFinished) {\n                return Promise.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            const reader = this._reader;\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    this._ongoingPromise = undefined;\n                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                    // FIXME Is this a bug in the specification, or in the test?\n                    _queueMicrotask(()=>resolvePromise({\n                            value: chunk,\n                            done: false\n                        }));\n                },\n                _closeSteps: ()=>{\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    resolvePromise({\n                        value: undefined,\n                        done: true\n                    });\n                },\n                _errorSteps: (reason)=>{\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    rejectPromise(reason);\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promise;\n        }\n        _returnSteps(value) {\n            if (this._isFinished) {\n                return Promise.resolve({\n                    value,\n                    done: true\n                });\n            }\n            this._isFinished = true;\n            const reader = this._reader;\n            if (!this._preventCancel) {\n                const result = ReadableStreamReaderGenericCancel(reader, value);\n                ReadableStreamReaderGenericRelease(reader);\n                return transformPromiseWith(result, ()=>({\n                        value,\n                        done: true\n                    }));\n            }\n            ReadableStreamReaderGenericRelease(reader);\n            return promiseResolvedWith({\n                value,\n                done: true\n            });\n        }\n    }\n    const ReadableStreamAsyncIteratorPrototype = {\n        next () {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"next\"));\n            }\n            return this._asyncIteratorImpl.next();\n        },\n        return (value) {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"return\"));\n            }\n            return this._asyncIteratorImpl.return(value);\n        }\n    };\n    if (AsyncIteratorPrototype !== undefined) {\n        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n        iterator._asyncIteratorImpl = impl;\n        return iterator;\n    }\n    function IsReadableStreamAsyncIterator(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_asyncIteratorImpl\")) {\n            return false;\n        }\n        try {\n            // noinspection SuspiciousTypeOfGuard\n            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n        } catch (_a) {\n            return false;\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamAsyncIteratorBrandCheckException(name) {\n        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n    }\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n    const NumberIsNaN = Number.isNaN || function(x) {\n        // eslint-disable-next-line no-self-compare\n        return x !== x;\n    };\n    function CreateArrayFromList(elements) {\n        // We use arrays to represent lists, so this is basically a no-op.\n        // Do a slice though just in case we happen to depend on the unique-ness.\n        return elements.slice();\n    }\n    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n    }\n    let TransferArrayBuffer = (O)=>{\n        if (typeof O.transfer === \"function\") {\n            TransferArrayBuffer = (buffer)=>buffer.transfer();\n        } else if (typeof structuredClone === \"function\") {\n            TransferArrayBuffer = (buffer)=>structuredClone(buffer, {\n                    transfer: [\n                        buffer\n                    ]\n                });\n        } else {\n            // Not implemented correctly\n            TransferArrayBuffer = (buffer)=>buffer;\n        }\n        return TransferArrayBuffer(O);\n    };\n    let IsDetachedBuffer = (O)=>{\n        if (typeof O.detached === \"boolean\") {\n            IsDetachedBuffer = (buffer)=>buffer.detached;\n        } else {\n            // Not implemented correctly\n            IsDetachedBuffer = (buffer)=>buffer.byteLength === 0;\n        }\n        return IsDetachedBuffer(O);\n    };\n    function ArrayBufferSlice(buffer, begin, end) {\n        // ArrayBuffer.prototype.slice is not available on IE10\n        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n        if (buffer.slice) {\n            return buffer.slice(begin, end);\n        }\n        const length = end - begin;\n        const slice = new ArrayBuffer(length);\n        CopyDataBlockBytes(slice, 0, buffer, begin, length);\n        return slice;\n    }\n    function GetMethod(receiver, prop) {\n        const func = receiver[prop];\n        if (func === undefined || func === null) {\n            return undefined;\n        }\n        if (typeof func !== \"function\") {\n            throw new TypeError(`${String(prop)} is not a function`);\n        }\n        return func;\n    }\n    function CreateAsyncFromSyncIterator(syncIteratorRecord) {\n        // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,\n        // we use yield* inside an async generator function to achieve the same result.\n        // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.\n        const syncIterable = {\n            [SymbolPolyfill.iterator]: ()=>syncIteratorRecord.iterator\n        };\n        // Create an async generator function and immediately invoke it.\n        const asyncIterator = async function*() {\n            return yield* syncIterable;\n        }();\n        // Return as an async iterator record.\n        const nextMethod = asyncIterator.next;\n        return {\n            iterator: asyncIterator,\n            nextMethod,\n            done: false\n        };\n    }\n    function GetIterator(obj, hint = \"sync\", method) {\n        if (method === undefined) {\n            if (hint === \"async\") {\n                method = GetMethod(obj, SymbolPolyfill.asyncIterator);\n                if (method === undefined) {\n                    const syncMethod = GetMethod(obj, SymbolPolyfill.iterator);\n                    const syncIteratorRecord = GetIterator(obj, \"sync\", syncMethod);\n                    return CreateAsyncFromSyncIterator(syncIteratorRecord);\n                }\n            } else {\n                method = GetMethod(obj, SymbolPolyfill.iterator);\n            }\n        }\n        if (method === undefined) {\n            throw new TypeError(\"The object is not iterable\");\n        }\n        const iterator = reflectCall(method, obj, []);\n        if (!typeIsObject(iterator)) {\n            throw new TypeError(\"The iterator method must return an object\");\n        }\n        const nextMethod = iterator.next;\n        return {\n            iterator,\n            nextMethod,\n            done: false\n        };\n    }\n    function IteratorNext(iteratorRecord) {\n        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);\n        if (!typeIsObject(result)) {\n            throw new TypeError(\"The iterator.next() method must return an object\");\n        }\n        return result;\n    }\n    function IteratorComplete(iterResult) {\n        return Boolean(iterResult.done);\n    }\n    function IteratorValue(iterResult) {\n        return iterResult.value;\n    }\n    function IsNonNegativeNumber(v) {\n        if (typeof v !== \"number\") {\n            return false;\n        }\n        if (NumberIsNaN(v)) {\n            return false;\n        }\n        if (v < 0) {\n            return false;\n        }\n        return true;\n    }\n    function CloneAsUint8Array(O) {\n        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n        return new Uint8Array(buffer);\n    }\n    function DequeueValue(container) {\n        const pair = container._queue.shift();\n        container._queueTotalSize -= pair.size;\n        if (container._queueTotalSize < 0) {\n            container._queueTotalSize = 0;\n        }\n        return pair.value;\n    }\n    function EnqueueValueWithSize(container, value, size) {\n        if (!IsNonNegativeNumber(size) || size === Infinity) {\n            throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n        }\n        container._queue.push({\n            value,\n            size\n        });\n        container._queueTotalSize += size;\n    }\n    function PeekQueueValue(container) {\n        const pair = container._queue.peek();\n        return pair.value;\n    }\n    function ResetQueue(container) {\n        container._queue = new SimpleQueue();\n        container._queueTotalSize = 0;\n    }\n    function isDataViewConstructor(ctor) {\n        return ctor === DataView;\n    }\n    function isDataView(view) {\n        return isDataViewConstructor(view.constructor);\n    }\n    function arrayBufferViewElementSize(ctor) {\n        if (isDataViewConstructor(ctor)) {\n            return 1;\n        }\n        return ctor.BYTES_PER_ELEMENT;\n    }\n    /**\n     * A pull-into request in a {@link ReadableByteStreamController}.\n     *\n     * @public\n     */ class ReadableStreamBYOBRequest {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n         */ get view() {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"view\");\n            }\n            return this._view;\n        }\n        respond(bytesWritten) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respond\");\n            }\n            assertRequiredArgument(bytesWritten, 1, \"respond\");\n            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, \"First parameter\");\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n            }\n            if (IsDetachedBuffer(this._view.buffer)) {\n                throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\n            }\n            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n        }\n        respondWithNewView(view) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respondWithNewView\");\n            }\n            assertRequiredArgument(view, 1, \"respondWithNewView\");\n            if (!ArrayBuffer.isView(view)) {\n                throw new TypeError(\"You can only respond with array buffer views\");\n            }\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n            }\n            if (IsDetachedBuffer(view.buffer)) {\n                throw new TypeError(\"The given view's buffer has been detached and so cannot be used as a response\");\n            }\n            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n        respond: {\n            enumerable: true\n        },\n        respondWithNewView: {\n            enumerable: true\n        },\n        view: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStreamBYOBRequest.prototype.respond, \"respond\");\n    setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, \"respondWithNewView\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamBYOBRequest\",\n            configurable: true\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n     *\n     * @public\n     */ class ReadableByteStreamController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the current BYOB pull request, or `null` if there isn't one.\n         */ get byobRequest() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"byobRequest\");\n            }\n            return ReadableByteStreamControllerGetBYOBRequest(this);\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n         */ get desiredSize() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"desiredSize\");\n            }\n            return ReadableByteStreamControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */ close() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"close\");\n            }\n            if (this._closeRequested) {\n                throw new TypeError(\"The stream has already been closed; do not close it again!\");\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n            }\n            ReadableByteStreamControllerClose(this);\n        }\n        enqueue(chunk) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"enqueue\");\n            }\n            assertRequiredArgument(chunk, 1, \"enqueue\");\n            if (!ArrayBuffer.isView(chunk)) {\n                throw new TypeError(\"chunk must be an array buffer view\");\n            }\n            if (chunk.byteLength === 0) {\n                throw new TypeError(\"chunk must have non-zero byteLength\");\n            }\n            if (chunk.buffer.byteLength === 0) {\n                throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n            }\n            if (this._closeRequested) {\n                throw new TypeError(\"stream is closed or draining\");\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n            }\n            ReadableByteStreamControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */ error(e = undefined) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"error\");\n            }\n            ReadableByteStreamControllerError(this, e);\n        }\n        /** @internal */ [CancelSteps](reason) {\n            ReadableByteStreamControllerClearPendingPullIntos(this);\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableByteStreamControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [PullSteps](readRequest) {\n            const stream = this._controlledReadableByteStream;\n            if (this._queueTotalSize > 0) {\n                ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n                return;\n            }\n            const autoAllocateChunkSize = this._autoAllocateChunkSize;\n            if (autoAllocateChunkSize !== undefined) {\n                let buffer;\n                try {\n                    buffer = new ArrayBuffer(autoAllocateChunkSize);\n                } catch (bufferE) {\n                    readRequest._errorSteps(bufferE);\n                    return;\n                }\n                const pullIntoDescriptor = {\n                    buffer,\n                    bufferByteLength: autoAllocateChunkSize,\n                    byteOffset: 0,\n                    byteLength: autoAllocateChunkSize,\n                    bytesFilled: 0,\n                    minimumFill: 1,\n                    elementSize: 1,\n                    viewConstructor: Uint8Array,\n                    readerType: \"default\"\n                };\n                this._pendingPullIntos.push(pullIntoDescriptor);\n            }\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableByteStreamControllerCallPullIfNeeded(this);\n        }\n        /** @internal */ [ReleaseSteps]() {\n            if (this._pendingPullIntos.length > 0) {\n                const firstPullInto = this._pendingPullIntos.peek();\n                firstPullInto.readerType = \"none\";\n                this._pendingPullIntos = new SimpleQueue();\n                this._pendingPullIntos.push(firstPullInto);\n            }\n        }\n    }\n    Object.defineProperties(ReadableByteStreamController.prototype, {\n        close: {\n            enumerable: true\n        },\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        byobRequest: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableByteStreamController.prototype.close, \"close\");\n    setFunctionName(ReadableByteStreamController.prototype.enqueue, \"enqueue\");\n    setFunctionName(ReadableByteStreamController.prototype.error, \"error\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableByteStreamController\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableByteStreamController.\n    function IsReadableByteStreamController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableByteStream\")) {\n            return false;\n        }\n        return x instanceof ReadableByteStreamController;\n    }\n    function IsReadableStreamBYOBRequest(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_associatedReadableByteStreamController\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBRequest;\n    }\n    function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        // TODO: Test controller argument\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, ()=>{\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            return null;\n        }, (e)=>{\n            ReadableByteStreamControllerError(controller, e);\n            return null;\n        });\n    }\n    function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        controller._pendingPullIntos = new SimpleQueue();\n    }\n    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n        let done = false;\n        if (stream._state === \"closed\") {\n            done = true;\n        }\n        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n        if (pullIntoDescriptor.readerType === \"default\") {\n            ReadableStreamFulfillReadRequest(stream, filledView, done);\n        } else {\n            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n        }\n    }\n    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n        const bytesFilled = pullIntoDescriptor.bytesFilled;\n        const elementSize = pullIntoDescriptor.elementSize;\n        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n    }\n    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        controller._queue.push({\n            buffer,\n            byteOffset,\n            byteLength\n        });\n        controller._queueTotalSize += byteLength;\n    }\n    function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        let clonedChunk;\n        try {\n            clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);\n        } catch (cloneE) {\n            ReadableByteStreamControllerError(controller, cloneE);\n            throw cloneE;\n        }\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);\n    }\n    function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\n        if (firstDescriptor.bytesFilled > 0) {\n            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\n        }\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n    }\n    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n        let totalBytesToCopyRemaining = maxBytesToCopy;\n        let ready = false;\n        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n        const maxAlignedBytes = maxBytesFilled - remainderBytes;\n        // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n        // of the queue, so the underlying source can keep filling it.\n        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n            ready = true;\n        }\n        const queue = controller._queue;\n        while(totalBytesToCopyRemaining > 0){\n            const headOfQueue = queue.peek();\n            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n            if (headOfQueue.byteLength === bytesToCopy) {\n                queue.shift();\n            } else {\n                headOfQueue.byteOffset += bytesToCopy;\n                headOfQueue.byteLength -= bytesToCopy;\n            }\n            controller._queueTotalSize -= bytesToCopy;\n            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n            totalBytesToCopyRemaining -= bytesToCopy;\n        }\n        return ready;\n    }\n    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n        pullIntoDescriptor.bytesFilled += size;\n    }\n    function ReadableByteStreamControllerHandleQueueDrain(controller) {\n        if (controller._queueTotalSize === 0 && controller._closeRequested) {\n            ReadableByteStreamControllerClearAlgorithms(controller);\n            ReadableStreamClose(controller._controlledReadableByteStream);\n        } else {\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }\n    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n        if (controller._byobRequest === null) {\n            return;\n        }\n        controller._byobRequest._associatedReadableByteStreamController = undefined;\n        controller._byobRequest._view = null;\n        controller._byobRequest = null;\n    }\n    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n        while(controller._pendingPullIntos.length > 0){\n            if (controller._queueTotalSize === 0) {\n                return;\n            }\n            const pullIntoDescriptor = controller._pendingPullIntos.peek();\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {\n        const reader = controller._controlledReadableByteStream._reader;\n        while(reader._readRequests.length > 0){\n            if (controller._queueTotalSize === 0) {\n                return;\n            }\n            const readRequest = reader._readRequests.shift();\n            ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n        }\n    }\n    function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {\n        const stream = controller._controlledReadableByteStream;\n        const ctor = view.constructor;\n        const elementSize = arrayBufferViewElementSize(ctor);\n        const { byteOffset, byteLength } = view;\n        const minimumFill = min * elementSize;\n        let buffer;\n        try {\n            buffer = TransferArrayBuffer(view.buffer);\n        } catch (e) {\n            readIntoRequest._errorSteps(e);\n            return;\n        }\n        const pullIntoDescriptor = {\n            buffer,\n            bufferByteLength: buffer.byteLength,\n            byteOffset,\n            byteLength,\n            bytesFilled: 0,\n            minimumFill,\n            elementSize,\n            viewConstructor: ctor,\n            readerType: \"byob\"\n        };\n        if (controller._pendingPullIntos.length > 0) {\n            controller._pendingPullIntos.push(pullIntoDescriptor);\n            // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n            // - No change happens on desiredSize\n            // - The source has already been notified of that there's at least 1 pending read(view)\n            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n            return;\n        }\n        if (stream._state === \"closed\") {\n            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n            readIntoRequest._closeSteps(emptyView);\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                ReadableByteStreamControllerHandleQueueDrain(controller);\n                readIntoRequest._chunkSteps(filledView);\n                return;\n            }\n            if (controller._closeRequested) {\n                const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e);\n                readIntoRequest._errorSteps(e);\n                return;\n            }\n        }\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n        if (firstDescriptor.readerType === \"none\") {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n        }\n        const stream = controller._controlledReadableByteStream;\n        if (ReadableStreamHasBYOBReader(stream)) {\n            while(ReadableStreamGetNumReadIntoRequests(stream) > 0){\n                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n        if (pullIntoDescriptor.readerType === \"none\") {\n            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n            return;\n        }\n        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n            // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n            // of the queue, so the underlying source can keep filling it.\n            return;\n        }\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n        if (remainderSize > 0) {\n            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);\n        }\n        pullIntoDescriptor.bytesFilled -= remainderSize;\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n        } else {\n            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n        const descriptor = controller._pendingPullIntos.shift();\n        return descriptor;\n    }\n    function ReadableByteStreamControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n            return false;\n        }\n        if (controller._closeRequested) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableByteStreamControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n    }\n    // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n    function ReadableByteStreamControllerClose(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            controller._closeRequested = true;\n            return;\n        }\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {\n                const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e);\n                throw e;\n            }\n        }\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n    function ReadableByteStreamControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n            return;\n        }\n        const { buffer, byteOffset, byteLength } = chunk;\n        if (IsDetachedBuffer(buffer)) {\n            throw new TypeError(\"chunk's buffer is detached and so cannot be enqueued\");\n        }\n        const transferredBuffer = TransferArrayBuffer(buffer);\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\n                throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk\");\n            }\n            ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n            if (firstPendingPullInto.readerType === \"none\") {\n                ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n            }\n        }\n        if (ReadableStreamHasDefaultReader(stream)) {\n            ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);\n            if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            } else {\n                if (controller._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerShiftPendingPullInto(controller);\n                }\n                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                ReadableStreamFulfillReadRequest(stream, transferredView, false);\n            }\n        } else if (ReadableStreamHasBYOBReader(stream)) {\n            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n        } else {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerError(controller, e) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n            return;\n        }\n        ReadableByteStreamControllerClearPendingPullIntos(controller);\n        ResetQueue(controller);\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\n        const entry = controller._queue.shift();\n        controller._queueTotalSize -= entry.byteLength;\n        ReadableByteStreamControllerHandleQueueDrain(controller);\n        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n        readRequest._chunkSteps(view);\n    }\n    function ReadableByteStreamControllerGetBYOBRequest(controller) {\n        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n            const firstDescriptor = controller._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n            controller._byobRequest = byobRequest;\n        }\n        return controller._byobRequest;\n    }\n    function ReadableByteStreamControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"errored\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            if (bytesWritten !== 0) {\n                throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n            }\n        } else {\n            if (bytesWritten === 0) {\n                throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n            }\n            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                throw new RangeError(\"bytesWritten out of range\");\n            }\n        }\n        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n    }\n    function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            if (view.byteLength !== 0) {\n                throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n            }\n        } else {\n            if (view.byteLength === 0) {\n                throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n            }\n        }\n        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n            throw new RangeError(\"The region specified by view does not match byobRequest\");\n        }\n        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n            throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n        }\n        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n            throw new RangeError(\"The region specified by view is larger than byobRequest\");\n        }\n        const viewByteLength = view.byteLength;\n        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n    }\n    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n        controller._controlledReadableByteStream = stream;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._byobRequest = null;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._closeRequested = false;\n        controller._started = false;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        controller._autoAllocateChunkSize = autoAllocateChunkSize;\n        controller._pendingPullIntos = new SimpleQueue();\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), ()=>{\n            controller._started = true;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n            return null;\n        }, (r)=>{\n            ReadableByteStreamControllerError(controller, r);\n            return null;\n        });\n    }\n    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        let startAlgorithm;\n        let pullAlgorithm;\n        let cancelAlgorithm;\n        if (underlyingByteSource.start !== undefined) {\n            startAlgorithm = ()=>underlyingByteSource.start(controller);\n        } else {\n            startAlgorithm = ()=>undefined;\n        }\n        if (underlyingByteSource.pull !== undefined) {\n            pullAlgorithm = ()=>underlyingByteSource.pull(controller);\n        } else {\n            pullAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (underlyingByteSource.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>underlyingByteSource.cancel(reason);\n        } else {\n            cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n        if (autoAllocateChunkSize === 0) {\n            throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n        }\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n    }\n    function SetUpReadableStreamBYOBRequest(request, controller, view) {\n        request._associatedReadableByteStreamController = controller;\n        request._view = view;\n    }\n    // Helper functions for the ReadableStreamBYOBRequest.\n    function byobRequestBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n    }\n    // Helper functions for the ReadableByteStreamController.\n    function byteStreamControllerBrandCheckException(name) {\n        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n    }\n    function convertReaderOptions(options, context) {\n        assertDictionary(options, context);\n        const mode = options === null || options === void 0 ? void 0 : options.mode;\n        return {\n            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n        };\n    }\n    function convertReadableStreamReaderMode(mode, context) {\n        mode = `${mode}`;\n        if (mode !== \"byob\") {\n            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n        }\n        return mode;\n    }\n    function convertByobReadOptions(options, context) {\n        var _a;\n        assertDictionary(options, context);\n        const min = (_a = options === null || options === void 0 ? void 0 : options.min) !== null && _a !== void 0 ? _a : 1;\n        return {\n            min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)\n        };\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamBYOBReader(stream) {\n        return new ReadableStreamBYOBReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n        stream._reader._readIntoRequests.push(readIntoRequest);\n    }\n    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readIntoRequest = reader._readIntoRequests.shift();\n        if (done) {\n            readIntoRequest._closeSteps(chunk);\n        } else {\n            readIntoRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadIntoRequests(stream) {\n        return stream._reader._readIntoRequests.length;\n    }\n    function ReadableStreamHasBYOBReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamBYOBReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A BYOB reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */ class ReadableStreamBYOBReader {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"ReadableStreamBYOBReader\");\n            assertReadableStream(stream, \"First parameter\");\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n            }\n            if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte \" + \"source\");\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readIntoRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the reader's lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        read(view, rawOptions = {}) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n            }\n            if (!ArrayBuffer.isView(view)) {\n                return promiseRejectedWith(new TypeError(\"view must be an array buffer view\"));\n            }\n            if (view.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(\"view must have non-zero byteLength\"));\n            }\n            if (view.buffer.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n            }\n            if (IsDetachedBuffer(view.buffer)) {\n                return promiseRejectedWith(new TypeError(\"view's buffer has been detached\"));\n            }\n            let options;\n            try {\n                options = convertByobReadOptions(rawOptions, \"options\");\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            const min = options.min;\n            if (min === 0) {\n                return promiseRejectedWith(new TypeError(\"options.min must be greater than 0\"));\n            }\n            if (!isDataView(view)) {\n                if (min > view.length) {\n                    return promiseRejectedWith(new RangeError(\"options.min must be less than or equal to view's length\"));\n                }\n            } else if (min > view.byteLength) {\n                return promiseRejectedWith(new RangeError(\"options.min must be less than or equal to view's byteLength\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readIntoRequest = {\n                _chunkSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: false\n                    }),\n                _closeSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: true\n                    }),\n                _errorSteps: (e)=>rejectPromise(e)\n            };\n            ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */ releaseLock() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                throw byobReaderBrandCheckException(\"releaseLock\");\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            ReadableStreamBYOBReaderRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        read: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStreamBYOBReader.prototype.cancel, \"cancel\");\n    setFunctionName(ReadableStreamBYOBReader.prototype.read, \"read\");\n    setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, \"releaseLock\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamBYOBReader\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamBYOBReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readIntoRequests\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBReader;\n    }\n    function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"errored\") {\n            readIntoRequest._errorSteps(stream._storedError);\n        } else {\n            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);\n        }\n    }\n    function ReadableStreamBYOBReaderRelease(reader) {\n        ReadableStreamReaderGenericRelease(reader);\n        const e = new TypeError(\"Reader was released\");\n        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n    }\n    function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\n        const readIntoRequests = reader._readIntoRequests;\n        reader._readIntoRequests = new SimpleQueue();\n        readIntoRequests.forEach((readIntoRequest)=>{\n            readIntoRequest._errorSteps(e);\n        });\n    }\n    // Helper functions for the ReadableStreamBYOBReader.\n    function byobReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n    }\n    function ExtractHighWaterMark(strategy, defaultHWM) {\n        const { highWaterMark } = strategy;\n        if (highWaterMark === undefined) {\n            return defaultHWM;\n        }\n        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n            throw new RangeError(\"Invalid highWaterMark\");\n        }\n        return highWaterMark;\n    }\n    function ExtractSizeAlgorithm(strategy) {\n        const { size } = strategy;\n        if (!size) {\n            return ()=>1;\n        }\n        return size;\n    }\n    function convertQueuingStrategy(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        const size = init === null || init === void 0 ? void 0 : init.size;\n        return {\n            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n        };\n    }\n    function convertQueuingStrategySize(fn, context) {\n        assertFunction(fn, context);\n        return (chunk)=>convertUnrestrictedDouble(fn(chunk));\n    }\n    function convertUnderlyingSink(original, context) {\n        assertDictionary(original, context);\n        const abort = original === null || original === void 0 ? void 0 : original.abort;\n        const close = original === null || original === void 0 ? void 0 : original.close;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        const write = original === null || original === void 0 ? void 0 : original.write;\n        return {\n            abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n            close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n            start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n            write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n            type\n        };\n    }\n    function convertUnderlyingSinkAbortCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    function convertUnderlyingSinkCloseCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return ()=>promiseCall(fn, original, []);\n    }\n    function convertUnderlyingSinkStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertUnderlyingSinkWriteCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller)=>promiseCall(fn, original, [\n                chunk,\n                controller\n            ]);\n    }\n    function assertWritableStream(x, context) {\n        if (!IsWritableStream(x)) {\n            throw new TypeError(`${context} is not a WritableStream.`);\n        }\n    }\n    function isAbortSignal(value) {\n        if (typeof value !== \"object\" || value === null) {\n            return false;\n        }\n        try {\n            return typeof value.aborted === \"boolean\";\n        } catch (_a) {\n            // AbortSignal.prototype.aborted throws if its brand check fails\n            return false;\n        }\n    }\n    const supportsAbortController = typeof AbortController === \"function\";\n    /**\n     * Construct a new AbortController, if supported by the platform.\n     *\n     * @internal\n     */ function createAbortController() {\n        if (supportsAbortController) {\n            return new AbortController();\n        }\n        return undefined;\n    }\n    /**\n     * A writable stream represents a destination for data, into which you can write.\n     *\n     * @public\n     */ class WritableStream {\n        constructor(rawUnderlyingSink = {}, rawStrategy = {}){\n            if (rawUnderlyingSink === undefined) {\n                rawUnderlyingSink = null;\n            } else {\n                assertObject(rawUnderlyingSink, \"First parameter\");\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, \"First parameter\");\n            InitializeWritableStream(this);\n            const type = underlyingSink.type;\n            if (type !== undefined) {\n                throw new RangeError(\"Invalid type is specified\");\n            }\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n        }\n        /**\n         * Returns whether or not the writable stream is locked to a writer.\n         */ get locked() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"locked\");\n            }\n            return IsWritableStreamLocked(this);\n        }\n        /**\n         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n         * mechanism of the underlying sink.\n         *\n         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n         * the stream) if the stream is currently locked.\n         */ abort(reason = undefined) {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"abort\"));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot abort a stream that already has a writer\"));\n            }\n            return WritableStreamAbort(this, reason);\n        }\n        /**\n         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n         *\n         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n         */ close() {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"close\"));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close a stream that already has a writer\"));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n            }\n            return WritableStreamClose(this);\n        }\n        /**\n         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n         * is locked, no other writer can be acquired until this one is released.\n         *\n         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n         */ getWriter() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"getWriter\");\n            }\n            return AcquireWritableStreamDefaultWriter(this);\n        }\n    }\n    Object.defineProperties(WritableStream.prototype, {\n        abort: {\n            enumerable: true\n        },\n        close: {\n            enumerable: true\n        },\n        getWriter: {\n            enumerable: true\n        },\n        locked: {\n            enumerable: true\n        }\n    });\n    setFunctionName(WritableStream.prototype.abort, \"abort\");\n    setFunctionName(WritableStream.prototype.close, \"close\");\n    setFunctionName(WritableStream.prototype.getWriter, \"getWriter\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStream\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStream.\n    function AcquireWritableStreamDefaultWriter(stream) {\n        return new WritableStreamDefaultWriter(stream);\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n        const stream = Object.create(WritableStream.prototype);\n        InitializeWritableStream(stream);\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    function InitializeWritableStream(stream) {\n        stream._state = \"writable\";\n        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n        // 'erroring' or 'errored'. May be set to an undefined value.\n        stream._storedError = undefined;\n        stream._writer = undefined;\n        // Initialize to undefined first because the constructor of the controller checks this\n        // variable to validate the caller.\n        stream._writableStreamController = undefined;\n        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n        // producer without waiting for the queued writes to finish.\n        stream._writeRequests = new SimpleQueue();\n        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n        stream._inFlightWriteRequest = undefined;\n        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n        // has been detached.\n        stream._closeRequest = undefined;\n        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n        stream._inFlightCloseRequest = undefined;\n        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n        stream._pendingAbortRequest = undefined;\n        // The backpressure signal set by the controller.\n        stream._backpressure = false;\n    }\n    function IsWritableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_writableStreamController\")) {\n            return false;\n        }\n        return x instanceof WritableStream;\n    }\n    function IsWritableStreamLocked(stream) {\n        if (stream._writer === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamAbort(stream, reason) {\n        var _a;\n        if (stream._state === \"closed\" || stream._state === \"errored\") {\n            return promiseResolvedWith(undefined);\n        }\n        stream._writableStreamController._abortReason = reason;\n        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort(reason);\n        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n        // but it doesn't know that signaling abort runs author code that might have changed the state.\n        // Widen the type again by casting to WritableStreamState.\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._pendingAbortRequest !== undefined) {\n            return stream._pendingAbortRequest._promise;\n        }\n        let wasAlreadyErroring = false;\n        if (state === \"erroring\") {\n            wasAlreadyErroring = true;\n            // reason will not be used, so don't keep a reference to it.\n            reason = undefined;\n        }\n        const promise = newPromise((resolve, reject)=>{\n            stream._pendingAbortRequest = {\n                _promise: undefined,\n                _resolve: resolve,\n                _reject: reject,\n                _reason: reason,\n                _wasAlreadyErroring: wasAlreadyErroring\n            };\n        });\n        stream._pendingAbortRequest._promise = promise;\n        if (!wasAlreadyErroring) {\n            WritableStreamStartErroring(stream, reason);\n        }\n        return promise;\n    }\n    function WritableStreamClose(stream) {\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n        }\n        const promise = newPromise((resolve, reject)=>{\n            const closeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._closeRequest = closeRequest;\n        });\n        const writer = stream._writer;\n        if (writer !== undefined && stream._backpressure && state === \"writable\") {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n        WritableStreamDefaultControllerClose(stream._writableStreamController);\n        return promise;\n    }\n    // WritableStream API exposed for controllers.\n    function WritableStreamAddWriteRequest(stream) {\n        const promise = newPromise((resolve, reject)=>{\n            const writeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._writeRequests.push(writeRequest);\n        });\n        return promise;\n    }\n    function WritableStreamDealWithRejection(stream, error) {\n        const state = stream._state;\n        if (state === \"writable\") {\n            WritableStreamStartErroring(stream, error);\n            return;\n        }\n        WritableStreamFinishErroring(stream);\n    }\n    function WritableStreamStartErroring(stream, reason) {\n        const controller = stream._writableStreamController;\n        stream._state = \"erroring\";\n        stream._storedError = reason;\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n        }\n        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n            WritableStreamFinishErroring(stream);\n        }\n    }\n    function WritableStreamFinishErroring(stream) {\n        stream._state = \"errored\";\n        stream._writableStreamController[ErrorSteps]();\n        const storedError = stream._storedError;\n        stream._writeRequests.forEach((writeRequest)=>{\n            writeRequest._reject(storedError);\n        });\n        stream._writeRequests = new SimpleQueue();\n        if (stream._pendingAbortRequest === undefined) {\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const abortRequest = stream._pendingAbortRequest;\n        stream._pendingAbortRequest = undefined;\n        if (abortRequest._wasAlreadyErroring) {\n            abortRequest._reject(storedError);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n        uponPromise(promise, ()=>{\n            abortRequest._resolve();\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return null;\n        }, (reason)=>{\n            abortRequest._reject(reason);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return null;\n        });\n    }\n    function WritableStreamFinishInFlightWrite(stream) {\n        stream._inFlightWriteRequest._resolve(undefined);\n        stream._inFlightWriteRequest = undefined;\n    }\n    function WritableStreamFinishInFlightWriteWithError(stream, error) {\n        stream._inFlightWriteRequest._reject(error);\n        stream._inFlightWriteRequest = undefined;\n        WritableStreamDealWithRejection(stream, error);\n    }\n    function WritableStreamFinishInFlightClose(stream) {\n        stream._inFlightCloseRequest._resolve(undefined);\n        stream._inFlightCloseRequest = undefined;\n        const state = stream._state;\n        if (state === \"erroring\") {\n            // The error was too late to do anything, so it is ignored.\n            stream._storedError = undefined;\n            if (stream._pendingAbortRequest !== undefined) {\n                stream._pendingAbortRequest._resolve();\n                stream._pendingAbortRequest = undefined;\n            }\n        }\n        stream._state = \"closed\";\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseResolve(writer);\n        }\n    }\n    function WritableStreamFinishInFlightCloseWithError(stream, error) {\n        stream._inFlightCloseRequest._reject(error);\n        stream._inFlightCloseRequest = undefined;\n        // Never execute sink abort() after sink close().\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._reject(error);\n            stream._pendingAbortRequest = undefined;\n        }\n        WritableStreamDealWithRejection(stream, error);\n    }\n    // TODO(ricea): Fix alphabetical order.\n    function WritableStreamCloseQueuedOrInFlight(stream) {\n        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamHasOperationMarkedInFlight(stream) {\n        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamMarkCloseRequestInFlight(stream) {\n        stream._inFlightCloseRequest = stream._closeRequest;\n        stream._closeRequest = undefined;\n    }\n    function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n        stream._inFlightWriteRequest = stream._writeRequests.shift();\n    }\n    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n        if (stream._closeRequest !== undefined) {\n            stream._closeRequest._reject(stream._storedError);\n            stream._closeRequest = undefined;\n        }\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseReject(writer, stream._storedError);\n        }\n    }\n    function WritableStreamUpdateBackpressure(stream, backpressure) {\n        const writer = stream._writer;\n        if (writer !== undefined && backpressure !== stream._backpressure) {\n            if (backpressure) {\n                defaultWriterReadyPromiseReset(writer);\n            } else {\n                defaultWriterReadyPromiseResolve(writer);\n            }\n        }\n        stream._backpressure = backpressure;\n    }\n    /**\n     * A default writer vended by a {@link WritableStream}.\n     *\n     * @public\n     */ class WritableStreamDefaultWriter {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"WritableStreamDefaultWriter\");\n            assertWritableStream(stream, \"First parameter\");\n            if (IsWritableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n            }\n            this._ownerWritableStream = stream;\n            stream._writer = this;\n            const state = stream._state;\n            if (state === \"writable\") {\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                    defaultWriterReadyPromiseInitialize(this);\n                } else {\n                    defaultWriterReadyPromiseInitializeAsResolved(this);\n                }\n                defaultWriterClosedPromiseInitialize(this);\n            } else if (state === \"erroring\") {\n                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                defaultWriterClosedPromiseInitialize(this);\n            } else if (state === \"closed\") {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n                defaultWriterClosedPromiseInitializeAsResolved(this);\n            } else {\n                const storedError = stream._storedError;\n                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n            }\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the writers lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n         * A producer can use this information to determine the right amount of data to write.\n         *\n         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n         * the writers lock is released.\n         */ get desiredSize() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"desiredSize\");\n            }\n            if (this._ownerWritableStream === undefined) {\n                throw defaultWriterLockException(\"desiredSize\");\n            }\n            return WritableStreamDefaultWriterGetDesiredSize(this);\n        }\n        /**\n         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n         *\n         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n         * rejected.\n         */ get ready() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n            }\n            return this._readyPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n         */ abort(reason = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n            }\n            return WritableStreamDefaultWriterAbort(this, reason);\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n         */ close() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"close\"));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n            }\n            return WritableStreamDefaultWriterClose(this);\n        }\n        /**\n         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n         * now on; otherwise, the writer will appear closed.\n         *\n         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n         * other producers from writing in an interleaved manner.\n         */ releaseLock() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"releaseLock\");\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return;\n            }\n            WritableStreamDefaultWriterRelease(this);\n        }\n        write(chunk = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n            }\n            return WritableStreamDefaultWriterWrite(this, chunk);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n        abort: {\n            enumerable: true\n        },\n        close: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        write: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        },\n        ready: {\n            enumerable: true\n        }\n    });\n    setFunctionName(WritableStreamDefaultWriter.prototype.abort, \"abort\");\n    setFunctionName(WritableStreamDefaultWriter.prototype.close, \"close\");\n    setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, \"releaseLock\");\n    setFunctionName(WritableStreamDefaultWriter.prototype.write, \"write\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStreamDefaultWriter\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStreamDefaultWriter.\n    function IsWritableStreamDefaultWriter(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_ownerWritableStream\")) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultWriter;\n    }\n    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n    function WritableStreamDefaultWriterAbort(writer, reason) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamAbort(stream, reason);\n    }\n    function WritableStreamDefaultWriterClose(writer) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamClose(stream);\n    }\n    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        return WritableStreamDefaultWriterClose(writer);\n    }\n    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n        if (writer._closedPromiseState === \"pending\") {\n            defaultWriterClosedPromiseReject(writer, error);\n        } else {\n            defaultWriterClosedPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n        if (writer._readyPromiseState === \"pending\") {\n            defaultWriterReadyPromiseReject(writer, error);\n        } else {\n            defaultWriterReadyPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterGetDesiredSize(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (state === \"errored\" || state === \"erroring\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n    }\n    function WritableStreamDefaultWriterRelease(writer) {\n        const stream = writer._ownerWritableStream;\n        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n        // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n        // rejected until afterwards. This means that simply testing state will not work.\n        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n        stream._writer = undefined;\n        writer._ownerWritableStream = undefined;\n    }\n    function WritableStreamDefaultWriterWrite(writer, chunk) {\n        const stream = writer._ownerWritableStream;\n        const controller = stream._writableStreamController;\n        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n        if (stream !== writer._ownerWritableStream) {\n            return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n        }\n        const state = stream._state;\n        if (state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n            return promiseRejectedWith(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n        }\n        if (state === \"erroring\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        const promise = WritableStreamAddWriteRequest(stream);\n        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n        return promise;\n    }\n    const closeSentinel = {};\n    /**\n     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n     *\n     * @public\n     */ class WritableStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n         *\n         * @deprecated\n         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n         */ get abortReason() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"abortReason\");\n            }\n            return this._abortReason;\n        }\n        /**\n         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n         */ get signal() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"signal\");\n            }\n            if (this._abortController === undefined) {\n                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n                throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n            }\n            return this._abortController.signal;\n        }\n        /**\n         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n         *\n         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n         * normal lifecycle of interactions with the underlying sink.\n         */ error(e = undefined) {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"error\");\n            }\n            const state = this._controlledWritableStream._state;\n            if (state !== \"writable\") {\n                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n                // just treat it as a no-op.\n                return;\n            }\n            WritableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */ [AbortSteps](reason) {\n            const result = this._abortAlgorithm(reason);\n            WritableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [ErrorSteps]() {\n            ResetQueue(this);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultController.prototype, {\n        abortReason: {\n            enumerable: true\n        },\n        signal: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Abstract operations implementing interface required by the WritableStream.\n    function IsWritableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledWritableStream\")) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultController;\n    }\n    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledWritableStream = stream;\n        stream._writableStreamController = controller;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._abortReason = undefined;\n        controller._abortController = createAbortController();\n        controller._started = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._writeAlgorithm = writeAlgorithm;\n        controller._closeAlgorithm = closeAlgorithm;\n        controller._abortAlgorithm = abortAlgorithm;\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n        const startResult = startAlgorithm();\n        const startPromise = promiseResolvedWith(startResult);\n        uponPromise(startPromise, ()=>{\n            controller._started = true;\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            return null;\n        }, (r)=>{\n            controller._started = true;\n            WritableStreamDealWithRejection(stream, r);\n            return null;\n        });\n    }\n    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        let startAlgorithm;\n        let writeAlgorithm;\n        let closeAlgorithm;\n        let abortAlgorithm;\n        if (underlyingSink.start !== undefined) {\n            startAlgorithm = ()=>underlyingSink.start(controller);\n        } else {\n            startAlgorithm = ()=>undefined;\n        }\n        if (underlyingSink.write !== undefined) {\n            writeAlgorithm = (chunk)=>underlyingSink.write(chunk, controller);\n        } else {\n            writeAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (underlyingSink.close !== undefined) {\n            closeAlgorithm = ()=>underlyingSink.close();\n        } else {\n            closeAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (underlyingSink.abort !== undefined) {\n            abortAlgorithm = (reason)=>underlyingSink.abort(reason);\n        } else {\n            abortAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n    function WritableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._writeAlgorithm = undefined;\n        controller._closeAlgorithm = undefined;\n        controller._abortAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    function WritableStreamDefaultControllerClose(controller) {\n        EnqueueValueWithSize(controller, closeSentinel, 0);\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n        try {\n            return controller._strategySizeAlgorithm(chunk);\n        } catch (chunkSizeE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n            return 1;\n        }\n    }\n    function WritableStreamDefaultControllerGetDesiredSize(controller) {\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        } catch (enqueueE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n            return;\n        }\n        const stream = controller._controlledWritableStream;\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === \"writable\") {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    // Abstract operations for the WritableStreamDefaultController.\n    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n        const stream = controller._controlledWritableStream;\n        if (!controller._started) {\n            return;\n        }\n        if (stream._inFlightWriteRequest !== undefined) {\n            return;\n        }\n        const state = stream._state;\n        if (state === \"erroring\") {\n            WritableStreamFinishErroring(stream);\n            return;\n        }\n        if (controller._queue.length === 0) {\n            return;\n        }\n        const value = PeekQueueValue(controller);\n        if (value === closeSentinel) {\n            WritableStreamDefaultControllerProcessClose(controller);\n        } else {\n            WritableStreamDefaultControllerProcessWrite(controller, value);\n        }\n    }\n    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n        if (controller._controlledWritableStream._state === \"writable\") {\n            WritableStreamDefaultControllerError(controller, error);\n        }\n    }\n    function WritableStreamDefaultControllerProcessClose(controller) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkCloseRequestInFlight(stream);\n        DequeueValue(controller);\n        const sinkClosePromise = controller._closeAlgorithm();\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(sinkClosePromise, ()=>{\n            WritableStreamFinishInFlightClose(stream);\n            return null;\n        }, (reason)=>{\n            WritableStreamFinishInFlightCloseWithError(stream, reason);\n            return null;\n        });\n    }\n    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkFirstWriteRequestInFlight(stream);\n        const sinkWritePromise = controller._writeAlgorithm(chunk);\n        uponPromise(sinkWritePromise, ()=>{\n            WritableStreamFinishInFlightWrite(stream);\n            const state = stream._state;\n            DequeueValue(controller);\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n            }\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            return null;\n        }, (reason)=>{\n            if (stream._state === \"writable\") {\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n            }\n            WritableStreamFinishInFlightWriteWithError(stream, reason);\n            return null;\n        });\n    }\n    function WritableStreamDefaultControllerGetBackpressure(controller) {\n        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n        return desiredSize <= 0;\n    }\n    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n    function WritableStreamDefaultControllerError(controller, error) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        WritableStreamStartErroring(stream, error);\n    }\n    // Helper functions for the WritableStream.\n    function streamBrandCheckException$2(name) {\n        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n    }\n    // Helper functions for the WritableStreamDefaultController.\n    function defaultControllerBrandCheckException$2(name) {\n        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n    }\n    // Helper functions for the WritableStreamDefaultWriter.\n    function defaultWriterBrandCheckException(name) {\n        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n    }\n    function defaultWriterLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n    }\n    function defaultWriterClosedPromiseInitialize(writer) {\n        writer._closedPromise = newPromise((resolve, reject)=>{\n            writer._closedPromise_resolve = resolve;\n            writer._closedPromise_reject = reject;\n            writer._closedPromiseState = \"pending\";\n        });\n    }\n    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseReject(writer, reason);\n    }\n    function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseResolve(writer);\n    }\n    function defaultWriterClosedPromiseReject(writer, reason) {\n        if (writer._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._closedPromise);\n        writer._closedPromise_reject(reason);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = \"rejected\";\n    }\n    function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterClosedPromiseResolve(writer) {\n        if (writer._closedPromise_resolve === undefined) {\n            return;\n        }\n        writer._closedPromise_resolve(undefined);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = \"resolved\";\n    }\n    function defaultWriterReadyPromiseInitialize(writer) {\n        writer._readyPromise = newPromise((resolve, reject)=>{\n            writer._readyPromise_resolve = resolve;\n            writer._readyPromise_reject = reject;\n        });\n        writer._readyPromiseState = \"pending\";\n    }\n    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseReject(writer, reason);\n    }\n    function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    function defaultWriterReadyPromiseReject(writer, reason) {\n        if (writer._readyPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._readyPromise);\n        writer._readyPromise_reject(reason);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = \"rejected\";\n    }\n    function defaultWriterReadyPromiseReset(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n    }\n    function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterReadyPromiseResolve(writer) {\n        if (writer._readyPromise_resolve === undefined) {\n            return;\n        }\n        writer._readyPromise_resolve(undefined);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = \"fulfilled\";\n    }\n    /// <reference lib=\"dom\" />\n    function getGlobals() {\n        if (typeof globalThis !== \"undefined\") {\n            return globalThis;\n        } else if (typeof self !== \"undefined\") {\n            return self;\n        } else if (typeof global !== \"undefined\") {\n            return global;\n        }\n        return undefined;\n    }\n    const globals = getGlobals();\n    /// <reference types=\"node\" />\n    function isDOMExceptionConstructor(ctor) {\n        if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n            return false;\n        }\n        if (ctor.name !== \"DOMException\") {\n            return false;\n        }\n        try {\n            new ctor();\n            return true;\n        } catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Support:\n     * - Web browsers\n     * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)\n     */ function getFromGlobal() {\n        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;\n        return isDOMExceptionConstructor(ctor) ? ctor : undefined;\n    }\n    /**\n     * Support:\n     * - All platforms\n     */ function createPolyfill() {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const ctor = function DOMException(message, name) {\n            this.message = message || \"\";\n            this.name = name || \"Error\";\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, this.constructor);\n            }\n        };\n        setFunctionName(ctor, \"DOMException\");\n        ctor.prototype = Object.create(Error.prototype);\n        Object.defineProperty(ctor.prototype, \"constructor\", {\n            value: ctor,\n            writable: true,\n            configurable: true\n        });\n        return ctor;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-redeclare\n    const DOMException = getFromGlobal() || createPolyfill();\n    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n        const reader = AcquireReadableStreamDefaultReader(source);\n        const writer = AcquireWritableStreamDefaultWriter(dest);\n        source._disturbed = true;\n        let shuttingDown = false;\n        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n        let currentWrite = promiseResolvedWith(undefined);\n        return newPromise((resolve, reject)=>{\n            let abortAlgorithm;\n            if (signal !== undefined) {\n                abortAlgorithm = ()=>{\n                    const error = signal.reason !== undefined ? signal.reason : new DOMException(\"Aborted\", \"AbortError\");\n                    const actions = [];\n                    if (!preventAbort) {\n                        actions.push(()=>{\n                            if (dest._state === \"writable\") {\n                                return WritableStreamAbort(dest, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    if (!preventCancel) {\n                        actions.push(()=>{\n                            if (source._state === \"readable\") {\n                                return ReadableStreamCancel(source, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    shutdownWithAction(()=>Promise.all(actions.map((action)=>action())), true, error);\n                };\n                if (signal.aborted) {\n                    abortAlgorithm();\n                    return;\n                }\n                signal.addEventListener(\"abort\", abortAlgorithm);\n            }\n            // Using reader and writer, read all chunks from this and write them to dest\n            // - Backpressure must be enforced\n            // - Shutdown must stop all activity\n            function pipeLoop() {\n                return newPromise((resolveLoop, rejectLoop)=>{\n                    function next(done) {\n                        if (done) {\n                            resolveLoop();\n                        } else {\n                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                            PerformPromiseThen(pipeStep(), next, rejectLoop);\n                        }\n                    }\n                    next(false);\n                });\n            }\n            function pipeStep() {\n                if (shuttingDown) {\n                    return promiseResolvedWith(true);\n                }\n                return PerformPromiseThen(writer._readyPromise, ()=>{\n                    return newPromise((resolveRead, rejectRead)=>{\n                        ReadableStreamDefaultReaderRead(reader, {\n                            _chunkSteps: (chunk)=>{\n                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                                resolveRead(false);\n                            },\n                            _closeSteps: ()=>resolveRead(true),\n                            _errorSteps: rejectRead\n                        });\n                    });\n                });\n            }\n            // Errors must be propagated forward\n            isOrBecomesErrored(source, reader._closedPromise, (storedError)=>{\n                if (!preventAbort) {\n                    shutdownWithAction(()=>WritableStreamAbort(dest, storedError), true, storedError);\n                } else {\n                    shutdown(true, storedError);\n                }\n                return null;\n            });\n            // Errors must be propagated backward\n            isOrBecomesErrored(dest, writer._closedPromise, (storedError)=>{\n                if (!preventCancel) {\n                    shutdownWithAction(()=>ReadableStreamCancel(source, storedError), true, storedError);\n                } else {\n                    shutdown(true, storedError);\n                }\n                return null;\n            });\n            // Closing must be propagated forward\n            isOrBecomesClosed(source, reader._closedPromise, ()=>{\n                if (!preventClose) {\n                    shutdownWithAction(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                } else {\n                    shutdown();\n                }\n                return null;\n            });\n            // Closing must be propagated backward\n            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === \"closed\") {\n                const destClosed = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                if (!preventCancel) {\n                    shutdownWithAction(()=>ReadableStreamCancel(source, destClosed), true, destClosed);\n                } else {\n                    shutdown(true, destClosed);\n                }\n            }\n            setPromiseIsHandledToTrue(pipeLoop());\n            function waitForWritesToFinish() {\n                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n                // for that too.\n                const oldCurrentWrite = currentWrite;\n                return PerformPromiseThen(currentWrite, ()=>oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n            }\n            function isOrBecomesErrored(stream, promise, action) {\n                if (stream._state === \"errored\") {\n                    action(stream._storedError);\n                } else {\n                    uponRejection(promise, action);\n                }\n            }\n            function isOrBecomesClosed(stream, promise, action) {\n                if (stream._state === \"closed\") {\n                    action();\n                } else {\n                    uponFulfillment(promise, action);\n                }\n            }\n            function shutdownWithAction(action, originalIsError, originalError) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), doTheRest);\n                } else {\n                    doTheRest();\n                }\n                function doTheRest() {\n                    uponPromise(action(), ()=>finalize(originalIsError, originalError), (newError)=>finalize(true, newError));\n                    return null;\n                }\n            }\n            function shutdown(isError, error) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), ()=>finalize(isError, error));\n                } else {\n                    finalize(isError, error);\n                }\n            }\n            function finalize(isError, error) {\n                WritableStreamDefaultWriterRelease(writer);\n                ReadableStreamReaderGenericRelease(reader);\n                if (signal !== undefined) {\n                    signal.removeEventListener(\"abort\", abortAlgorithm);\n                }\n                if (isError) {\n                    reject(error);\n                } else {\n                    resolve(undefined);\n                }\n                return null;\n            }\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n     *\n     * @public\n     */ class ReadableStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n         */ get desiredSize() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"desiredSize\");\n            }\n            return ReadableStreamDefaultControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */ close() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"close\");\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits close\");\n            }\n            ReadableStreamDefaultControllerClose(this);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"enqueue\");\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits enqueue\");\n            }\n            return ReadableStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */ error(e = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"error\");\n            }\n            ReadableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */ [CancelSteps](reason) {\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [PullSteps](readRequest) {\n            const stream = this._controlledReadableStream;\n            if (this._queue.length > 0) {\n                const chunk = DequeueValue(this);\n                if (this._closeRequested && this._queue.length === 0) {\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\n                    ReadableStreamClose(stream);\n                } else {\n                    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                }\n                readRequest._chunkSteps(chunk);\n            } else {\n                ReadableStreamAddReadRequest(stream, readRequest);\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n        }\n        /** @internal */ [ReleaseSteps]() {\n        // Do nothing.\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultController.prototype, {\n        close: {\n            enumerable: true\n        },\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStreamDefaultController.prototype.close, \"close\");\n    setFunctionName(ReadableStreamDefaultController.prototype.enqueue, \"enqueue\");\n    setFunctionName(ReadableStreamDefaultController.prototype.error, \"error\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStreamDefaultController.\n    function IsReadableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableStream\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultController;\n    }\n    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, ()=>{\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }\n            return null;\n        }, (e)=>{\n            ReadableStreamDefaultControllerError(controller, e);\n            return null;\n        });\n    }\n    function ReadableStreamDefaultControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableStream;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n    function ReadableStreamDefaultControllerClose(controller) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        controller._closeRequested = true;\n        if (controller._queue.length === 0) {\n            ReadableStreamDefaultControllerClearAlgorithms(controller);\n            ReadableStreamClose(stream);\n        }\n    }\n    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            ReadableStreamFulfillReadRequest(stream, chunk, false);\n        } else {\n            let chunkSize;\n            try {\n                chunkSize = controller._strategySizeAlgorithm(chunk);\n            } catch (chunkSizeE) {\n                ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                throw chunkSizeE;\n            }\n            try {\n                EnqueueValueWithSize(controller, chunk, chunkSize);\n            } catch (enqueueE) {\n                ReadableStreamDefaultControllerError(controller, enqueueE);\n                throw enqueueE;\n            }\n        }\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    function ReadableStreamDefaultControllerError(controller, e) {\n        const stream = controller._controlledReadableStream;\n        if (stream._state !== \"readable\") {\n            return;\n        }\n        ResetQueue(controller);\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (state === \"errored\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    // This is used in the implementation of TransformStream.\n    function ReadableStreamDefaultControllerHasBackpressure(controller) {\n        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n            return false;\n        }\n        return true;\n    }\n    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (!controller._closeRequested && state === \"readable\") {\n            return true;\n        }\n        return false;\n    }\n    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledReadableStream = stream;\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._started = false;\n        controller._closeRequested = false;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), ()=>{\n            controller._started = true;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            return null;\n        }, (r)=>{\n            ReadableStreamDefaultControllerError(controller, r);\n            return null;\n        });\n    }\n    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        let startAlgorithm;\n        let pullAlgorithm;\n        let cancelAlgorithm;\n        if (underlyingSource.start !== undefined) {\n            startAlgorithm = ()=>underlyingSource.start(controller);\n        } else {\n            startAlgorithm = ()=>undefined;\n        }\n        if (underlyingSource.pull !== undefined) {\n            pullAlgorithm = ()=>underlyingSource.pull(controller);\n        } else {\n            pullAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (underlyingSource.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>underlyingSource.cancel(reason);\n        } else {\n            cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // Helper functions for the ReadableStreamDefaultController.\n    function defaultControllerBrandCheckException$1(name) {\n        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n    }\n    function ReadableStreamTee(stream, cloneForBranch2) {\n        if (IsReadableByteStreamController(stream._readableStreamController)) {\n            return ReadableByteStreamTee(stream);\n        }\n        return ReadableStreamDefaultTee(stream);\n    }\n    function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgain = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve)=>{\n            resolveCancelPromise = resolve;\n        });\n        function pullAlgorithm() {\n            if (reading) {\n                readAgain = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    _queueMicrotask(()=>{\n                        readAgain = false;\n                        const chunk1 = chunk;\n                        const chunk2 = chunk;\n                        // There is no way to access the cloning code right now in the reference implementation.\n                        // If we add one then we'll need an implementation for serializable objects.\n                        // if (!canceled2 && cloneForBranch2) {\n                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                        // }\n                        if (!canceled1) {\n                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgain) {\n                            pullAlgorithm();\n                        }\n                    });\n                },\n                _closeSteps: ()=>{\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n        // do nothing\n        }\n        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n        uponRejection(reader._closedPromise, (r)=>{\n            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n            if (!canceled1 || !canceled2) {\n                resolveCancelPromise(undefined);\n            }\n            return null;\n        });\n        return [\n            branch1,\n            branch2\n        ];\n    }\n    function ReadableByteStreamTee(stream) {\n        let reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgainForBranch1 = false;\n        let readAgainForBranch2 = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve)=>{\n            resolveCancelPromise = resolve;\n        });\n        function forwardReaderError(thisReader) {\n            uponRejection(thisReader._closedPromise, (r)=>{\n                if (thisReader !== reader) {\n                    return null;\n                }\n                ReadableByteStreamControllerError(branch1._readableStreamController, r);\n                ReadableByteStreamControllerError(branch2._readableStreamController, r);\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n                return null;\n            });\n        }\n        function pullWithDefaultReader() {\n            if (IsReadableStreamBYOBReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamDefaultReader(stream);\n                forwardReaderError(reader);\n            }\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    _queueMicrotask(()=>{\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const chunk1 = chunk;\n                        let chunk2 = chunk;\n                        if (!canceled1 && !canceled2) {\n                            try {\n                                chunk2 = CloneAsUint8Array(chunk);\n                            } catch (cloneE) {\n                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                        }\n                        if (!canceled1) {\n                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        } else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: ()=>{\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableByteStreamControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableByteStreamControllerClose(branch2._readableStreamController);\n                    }\n                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                    }\n                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n        }\n        function pullWithBYOBReader(view, forBranch2) {\n            if (IsReadableStreamDefaultReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamBYOBReader(stream);\n                forwardReaderError(reader);\n            }\n            const byobBranch = forBranch2 ? branch2 : branch1;\n            const otherBranch = forBranch2 ? branch1 : branch2;\n            const readIntoRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    _queueMicrotask(()=>{\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                        if (!otherCanceled) {\n                            let clonedChunk;\n                            try {\n                                clonedChunk = CloneAsUint8Array(chunk);\n                            } catch (cloneE) {\n                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                            if (!byobCanceled) {\n                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                            }\n                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                        } else if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        } else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: (chunk)=>{\n                    reading = false;\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                    if (!byobCanceled) {\n                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                    }\n                    if (!otherCanceled) {\n                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                    }\n                    if (chunk !== undefined) {\n                        if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                        }\n                    }\n                    if (!byobCanceled || !otherCanceled) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n        }\n        function pull1Algorithm() {\n            if (reading) {\n                readAgainForBranch1 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            } else {\n                pullWithBYOBReader(byobRequest._view, false);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function pull2Algorithm() {\n            if (reading) {\n                readAgainForBranch2 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            } else {\n                pullWithBYOBReader(byobRequest._view, true);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n            return;\n        }\n        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n        forwardReaderError(reader);\n        return [\n            branch1,\n            branch2\n        ];\n    }\n    function isReadableStreamLike(stream) {\n        return typeIsObject(stream) && typeof stream.getReader !== \"undefined\";\n    }\n    function ReadableStreamFrom(source) {\n        if (isReadableStreamLike(source)) {\n            return ReadableStreamFromDefaultReader(source.getReader());\n        }\n        return ReadableStreamFromIterable(source);\n    }\n    function ReadableStreamFromIterable(asyncIterable) {\n        let stream;\n        const iteratorRecord = GetIterator(asyncIterable, \"async\");\n        const startAlgorithm = noop;\n        function pullAlgorithm() {\n            let nextResult;\n            try {\n                nextResult = IteratorNext(iteratorRecord);\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            const nextPromise = promiseResolvedWith(nextResult);\n            return transformPromiseWith(nextPromise, (iterResult)=>{\n                if (!typeIsObject(iterResult)) {\n                    throw new TypeError(\"The promise returned by the iterator.next() method must fulfill with an object\");\n                }\n                const done = IteratorComplete(iterResult);\n                if (done) {\n                    ReadableStreamDefaultControllerClose(stream._readableStreamController);\n                } else {\n                    const value = IteratorValue(iterResult);\n                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n                }\n            });\n        }\n        function cancelAlgorithm(reason) {\n            const iterator = iteratorRecord.iterator;\n            let returnMethod;\n            try {\n                returnMethod = GetMethod(iterator, \"return\");\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            if (returnMethod === undefined) {\n                return promiseResolvedWith(undefined);\n            }\n            let returnResult;\n            try {\n                returnResult = reflectCall(returnMethod, iterator, [\n                    reason\n                ]);\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            const returnPromise = promiseResolvedWith(returnResult);\n            return transformPromiseWith(returnPromise, (iterResult)=>{\n                if (!typeIsObject(iterResult)) {\n                    throw new TypeError(\"The promise returned by the iterator.return() method must fulfill with an object\");\n                }\n                return undefined;\n            });\n        }\n        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n        return stream;\n    }\n    function ReadableStreamFromDefaultReader(reader) {\n        let stream;\n        const startAlgorithm = noop;\n        function pullAlgorithm() {\n            let readPromise;\n            try {\n                readPromise = reader.read();\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            return transformPromiseWith(readPromise, (readResult)=>{\n                if (!typeIsObject(readResult)) {\n                    throw new TypeError(\"The promise returned by the reader.read() method must fulfill with an object\");\n                }\n                if (readResult.done) {\n                    ReadableStreamDefaultControllerClose(stream._readableStreamController);\n                } else {\n                    const value = readResult.value;\n                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n                }\n            });\n        }\n        function cancelAlgorithm(reason) {\n            try {\n                return promiseResolvedWith(reader.cancel(reason));\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n        }\n        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n        return stream;\n    }\n    function convertUnderlyingDefaultOrByteSource(source, context) {\n        assertDictionary(source, context);\n        const original = source;\n        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n        const pull = original === null || original === void 0 ? void 0 : original.pull;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        return {\n            autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n            cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n            pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n            start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n        };\n    }\n    function convertUnderlyingSourceCancelCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    function convertUnderlyingSourcePullCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>promiseCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertUnderlyingSourceStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertReadableStreamType(type, context) {\n        type = `${type}`;\n        if (type !== \"bytes\") {\n            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n        }\n        return type;\n    }\n    function convertIteratorOptions(options, context) {\n        assertDictionary(options, context);\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        return {\n            preventCancel: Boolean(preventCancel)\n        };\n    }\n    function convertPipeOptions(options, context) {\n        assertDictionary(options, context);\n        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n        const signal = options === null || options === void 0 ? void 0 : options.signal;\n        if (signal !== undefined) {\n            assertAbortSignal(signal, `${context} has member 'signal' that`);\n        }\n        return {\n            preventAbort: Boolean(preventAbort),\n            preventCancel: Boolean(preventCancel),\n            preventClose: Boolean(preventClose),\n            signal\n        };\n    }\n    function assertAbortSignal(signal, context) {\n        if (!isAbortSignal(signal)) {\n            throw new TypeError(`${context} is not an AbortSignal.`);\n        }\n    }\n    function convertReadableWritablePair(pair, context) {\n        assertDictionary(pair, context);\n        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n        assertRequiredField(readable, \"readable\", \"ReadableWritablePair\");\n        assertReadableStream(readable, `${context} has member 'readable' that`);\n        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n        assertRequiredField(writable, \"writable\", \"ReadableWritablePair\");\n        assertWritableStream(writable, `${context} has member 'writable' that`);\n        return {\n            readable,\n            writable\n        };\n    }\n    /**\n     * A readable stream represents a source of data, from which you can read.\n     *\n     * @public\n     */ class ReadableStream {\n        constructor(rawUnderlyingSource = {}, rawStrategy = {}){\n            if (rawUnderlyingSource === undefined) {\n                rawUnderlyingSource = null;\n            } else {\n                assertObject(rawUnderlyingSource, \"First parameter\");\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, \"First parameter\");\n            InitializeReadableStream(this);\n            if (underlyingSource.type === \"bytes\") {\n                if (strategy.size !== undefined) {\n                    throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                }\n                const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n            } else {\n                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n            }\n        }\n        /**\n         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n         */ get locked() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"locked\");\n            }\n            return IsReadableStreamLocked(this);\n        }\n        /**\n         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n         *\n         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n         * method, which might or might not use it.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot cancel a stream that already has a reader\"));\n            }\n            return ReadableStreamCancel(this, reason);\n        }\n        getReader(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"getReader\");\n            }\n            const options = convertReaderOptions(rawOptions, \"First parameter\");\n            if (options.mode === undefined) {\n                return AcquireReadableStreamDefaultReader(this);\n            }\n            return AcquireReadableStreamBYOBReader(this);\n        }\n        pipeThrough(rawTransform, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"pipeThrough\");\n            }\n            assertRequiredArgument(rawTransform, 1, \"pipeThrough\");\n            const transform = convertReadableWritablePair(rawTransform, \"First parameter\");\n            const options = convertPipeOptions(rawOptions, \"Second parameter\");\n            if (IsReadableStreamLocked(this)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n            }\n            if (IsWritableStreamLocked(transform.writable)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n            }\n            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n            setPromiseIsHandledToTrue(promise);\n            return transform.readable;\n        }\n        pipeTo(destination, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n            }\n            if (destination === undefined) {\n                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n            }\n            if (!IsWritableStream(destination)) {\n                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n            }\n            let options;\n            try {\n                options = convertPipeOptions(rawOptions, \"Second parameter\");\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"));\n            }\n            if (IsWritableStreamLocked(destination)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"));\n            }\n            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        }\n        /**\n         * Tees this readable stream, returning a two-element array containing the two resulting branches as\n         * new {@link ReadableStream} instances.\n         *\n         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n         * propagated to the stream's underlying source.\n         *\n         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n         * this could allow interference between the two branches.\n         */ tee() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"tee\");\n            }\n            const branches = ReadableStreamTee(this);\n            return CreateArrayFromList(branches);\n        }\n        values(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"values\");\n            }\n            const options = convertIteratorOptions(rawOptions, \"First parameter\");\n            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n        }\n        /**\n         * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n         *\n         * This can be used to adapt various kinds of objects into a readable stream,\n         * such as an array, an async generator, or a Node.js readable stream.\n         */ static from(asyncIterable) {\n            return ReadableStreamFrom(asyncIterable);\n        }\n    }\n    Object.defineProperties(ReadableStream, {\n        from: {\n            enumerable: true\n        }\n    });\n    Object.defineProperties(ReadableStream.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        getReader: {\n            enumerable: true\n        },\n        pipeThrough: {\n            enumerable: true\n        },\n        pipeTo: {\n            enumerable: true\n        },\n        tee: {\n            enumerable: true\n        },\n        values: {\n            enumerable: true\n        },\n        locked: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStream.from, \"from\");\n    setFunctionName(ReadableStream.prototype.cancel, \"cancel\");\n    setFunctionName(ReadableStream.prototype.getReader, \"getReader\");\n    setFunctionName(ReadableStream.prototype.pipeThrough, \"pipeThrough\");\n    setFunctionName(ReadableStream.prototype.pipeTo, \"pipeTo\");\n    setFunctionName(ReadableStream.prototype.tee, \"tee\");\n    setFunctionName(ReadableStream.prototype.values, \"values\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStream\",\n            configurable: true\n        });\n    }\n    if (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n            value: ReadableStream.prototype.values,\n            writable: true,\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStream.\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n        return stream;\n    }\n    function InitializeReadableStream(stream) {\n        stream._state = \"readable\";\n        stream._reader = undefined;\n        stream._storedError = undefined;\n        stream._disturbed = false;\n    }\n    function IsReadableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readableStreamController\")) {\n            return false;\n        }\n        return x instanceof ReadableStream;\n    }\n    function IsReadableStreamLocked(stream) {\n        if (stream._reader === undefined) {\n            return false;\n        }\n        return true;\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamCancel(stream, reason) {\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        ReadableStreamClose(stream);\n        const reader = stream._reader;\n        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n            const readIntoRequests = reader._readIntoRequests;\n            reader._readIntoRequests = new SimpleQueue();\n            readIntoRequests.forEach((readIntoRequest)=>{\n                readIntoRequest._closeSteps(undefined);\n            });\n        }\n        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n        return transformPromiseWith(sourceCancelPromise, noop);\n    }\n    function ReadableStreamClose(stream) {\n        stream._state = \"closed\";\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseResolve(reader);\n        if (IsReadableStreamDefaultReader(reader)) {\n            const readRequests = reader._readRequests;\n            reader._readRequests = new SimpleQueue();\n            readRequests.forEach((readRequest)=>{\n                readRequest._closeSteps();\n            });\n        }\n    }\n    function ReadableStreamError(stream, e) {\n        stream._state = \"errored\";\n        stream._storedError = e;\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseReject(reader, e);\n        if (IsReadableStreamDefaultReader(reader)) {\n            ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n        } else {\n            ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamBrandCheckException$1(name) {\n        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n    }\n    function convertQueuingStrategyInit(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        assertRequiredField(highWaterMark, \"highWaterMark\", \"QueuingStrategyInit\");\n        return {\n            highWaterMark: convertUnrestrictedDouble(highWaterMark)\n        };\n    }\n    // The size function must not have a prototype property nor be a constructor\n    const byteLengthSizeFunction = (chunk)=>{\n        return chunk.byteLength;\n    };\n    setFunctionName(byteLengthSizeFunction, \"size\");\n    /**\n     * A queuing strategy that counts the number of bytes in each chunk.\n     *\n     * @public\n     */ class ByteLengthQueuingStrategy {\n        constructor(options){\n            assertRequiredArgument(options, 1, \"ByteLengthQueuingStrategy\");\n            options = convertQueuingStrategyInit(options, \"First parameter\");\n            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */ get highWaterMark() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"highWaterMark\");\n            }\n            return this._byteLengthQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by returning the value of its `byteLength` property.\n         */ get size() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"size\");\n            }\n            return byteLengthSizeFunction;\n        }\n    }\n    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n        highWaterMark: {\n            enumerable: true\n        },\n        size: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ByteLengthQueuingStrategy\",\n            configurable: true\n        });\n    }\n    // Helper functions for the ByteLengthQueuingStrategy.\n    function byteLengthBrandCheckException(name) {\n        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n    }\n    function IsByteLengthQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_byteLengthQueuingStrategyHighWaterMark\")) {\n            return false;\n        }\n        return x instanceof ByteLengthQueuingStrategy;\n    }\n    // The size function must not have a prototype property nor be a constructor\n    const countSizeFunction = ()=>{\n        return 1;\n    };\n    setFunctionName(countSizeFunction, \"size\");\n    /**\n     * A queuing strategy that counts the number of chunks.\n     *\n     * @public\n     */ class CountQueuingStrategy {\n        constructor(options){\n            assertRequiredArgument(options, 1, \"CountQueuingStrategy\");\n            options = convertQueuingStrategyInit(options, \"First parameter\");\n            this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */ get highWaterMark() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"highWaterMark\");\n            }\n            return this._countQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by always returning 1.\n         * This ensures that the total queue size is a count of the number of chunks in the queue.\n         */ get size() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"size\");\n            }\n            return countSizeFunction;\n        }\n    }\n    Object.defineProperties(CountQueuingStrategy.prototype, {\n        highWaterMark: {\n            enumerable: true\n        },\n        size: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: \"CountQueuingStrategy\",\n            configurable: true\n        });\n    }\n    // Helper functions for the CountQueuingStrategy.\n    function countBrandCheckException(name) {\n        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n    }\n    function IsCountQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_countQueuingStrategyHighWaterMark\")) {\n            return false;\n        }\n        return x instanceof CountQueuingStrategy;\n    }\n    function convertTransformer(original, context) {\n        assertDictionary(original, context);\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n        const flush = original === null || original === void 0 ? void 0 : original.flush;\n        const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const transform = original === null || original === void 0 ? void 0 : original.transform;\n        const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n        return {\n            cancel: cancel === undefined ? undefined : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n            flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n            readableType,\n            start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n            transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n            writableType\n        };\n    }\n    function convertTransformerFlushCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>promiseCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertTransformerStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertTransformerTransformCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller)=>promiseCall(fn, original, [\n                chunk,\n                controller\n            ]);\n    }\n    function convertTransformerCancelCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    // Class TransformStream\n    /**\n     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n     * made available for reading from the readable side.\n     *\n     * @public\n     */ class TransformStream {\n        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}){\n            if (rawTransformer === undefined) {\n                rawTransformer = null;\n            }\n            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, \"Second parameter\");\n            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, \"Third parameter\");\n            const transformer = convertTransformer(rawTransformer, \"First parameter\");\n            if (transformer.readableType !== undefined) {\n                throw new RangeError(\"Invalid readableType specified\");\n            }\n            if (transformer.writableType !== undefined) {\n                throw new RangeError(\"Invalid writableType specified\");\n            }\n            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n            let startPromise_resolve;\n            const startPromise = newPromise((resolve)=>{\n                startPromise_resolve = resolve;\n            });\n            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n            if (transformer.start !== undefined) {\n                startPromise_resolve(transformer.start(this._transformStreamController));\n            } else {\n                startPromise_resolve(undefined);\n            }\n        }\n        /**\n         * The readable side of the transform stream.\n         */ get readable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"readable\");\n            }\n            return this._readable;\n        }\n        /**\n         * The writable side of the transform stream.\n         */ get writable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"writable\");\n            }\n            return this._writable;\n        }\n    }\n    Object.defineProperties(TransformStream.prototype, {\n        readable: {\n            enumerable: true\n        },\n        writable: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"TransformStream\",\n            configurable: true\n        });\n    }\n    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n        function startAlgorithm() {\n            return startPromise;\n        }\n        function writeAlgorithm(chunk) {\n            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n        }\n        function abortAlgorithm(reason) {\n            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n        }\n        function closeAlgorithm() {\n            return TransformStreamDefaultSinkCloseAlgorithm(stream);\n        }\n        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n        function pullAlgorithm() {\n            return TransformStreamDefaultSourcePullAlgorithm(stream);\n        }\n        function cancelAlgorithm(reason) {\n            return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n        }\n        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n        stream._backpressure = undefined;\n        stream._backpressureChangePromise = undefined;\n        stream._backpressureChangePromise_resolve = undefined;\n        TransformStreamSetBackpressure(stream, true);\n        stream._transformStreamController = undefined;\n    }\n    function IsTransformStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_transformStreamController\")) {\n            return false;\n        }\n        return x instanceof TransformStream;\n    }\n    // This is a no-op if both sides are already errored.\n    function TransformStreamError(stream, e) {\n        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n    }\n    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n        TransformStreamUnblockWrite(stream);\n    }\n    function TransformStreamUnblockWrite(stream) {\n        if (stream._backpressure) {\n            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n            // _backpressure is set.\n            TransformStreamSetBackpressure(stream, false);\n        }\n    }\n    function TransformStreamSetBackpressure(stream, backpressure) {\n        // Passes also when called during construction.\n        if (stream._backpressureChangePromise !== undefined) {\n            stream._backpressureChangePromise_resolve();\n        }\n        stream._backpressureChangePromise = newPromise((resolve)=>{\n            stream._backpressureChangePromise_resolve = resolve;\n        });\n        stream._backpressure = backpressure;\n    }\n    // Class TransformStreamDefaultController\n    /**\n     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n     *\n     * @public\n     */ class TransformStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n         */ get desiredSize() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"desiredSize\");\n            }\n            const readableController = this._controlledTransformStream._readable._readableStreamController;\n            return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"enqueue\");\n            }\n            TransformStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors both the readable side and the writable side of the controlled transform stream, making all future\n         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n         */ error(reason = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"error\");\n            }\n            TransformStreamDefaultControllerError(this, reason);\n        }\n        /**\n         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n         * transformer only needs to consume a portion of the chunks written to the writable side.\n         */ terminate() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"terminate\");\n            }\n            TransformStreamDefaultControllerTerminate(this);\n        }\n    }\n    Object.defineProperties(TransformStreamDefaultController.prototype, {\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        terminate: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    setFunctionName(TransformStreamDefaultController.prototype.enqueue, \"enqueue\");\n    setFunctionName(TransformStreamDefaultController.prototype.error, \"error\");\n    setFunctionName(TransformStreamDefaultController.prototype.terminate, \"terminate\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"TransformStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Transform Stream Default Controller Abstract Operations\n    function IsTransformStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledTransformStream\")) {\n            return false;\n        }\n        return x instanceof TransformStreamDefaultController;\n    }\n    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {\n        controller._controlledTransformStream = stream;\n        stream._transformStreamController = controller;\n        controller._transformAlgorithm = transformAlgorithm;\n        controller._flushAlgorithm = flushAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        controller._finishPromise = undefined;\n        controller._finishPromise_resolve = undefined;\n        controller._finishPromise_reject = undefined;\n    }\n    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n        const controller = Object.create(TransformStreamDefaultController.prototype);\n        let transformAlgorithm;\n        let flushAlgorithm;\n        let cancelAlgorithm;\n        if (transformer.transform !== undefined) {\n            transformAlgorithm = (chunk)=>transformer.transform(chunk, controller);\n        } else {\n            transformAlgorithm = (chunk)=>{\n                try {\n                    TransformStreamDefaultControllerEnqueue(controller, chunk);\n                    return promiseResolvedWith(undefined);\n                } catch (transformResultE) {\n                    return promiseRejectedWith(transformResultE);\n                }\n            };\n        }\n        if (transformer.flush !== undefined) {\n            flushAlgorithm = ()=>transformer.flush(controller);\n        } else {\n            flushAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (transformer.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>transformer.cancel(reason);\n        } else {\n            cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n    }\n    function TransformStreamDefaultControllerClearAlgorithms(controller) {\n        controller._transformAlgorithm = undefined;\n        controller._flushAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n    }\n    function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n            throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n        }\n        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n        // accept TransformStreamDefaultControllerEnqueue() calls.\n        try {\n            ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n        } catch (e) {\n            // This happens when readableStrategy.size() throws.\n            TransformStreamErrorWritableAndUnblockWrite(stream, e);\n            throw stream._readable._storedError;\n        }\n        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n        if (backpressure !== stream._backpressure) {\n            TransformStreamSetBackpressure(stream, true);\n        }\n    }\n    function TransformStreamDefaultControllerError(controller, e) {\n        TransformStreamError(controller._controlledTransformStream, e);\n    }\n    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n        const transformPromise = controller._transformAlgorithm(chunk);\n        return transformPromiseWith(transformPromise, undefined, (r)=>{\n            TransformStreamError(controller._controlledTransformStream, r);\n            throw r;\n        });\n    }\n    function TransformStreamDefaultControllerTerminate(controller) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        ReadableStreamDefaultControllerClose(readableController);\n        const error = new TypeError(\"TransformStream terminated\");\n        TransformStreamErrorWritableAndUnblockWrite(stream, error);\n    }\n    // TransformStreamDefaultSink Algorithms\n    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n        const controller = stream._transformStreamController;\n        if (stream._backpressure) {\n            const backpressureChangePromise = stream._backpressureChangePromise;\n            return transformPromiseWith(backpressureChangePromise, ()=>{\n                const writable = stream._writable;\n                const state = writable._state;\n                if (state === \"erroring\") {\n                    throw writable._storedError;\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n            });\n        }\n        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n    }\n    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n        const controller = stream._transformStreamController;\n        if (controller._finishPromise !== undefined) {\n            return controller._finishPromise;\n        }\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n        const readable = stream._readable;\n        // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\n        // we don't run the _cancelAlgorithm again.\n        controller._finishPromise = newPromise((resolve, reject)=>{\n            controller._finishPromise_resolve = resolve;\n            controller._finishPromise_reject = reject;\n        });\n        const cancelPromise = controller._cancelAlgorithm(reason);\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(cancelPromise, ()=>{\n            if (readable._state === \"errored\") {\n                defaultControllerFinishPromiseReject(controller, readable._storedError);\n            } else {\n                ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n                defaultControllerFinishPromiseResolve(controller);\n            }\n            return null;\n        }, (r)=>{\n            ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n            defaultControllerFinishPromiseReject(controller, r);\n            return null;\n        });\n        return controller._finishPromise;\n    }\n    function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n        const controller = stream._transformStreamController;\n        if (controller._finishPromise !== undefined) {\n            return controller._finishPromise;\n        }\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n        const readable = stream._readable;\n        // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\n        // we don't also run the _cancelAlgorithm.\n        controller._finishPromise = newPromise((resolve, reject)=>{\n            controller._finishPromise_resolve = resolve;\n            controller._finishPromise_reject = reject;\n        });\n        const flushPromise = controller._flushAlgorithm();\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(flushPromise, ()=>{\n            if (readable._state === \"errored\") {\n                defaultControllerFinishPromiseReject(controller, readable._storedError);\n            } else {\n                ReadableStreamDefaultControllerClose(readable._readableStreamController);\n                defaultControllerFinishPromiseResolve(controller);\n            }\n            return null;\n        }, (r)=>{\n            ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n            defaultControllerFinishPromiseReject(controller, r);\n            return null;\n        });\n        return controller._finishPromise;\n    }\n    // TransformStreamDefaultSource Algorithms\n    function TransformStreamDefaultSourcePullAlgorithm(stream) {\n        // Invariant. Enforced by the promises returned by start() and pull().\n        TransformStreamSetBackpressure(stream, false);\n        // Prevent the next pull() call until there is backpressure.\n        return stream._backpressureChangePromise;\n    }\n    function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {\n        const controller = stream._transformStreamController;\n        if (controller._finishPromise !== undefined) {\n            return controller._finishPromise;\n        }\n        // stream._writable cannot change after construction, so caching it across a call to user code is safe.\n        const writable = stream._writable;\n        // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or\n        // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the\n        // _flushAlgorithm.\n        controller._finishPromise = newPromise((resolve, reject)=>{\n            controller._finishPromise_resolve = resolve;\n            controller._finishPromise_reject = reject;\n        });\n        const cancelPromise = controller._cancelAlgorithm(reason);\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(cancelPromise, ()=>{\n            if (writable._state === \"errored\") {\n                defaultControllerFinishPromiseReject(controller, writable._storedError);\n            } else {\n                WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);\n                TransformStreamUnblockWrite(stream);\n                defaultControllerFinishPromiseResolve(controller);\n            }\n            return null;\n        }, (r)=>{\n            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);\n            TransformStreamUnblockWrite(stream);\n            defaultControllerFinishPromiseReject(controller, r);\n            return null;\n        });\n        return controller._finishPromise;\n    }\n    // Helper functions for the TransformStreamDefaultController.\n    function defaultControllerBrandCheckException(name) {\n        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n    }\n    function defaultControllerFinishPromiseResolve(controller) {\n        if (controller._finishPromise_resolve === undefined) {\n            return;\n        }\n        controller._finishPromise_resolve();\n        controller._finishPromise_resolve = undefined;\n        controller._finishPromise_reject = undefined;\n    }\n    function defaultControllerFinishPromiseReject(controller, reason) {\n        if (controller._finishPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(controller._finishPromise);\n        controller._finishPromise_reject(reason);\n        controller._finishPromise_resolve = undefined;\n        controller._finishPromise_reject = undefined;\n    }\n    // Helper functions for the TransformStream.\n    function streamBrandCheckException(name) {\n        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n    }\n    exports1.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n    exports1.CountQueuingStrategy = CountQueuingStrategy;\n    exports1.ReadableByteStreamController = ReadableByteStreamController;\n    exports1.ReadableStream = ReadableStream;\n    exports1.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n    exports1.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n    exports1.ReadableStreamDefaultController = ReadableStreamDefaultController;\n    exports1.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n    exports1.TransformStream = TransformStream;\n    exports1.TransformStreamDefaultController = TransformStreamDefaultController;\n    exports1.WritableStream = WritableStream;\n    exports1.WritableStreamDefaultController = WritableStreamDefaultController;\n    exports1.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n}); //# sourceMappingURL=ponyfill.es2018.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL2Rpc3QvcG9ueWZpbGwuZXMyMDE4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQyxHQUNBLFVBQVVBLE9BQU0sRUFBRUMsT0FBTztJQUN0QixLQUFpRCxHQUFjQSxRQUFRQyxXQUN2RSxDQUNrSDtBQUN0SCxHQUFHLElBQUksRUFBRyxTQUFVQSxRQUFPO0lBQUk7SUFFM0IscUNBQXFDO0lBQ3JDLE1BQU1PLGlCQUFpQixPQUFPQyxXQUFXLGNBQWMsT0FBT0EsT0FBT0MsUUFBUSxLQUFLLFdBQzlFRCxTQUNBRSxDQUFBQSxjQUFlLENBQUMsT0FBTyxFQUFFQSxZQUFZLENBQUMsQ0FBQztJQUUzQyxTQUFTQztRQUNMLE9BQU9DO0lBQ1g7SUFFQSxTQUFTQyxhQUFhQyxDQUFDO1FBQ25CLE9BQU8sT0FBUUEsTUFBTSxZQUFZQSxNQUFNLFFBQVMsT0FBT0EsTUFBTTtJQUNqRTtJQUNBLE1BQU1DLGlDQUFpQ0o7SUFDdkMsU0FBU0ssZ0JBQWdCQyxFQUFFLEVBQUVDLElBQUk7UUFDN0IsSUFBSTtZQUNBQyxPQUFPQyxjQUFjLENBQUNILElBQUksUUFBUTtnQkFDOUJJLE9BQU9IO2dCQUNQSSxjQUFjO1lBQ2xCO1FBQ0osRUFDQSxPQUFPQyxJQUFJO1FBQ1AsaUZBQWlGO1FBQ2pGLHVIQUF1SDtRQUMzSDtJQUNKO0lBRUEsTUFBTUMsa0JBQWtCQztJQUN4QixNQUFNQyxzQkFBc0JELFFBQVFFLFNBQVMsQ0FBQ0MsSUFBSTtJQUNsRCxNQUFNQyx3QkFBd0JKLFFBQVFLLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDUDtJQUNsRCxnREFBZ0Q7SUFDaEQsU0FBU1EsV0FBV0MsUUFBUTtRQUN4QixPQUFPLElBQUlULGdCQUFnQlM7SUFDL0I7SUFDQSwwREFBMEQ7SUFDMUQsU0FBU0Msb0JBQW9CYixLQUFLO1FBQzlCLE9BQU9XLFdBQVdHLENBQUFBLFVBQVdBLFFBQVFkO0lBQ3pDO0lBQ0EsMERBQTBEO0lBQzFELFNBQVNlLG9CQUFvQkMsTUFBTTtRQUMvQixPQUFPUixzQkFBc0JRO0lBQ2pDO0lBQ0EsU0FBU0MsbUJBQW1CQyxPQUFPLEVBQUVDLFdBQVcsRUFBRUMsVUFBVTtRQUN4RCw0R0FBNEc7UUFDNUcsaUJBQWlCO1FBQ2pCLE9BQU9mLG9CQUFvQmdCLElBQUksQ0FBQ0gsU0FBU0MsYUFBYUM7SUFDMUQ7SUFDQSwwR0FBMEc7SUFDMUcscUZBQXFGO0lBQ3JGLCtIQUErSDtJQUMvSCxTQUFTRSxZQUFZSixPQUFPLEVBQUVDLFdBQVcsRUFBRUMsVUFBVTtRQUNqREgsbUJBQW1CQSxtQkFBbUJDLFNBQVNDLGFBQWFDLGFBQWE3QixXQUFXRztJQUN4RjtJQUNBLFNBQVM2QixnQkFBZ0JMLE9BQU8sRUFBRUMsV0FBVztRQUN6Q0csWUFBWUosU0FBU0M7SUFDekI7SUFDQSxTQUFTSyxjQUFjTixPQUFPLEVBQUVFLFVBQVU7UUFDdENFLFlBQVlKLFNBQVMzQixXQUFXNkI7SUFDcEM7SUFDQSxTQUFTSyxxQkFBcUJQLE9BQU8sRUFBRVEsa0JBQWtCLEVBQUVDLGdCQUFnQjtRQUN2RSxPQUFPVixtQkFBbUJDLFNBQVNRLG9CQUFvQkM7SUFDM0Q7SUFDQSxTQUFTQywwQkFBMEJWLE9BQU87UUFDdENELG1CQUFtQkMsU0FBUzNCLFdBQVdHO0lBQzNDO0lBQ0EsSUFBSW1DLGtCQUFrQkMsQ0FBQUE7UUFDbEIsSUFBSSxPQUFPQyxtQkFBbUIsWUFBWTtZQUN0Q0Ysa0JBQWtCRTtRQUN0QixPQUNLO1lBQ0QsTUFBTUMsa0JBQWtCbkIsb0JBQW9CdEI7WUFDNUNzQyxrQkFBa0JJLENBQUFBLEtBQU1oQixtQkFBbUJlLGlCQUFpQkM7UUFDaEU7UUFDQSxPQUFPSixnQkFBZ0JDO0lBQzNCO0lBQ0EsU0FBU0ksWUFBWUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLElBQUk7UUFDM0IsSUFBSSxPQUFPRixNQUFNLFlBQVk7WUFDekIsTUFBTSxJQUFJRyxVQUFVO1FBQ3hCO1FBQ0EsT0FBT0MsU0FBU2pDLFNBQVMsQ0FBQ2tDLEtBQUssQ0FBQ25CLElBQUksQ0FBQ2MsR0FBR0MsR0FBR0M7SUFDL0M7SUFDQSxTQUFTSSxZQUFZTixDQUFDLEVBQUVDLENBQUMsRUFBRUMsSUFBSTtRQUMzQixJQUFJO1lBQ0EsT0FBT3hCLG9CQUFvQnFCLFlBQVlDLEdBQUdDLEdBQUdDO1FBQ2pELEVBQ0EsT0FBT3JDLE9BQU87WUFDVixPQUFPZSxvQkFBb0JmO1FBQy9CO0lBQ0o7SUFFQSx5QkFBeUI7SUFDekIsbUpBQW1KO0lBQ25KLE1BQU0wQyx1QkFBdUI7SUFDN0I7Ozs7O0tBS0MsR0FDRCxNQUFNQztRQUNGQyxhQUFjO1lBQ1YsSUFBSSxDQUFDQyxPQUFPLEdBQUc7WUFDZixJQUFJLENBQUNDLEtBQUssR0FBRztZQUNiLHVDQUF1QztZQUN2QyxJQUFJLENBQUNDLE1BQU0sR0FBRztnQkFDVkMsV0FBVyxFQUFFO2dCQUNiQyxPQUFPMUQ7WUFDWDtZQUNBLElBQUksQ0FBQzJELEtBQUssR0FBRyxJQUFJLENBQUNILE1BQU07WUFDeEIscURBQXFEO1lBQ3JELHFFQUFxRTtZQUNyRSx3RUFBd0U7WUFDeEUsSUFBSSxDQUFDRixPQUFPLEdBQUc7WUFDZixrRUFBa0U7WUFDbEUsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDakI7UUFDQSxJQUFJSyxTQUFTO1lBQ1QsT0FBTyxJQUFJLENBQUNMLEtBQUs7UUFDckI7UUFDQSw0REFBNEQ7UUFDNUQsZ0JBQWdCO1FBQ2hCLHdDQUF3QztRQUN4Qyw2QkFBNkI7UUFDN0JNLEtBQUtDLE9BQU8sRUFBRTtZQUNWLE1BQU1DLFVBQVUsSUFBSSxDQUFDSixLQUFLO1lBQzFCLElBQUlLLFVBQVVEO1lBQ2QsSUFBSUEsUUFBUU4sU0FBUyxDQUFDRyxNQUFNLEtBQUtULHVCQUF1QixHQUFHO2dCQUN2RGEsVUFBVTtvQkFDTlAsV0FBVyxFQUFFO29CQUNiQyxPQUFPMUQ7Z0JBQ1g7WUFDSjtZQUNBLGtFQUFrRTtZQUNsRSxjQUFjO1lBQ2QrRCxRQUFRTixTQUFTLENBQUNJLElBQUksQ0FBQ0M7WUFDdkIsSUFBSUUsWUFBWUQsU0FBUztnQkFDckIsSUFBSSxDQUFDSixLQUFLLEdBQUdLO2dCQUNiRCxRQUFRTCxLQUFLLEdBQUdNO1lBQ3BCO1lBQ0EsRUFBRSxJQUFJLENBQUNULEtBQUs7UUFDaEI7UUFDQSwyRUFBMkU7UUFDM0Usb0JBQW9CO1FBQ3BCVSxRQUFRO1lBQ0osTUFBTUMsV0FBVyxJQUFJLENBQUNWLE1BQU07WUFDNUIsSUFBSVcsV0FBV0Q7WUFDZixNQUFNRSxZQUFZLElBQUksQ0FBQ2QsT0FBTztZQUM5QixJQUFJZSxZQUFZRCxZQUFZO1lBQzVCLE1BQU1FLFdBQVdKLFNBQVNULFNBQVM7WUFDbkMsTUFBTUssVUFBVVEsUUFBUSxDQUFDRixVQUFVO1lBQ25DLElBQUlDLGNBQWNsQixzQkFBc0I7Z0JBQ3BDZ0IsV0FBV0QsU0FBU1IsS0FBSztnQkFDekJXLFlBQVk7WUFDaEI7WUFDQSxrQ0FBa0M7WUFDbEMsRUFBRSxJQUFJLENBQUNkLEtBQUs7WUFDWixJQUFJLENBQUNELE9BQU8sR0FBR2U7WUFDZixJQUFJSCxhQUFhQyxVQUFVO2dCQUN2QixJQUFJLENBQUNYLE1BQU0sR0FBR1c7WUFDbEI7WUFDQSxrREFBa0Q7WUFDbERHLFFBQVEsQ0FBQ0YsVUFBVSxHQUFHcEU7WUFDdEIsT0FBTzhEO1FBQ1g7UUFDQSw0REFBNEQ7UUFDNUQsNEVBQTRFO1FBQzVFLDRFQUE0RTtRQUM1RSx1RUFBdUU7UUFDdkUsdUVBQXVFO1FBQ3ZFLDBFQUEwRTtRQUMxRSw0RUFBNEU7UUFDNUUsd0NBQXdDO1FBQ3hDUyxRQUFRaEMsUUFBUSxFQUFFO1lBQ2QsSUFBSWlDLElBQUksSUFBSSxDQUFDbEIsT0FBTztZQUNwQixJQUFJbUIsT0FBTyxJQUFJLENBQUNqQixNQUFNO1lBQ3RCLElBQUljLFdBQVdHLEtBQUtoQixTQUFTO1lBQzdCLE1BQU9lLE1BQU1GLFNBQVNWLE1BQU0sSUFBSWEsS0FBS2YsS0FBSyxLQUFLMUQsVUFBVztnQkFDdEQsSUFBSXdFLE1BQU1GLFNBQVNWLE1BQU0sRUFBRTtvQkFDdkJhLE9BQU9BLEtBQUtmLEtBQUs7b0JBQ2pCWSxXQUFXRyxLQUFLaEIsU0FBUztvQkFDekJlLElBQUk7b0JBQ0osSUFBSUYsU0FBU1YsTUFBTSxLQUFLLEdBQUc7d0JBQ3ZCO29CQUNKO2dCQUNKO2dCQUNBckIsU0FBUytCLFFBQVEsQ0FBQ0UsRUFBRTtnQkFDcEIsRUFBRUE7WUFDTjtRQUNKO1FBQ0EsdUVBQXVFO1FBQ3ZFLCtCQUErQjtRQUMvQkUsT0FBTztZQUNILE1BQU1DLFFBQVEsSUFBSSxDQUFDbkIsTUFBTTtZQUN6QixNQUFNb0IsU0FBUyxJQUFJLENBQUN0QixPQUFPO1lBQzNCLE9BQU9xQixNQUFNbEIsU0FBUyxDQUFDbUIsT0FBTztRQUNsQztJQUNKO0lBRUEsTUFBTUMsYUFBYWxGLGVBQWU7SUFDbEMsTUFBTW1GLGFBQWFuRixlQUFlO0lBQ2xDLE1BQU1vRixjQUFjcEYsZUFBZTtJQUNuQyxNQUFNcUYsWUFBWXJGLGVBQWU7SUFDakMsTUFBTXNGLGVBQWV0RixlQUFlO0lBRXBDLFNBQVN1RixzQ0FBc0NDLE1BQU0sRUFBRUMsTUFBTTtRQUN6REQsT0FBT0Usb0JBQW9CLEdBQUdEO1FBQzlCQSxPQUFPRSxPQUFPLEdBQUdIO1FBQ2pCLElBQUlDLE9BQU9HLE1BQU0sS0FBSyxZQUFZO1lBQzlCQyxxQ0FBcUNMO1FBQ3pDLE9BQ0ssSUFBSUMsT0FBT0csTUFBTSxLQUFLLFVBQVU7WUFDakNFLCtDQUErQ047UUFDbkQsT0FDSztZQUNETywrQ0FBK0NQLFFBQVFDLE9BQU9PLFlBQVk7UUFDOUU7SUFDSjtJQUNBLHdIQUF3SDtJQUN4SCxTQUFTO0lBQ1QsU0FBU0Msa0NBQWtDVCxNQUFNLEVBQUUxRCxNQUFNO1FBQ3JELE1BQU0yRCxTQUFTRCxPQUFPRSxvQkFBb0I7UUFDMUMsT0FBT1EscUJBQXFCVCxRQUFRM0Q7SUFDeEM7SUFDQSxTQUFTcUUsbUNBQW1DWCxNQUFNO1FBQzlDLE1BQU1DLFNBQVNELE9BQU9FLG9CQUFvQjtRQUMxQyxJQUFJRCxPQUFPRyxNQUFNLEtBQUssWUFBWTtZQUM5QlEsaUNBQWlDWixRQUFRLElBQUlwQyxVQUFVLENBQUMsZ0ZBQWdGLENBQUM7UUFDN0ksT0FDSztZQUNEaUQsMENBQTBDYixRQUFRLElBQUlwQyxVQUFVLENBQUMsZ0ZBQWdGLENBQUM7UUFDdEo7UUFDQXFDLE9BQU9hLHlCQUF5QixDQUFDaEIsYUFBYTtRQUM5Q0csT0FBT0UsT0FBTyxHQUFHdEY7UUFDakJtRixPQUFPRSxvQkFBb0IsR0FBR3JGO0lBQ2xDO0lBQ0Esb0NBQW9DO0lBQ3BDLFNBQVNrRyxvQkFBb0I1RixJQUFJO1FBQzdCLE9BQU8sSUFBSXlDLFVBQVUsWUFBWXpDLE9BQU87SUFDNUM7SUFDQSx3REFBd0Q7SUFDeEQsU0FBU2tGLHFDQUFxQ0wsTUFBTTtRQUNoREEsT0FBT2dCLGNBQWMsR0FBRy9FLFdBQVcsQ0FBQ0csU0FBU0w7WUFDekNpRSxPQUFPaUIsc0JBQXNCLEdBQUc3RTtZQUNoQzRELE9BQU9rQixxQkFBcUIsR0FBR25GO1FBQ25DO0lBQ0o7SUFDQSxTQUFTd0UsK0NBQStDUCxNQUFNLEVBQUUxRCxNQUFNO1FBQ2xFK0QscUNBQXFDTDtRQUNyQ1ksaUNBQWlDWixRQUFRMUQ7SUFDN0M7SUFDQSxTQUFTZ0UsK0NBQStDTixNQUFNO1FBQzFESyxxQ0FBcUNMO1FBQ3JDbUIsa0NBQWtDbkI7SUFDdEM7SUFDQSxTQUFTWSxpQ0FBaUNaLE1BQU0sRUFBRTFELE1BQU07UUFDcEQsSUFBSTBELE9BQU9rQixxQkFBcUIsS0FBS3JHLFdBQVc7WUFDNUM7UUFDSjtRQUNBcUMsMEJBQTBCOEMsT0FBT2dCLGNBQWM7UUFDL0NoQixPQUFPa0IscUJBQXFCLENBQUM1RTtRQUM3QjBELE9BQU9pQixzQkFBc0IsR0FBR3BHO1FBQ2hDbUYsT0FBT2tCLHFCQUFxQixHQUFHckc7SUFDbkM7SUFDQSxTQUFTZ0csMENBQTBDYixNQUFNLEVBQUUxRCxNQUFNO1FBQzdEaUUsK0NBQStDUCxRQUFRMUQ7SUFDM0Q7SUFDQSxTQUFTNkUsa0NBQWtDbkIsTUFBTTtRQUM3QyxJQUFJQSxPQUFPaUIsc0JBQXNCLEtBQUtwRyxXQUFXO1lBQzdDO1FBQ0o7UUFDQW1GLE9BQU9pQixzQkFBc0IsQ0FBQ3BHO1FBQzlCbUYsT0FBT2lCLHNCQUFzQixHQUFHcEc7UUFDaENtRixPQUFPa0IscUJBQXFCLEdBQUdyRztJQUNuQztJQUVBLG1DQUFtQztJQUNuQyw0R0FBNEc7SUFDNUcsTUFBTXVHLGlCQUFpQkMsT0FBT0MsUUFBUSxJQUFJLFNBQVV2RyxDQUFDO1FBQ2pELE9BQU8sT0FBT0EsTUFBTSxZQUFZdUcsU0FBU3ZHO0lBQzdDO0lBRUEsbUNBQW1DO0lBQ25DLHVHQUF1RztJQUN2RyxNQUFNd0csWUFBWUMsS0FBS0MsS0FBSyxJQUFJLFNBQVVDLENBQUM7UUFDdkMsT0FBT0EsSUFBSSxJQUFJRixLQUFLRyxJQUFJLENBQUNELEtBQUtGLEtBQUtJLEtBQUssQ0FBQ0Y7SUFDN0M7SUFFQSxvREFBb0Q7SUFDcEQsU0FBU0csYUFBYTlHLENBQUM7UUFDbkIsT0FBTyxPQUFPQSxNQUFNLFlBQVksT0FBT0EsTUFBTTtJQUNqRDtJQUNBLFNBQVMrRyxpQkFBaUJDLEdBQUcsRUFBRUMsT0FBTztRQUNsQyxJQUFJRCxRQUFRbEgsYUFBYSxDQUFDZ0gsYUFBYUUsTUFBTTtZQUN6QyxNQUFNLElBQUluRSxVQUFVLENBQUMsRUFBRW9FLFFBQVEsa0JBQWtCLENBQUM7UUFDdEQ7SUFDSjtJQUNBLDBEQUEwRDtJQUMxRCxTQUFTQyxlQUFlbEgsQ0FBQyxFQUFFaUgsT0FBTztRQUM5QixJQUFJLE9BQU9qSCxNQUFNLFlBQVk7WUFDekIsTUFBTSxJQUFJNkMsVUFBVSxDQUFDLEVBQUVvRSxRQUFRLG1CQUFtQixDQUFDO1FBQ3ZEO0lBQ0o7SUFDQSw4Q0FBOEM7SUFDOUMsU0FBU0UsU0FBU25ILENBQUM7UUFDZixPQUFPLE9BQVFBLE1BQU0sWUFBWUEsTUFBTSxRQUFTLE9BQU9BLE1BQU07SUFDakU7SUFDQSxTQUFTb0gsYUFBYXBILENBQUMsRUFBRWlILE9BQU87UUFDNUIsSUFBSSxDQUFDRSxTQUFTbkgsSUFBSTtZQUNkLE1BQU0sSUFBSTZDLFVBQVUsQ0FBQyxFQUFFb0UsUUFBUSxrQkFBa0IsQ0FBQztRQUN0RDtJQUNKO0lBQ0EsU0FBU0ksdUJBQXVCckgsQ0FBQyxFQUFFc0gsUUFBUSxFQUFFTCxPQUFPO1FBQ2hELElBQUlqSCxNQUFNRixXQUFXO1lBQ2pCLE1BQU0sSUFBSStDLFVBQVUsQ0FBQyxVQUFVLEVBQUV5RSxTQUFTLGlCQUFpQixFQUFFTCxRQUFRLEVBQUUsQ0FBQztRQUM1RTtJQUNKO0lBQ0EsU0FBU00sb0JBQW9CdkgsQ0FBQyxFQUFFd0gsS0FBSyxFQUFFUCxPQUFPO1FBQzFDLElBQUlqSCxNQUFNRixXQUFXO1lBQ2pCLE1BQU0sSUFBSStDLFVBQVUsQ0FBQyxFQUFFMkUsTUFBTSxpQkFBaUIsRUFBRVAsUUFBUSxFQUFFLENBQUM7UUFDL0Q7SUFDSjtJQUNBLDJEQUEyRDtJQUMzRCxTQUFTUSwwQkFBMEJsSCxLQUFLO1FBQ3BDLE9BQU8rRixPQUFPL0Y7SUFDbEI7SUFDQSxTQUFTbUgsbUJBQW1CMUgsQ0FBQztRQUN6QixPQUFPQSxNQUFNLElBQUksSUFBSUE7SUFDekI7SUFDQSxTQUFTMkgsWUFBWTNILENBQUM7UUFDbEIsT0FBTzBILG1CQUFtQmxCLFVBQVV4RztJQUN4QztJQUNBLDBEQUEwRDtJQUMxRCxTQUFTNEgsd0NBQXdDckgsS0FBSyxFQUFFMEcsT0FBTztRQUMzRCxNQUFNWSxhQUFhO1FBQ25CLE1BQU1DLGFBQWF4QixPQUFPeUIsZ0JBQWdCO1FBQzFDLElBQUkvSCxJQUFJc0csT0FBTy9GO1FBQ2ZQLElBQUkwSCxtQkFBbUIxSDtRQUN2QixJQUFJLENBQUNxRyxlQUFlckcsSUFBSTtZQUNwQixNQUFNLElBQUk2QyxVQUFVLENBQUMsRUFBRW9FLFFBQVEsdUJBQXVCLENBQUM7UUFDM0Q7UUFDQWpILElBQUkySCxZQUFZM0g7UUFDaEIsSUFBSUEsSUFBSTZILGNBQWM3SCxJQUFJOEgsWUFBWTtZQUNsQyxNQUFNLElBQUlqRixVQUFVLENBQUMsRUFBRW9FLFFBQVEsa0NBQWtDLEVBQUVZLFdBQVcsSUFBSSxFQUFFQyxXQUFXLFdBQVcsQ0FBQztRQUMvRztRQUNBLElBQUksQ0FBQ3pCLGVBQWVyRyxNQUFNQSxNQUFNLEdBQUc7WUFDL0IsT0FBTztRQUNYO1FBQ0EsZ0NBQWdDO1FBQ2hDLHdDQUF3QztRQUN4Qyx5Q0FBeUM7UUFDekMsMEJBQTBCO1FBQzFCLE9BQU9BO0lBQ1g7SUFFQSxTQUFTZ0kscUJBQXFCaEksQ0FBQyxFQUFFaUgsT0FBTztRQUNwQyxJQUFJLENBQUNnQixpQkFBaUJqSSxJQUFJO1lBQ3RCLE1BQU0sSUFBSTZDLFVBQVUsQ0FBQyxFQUFFb0UsUUFBUSx5QkFBeUIsQ0FBQztRQUM3RDtJQUNKO0lBRUEsOENBQThDO0lBQzlDLFNBQVNpQixtQ0FBbUNoRCxNQUFNO1FBQzlDLE9BQU8sSUFBSWlELDRCQUE0QmpEO0lBQzNDO0lBQ0EsOENBQThDO0lBQzlDLFNBQVNrRCw2QkFBNkJsRCxNQUFNLEVBQUVtRCxXQUFXO1FBQ3JEbkQsT0FBT0UsT0FBTyxDQUFDa0QsYUFBYSxDQUFDM0UsSUFBSSxDQUFDMEU7SUFDdEM7SUFDQSxTQUFTRSxpQ0FBaUNyRCxNQUFNLEVBQUVzRCxLQUFLLEVBQUVDLElBQUk7UUFDekQsTUFBTXhELFNBQVNDLE9BQU9FLE9BQU87UUFDN0IsTUFBTWlELGNBQWNwRCxPQUFPcUQsYUFBYSxDQUFDdkUsS0FBSztRQUM5QyxJQUFJMEUsTUFBTTtZQUNOSixZQUFZSyxXQUFXO1FBQzNCLE9BQ0s7WUFDREwsWUFBWU0sV0FBVyxDQUFDSDtRQUM1QjtJQUNKO0lBQ0EsU0FBU0ksaUNBQWlDMUQsTUFBTTtRQUM1QyxPQUFPQSxPQUFPRSxPQUFPLENBQUNrRCxhQUFhLENBQUM1RSxNQUFNO0lBQzlDO0lBQ0EsU0FBU21GLCtCQUErQjNELE1BQU07UUFDMUMsTUFBTUQsU0FBU0MsT0FBT0UsT0FBTztRQUM3QixJQUFJSCxXQUFXbkYsV0FBVztZQUN0QixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUNnSiw4QkFBOEI3RCxTQUFTO1lBQ3hDLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBOzs7O0tBSUMsR0FDRCxNQUFNa0Q7UUFDRmhGLFlBQVkrQixNQUFNLENBQUU7WUFDaEJtQyx1QkFBdUJuQyxRQUFRLEdBQUc7WUFDbEM4QyxxQkFBcUI5QyxRQUFRO1lBQzdCLElBQUk2RCx1QkFBdUI3RCxTQUFTO2dCQUNoQyxNQUFNLElBQUlyQyxVQUFVO1lBQ3hCO1lBQ0FtQyxzQ0FBc0MsSUFBSSxFQUFFRTtZQUM1QyxJQUFJLENBQUNvRCxhQUFhLEdBQUcsSUFBSXBGO1FBQzdCO1FBQ0E7OztTQUdDLEdBQ0QsSUFBSThGLFNBQVM7WUFDVCxJQUFJLENBQUNGLDhCQUE4QixJQUFJLEdBQUc7Z0JBQ3RDLE9BQU94SCxvQkFBb0IySCxpQ0FBaUM7WUFDaEU7WUFDQSxPQUFPLElBQUksQ0FBQ2hELGNBQWM7UUFDOUI7UUFDQTs7U0FFQyxHQUNEaUQsT0FBTzNILFNBQVN6QixTQUFTLEVBQUU7WUFDdkIsSUFBSSxDQUFDZ0osOEJBQThCLElBQUksR0FBRztnQkFDdEMsT0FBT3hILG9CQUFvQjJILGlDQUFpQztZQUNoRTtZQUNBLElBQUksSUFBSSxDQUFDOUQsb0JBQW9CLEtBQUtyRixXQUFXO2dCQUN6QyxPQUFPd0Isb0JBQW9CMEUsb0JBQW9CO1lBQ25EO1lBQ0EsT0FBT04sa0NBQWtDLElBQUksRUFBRW5FO1FBQ25EO1FBQ0E7Ozs7U0FJQyxHQUNENEgsT0FBTztZQUNILElBQUksQ0FBQ0wsOEJBQThCLElBQUksR0FBRztnQkFDdEMsT0FBT3hILG9CQUFvQjJILGlDQUFpQztZQUNoRTtZQUNBLElBQUksSUFBSSxDQUFDOUQsb0JBQW9CLEtBQUtyRixXQUFXO2dCQUN6QyxPQUFPd0Isb0JBQW9CMEUsb0JBQW9CO1lBQ25EO1lBQ0EsSUFBSW9EO1lBQ0osSUFBSUM7WUFDSixNQUFNNUgsVUFBVVAsV0FBVyxDQUFDRyxTQUFTTDtnQkFDakNvSSxpQkFBaUIvSDtnQkFDakJnSSxnQkFBZ0JySTtZQUNwQjtZQUNBLE1BQU1xSCxjQUFjO2dCQUNoQk0sYUFBYUgsQ0FBQUEsUUFBU1ksZUFBZTt3QkFBRTdJLE9BQU9pSTt3QkFBT0MsTUFBTTtvQkFBTTtnQkFDakVDLGFBQWEsSUFBTVUsZUFBZTt3QkFBRTdJLE9BQU9UO3dCQUFXMkksTUFBTTtvQkFBSztnQkFDakVhLGFBQWFDLENBQUFBLElBQUtGLGNBQWNFO1lBQ3BDO1lBQ0FDLGdDQUFnQyxJQUFJLEVBQUVuQjtZQUN0QyxPQUFPNUc7UUFDWDtRQUNBOzs7Ozs7OztTQVFDLEdBQ0RnSSxjQUFjO1lBQ1YsSUFBSSxDQUFDWCw4QkFBOEIsSUFBSSxHQUFHO2dCQUN0QyxNQUFNRyxpQ0FBaUM7WUFDM0M7WUFDQSxJQUFJLElBQUksQ0FBQzlELG9CQUFvQixLQUFLckYsV0FBVztnQkFDekM7WUFDSjtZQUNBNEosbUNBQW1DLElBQUk7UUFDM0M7SUFDSjtJQUNBckosT0FBT3NKLGdCQUFnQixDQUFDeEIsNEJBQTRCdEgsU0FBUyxFQUFFO1FBQzNEcUksUUFBUTtZQUFFVSxZQUFZO1FBQUs7UUFDM0JULE1BQU07WUFBRVMsWUFBWTtRQUFLO1FBQ3pCSCxhQUFhO1lBQUVHLFlBQVk7UUFBSztRQUNoQ1osUUFBUTtZQUFFWSxZQUFZO1FBQUs7SUFDL0I7SUFDQTFKLGdCQUFnQmlJLDRCQUE0QnRILFNBQVMsQ0FBQ3FJLE1BQU0sRUFBRTtJQUM5RGhKLGdCQUFnQmlJLDRCQUE0QnRILFNBQVMsQ0FBQ3NJLElBQUksRUFBRTtJQUM1RGpKLGdCQUFnQmlJLDRCQUE0QnRILFNBQVMsQ0FBQzRJLFdBQVcsRUFBRTtJQUNuRSxJQUFJLE9BQU9oSyxlQUFlb0ssV0FBVyxLQUFLLFVBQVU7UUFDaER4SixPQUFPQyxjQUFjLENBQUM2SCw0QkFBNEJ0SCxTQUFTLEVBQUVwQixlQUFlb0ssV0FBVyxFQUFFO1lBQ3JGdEosT0FBTztZQUNQQyxjQUFjO1FBQ2xCO0lBQ0o7SUFDQSx1Q0FBdUM7SUFDdkMsU0FBU3NJLDhCQUE4QjlJLENBQUM7UUFDcEMsSUFBSSxDQUFDRCxhQUFhQyxJQUFJO1lBQ2xCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0ssT0FBT1EsU0FBUyxDQUFDaUosY0FBYyxDQUFDbEksSUFBSSxDQUFDNUIsR0FBRyxrQkFBa0I7WUFDM0QsT0FBTztRQUNYO1FBQ0EsT0FBT0EsYUFBYW1JO0lBQ3hCO0lBQ0EsU0FBU3FCLGdDQUFnQ3ZFLE1BQU0sRUFBRW9ELFdBQVc7UUFDeEQsTUFBTW5ELFNBQVNELE9BQU9FLG9CQUFvQjtRQUMxQ0QsT0FBTzZFLFVBQVUsR0FBRztRQUNwQixJQUFJN0UsT0FBT0csTUFBTSxLQUFLLFVBQVU7WUFDNUJnRCxZQUFZSyxXQUFXO1FBQzNCLE9BQ0ssSUFBSXhELE9BQU9HLE1BQU0sS0FBSyxXQUFXO1lBQ2xDZ0QsWUFBWWlCLFdBQVcsQ0FBQ3BFLE9BQU9PLFlBQVk7UUFDL0MsT0FDSztZQUNEUCxPQUFPYSx5QkFBeUIsQ0FBQ2pCLFVBQVUsQ0FBQ3VEO1FBQ2hEO0lBQ0o7SUFDQSxTQUFTcUIsbUNBQW1DekUsTUFBTTtRQUM5Q1csbUNBQW1DWDtRQUNuQyxNQUFNc0UsSUFBSSxJQUFJMUcsVUFBVTtRQUN4Qm1ILDZDQUE2Qy9FLFFBQVFzRTtJQUN6RDtJQUNBLFNBQVNTLDZDQUE2Qy9FLE1BQU0sRUFBRXNFLENBQUM7UUFDM0QsTUFBTVUsZUFBZWhGLE9BQU9xRCxhQUFhO1FBQ3pDckQsT0FBT3FELGFBQWEsR0FBRyxJQUFJcEY7UUFDM0IrRyxhQUFhNUYsT0FBTyxDQUFDZ0UsQ0FBQUE7WUFDakJBLFlBQVlpQixXQUFXLENBQUNDO1FBQzVCO0lBQ0o7SUFDQSx3REFBd0Q7SUFDeEQsU0FBU04saUNBQWlDN0ksSUFBSTtRQUMxQyxPQUFPLElBQUl5QyxVQUFVLENBQUMsc0NBQXNDLEVBQUV6QyxLQUFLLGtEQUFrRCxDQUFDO0lBQzFIO0lBRUEsNENBQTRDO0lBQzVDLHVEQUF1RCxHQUN2RCxNQUFNOEoseUJBQXlCN0osT0FBTzhKLGNBQWMsQ0FBQzlKLE9BQU84SixjQUFjLENBQUMsbUJBQXFCLEdBQUd0SixTQUFTO0lBRTVHLDRDQUE0QztJQUM1QyxNQUFNdUo7UUFDRmpILFlBQVk4QixNQUFNLEVBQUVvRixhQUFhLENBQUU7WUFDL0IsSUFBSSxDQUFDQyxlQUFlLEdBQUd4SztZQUN2QixJQUFJLENBQUN5SyxXQUFXLEdBQUc7WUFDbkIsSUFBSSxDQUFDbkYsT0FBTyxHQUFHSDtZQUNmLElBQUksQ0FBQ3VGLGNBQWMsR0FBR0g7UUFDMUI7UUFDQUksT0FBTztZQUNILE1BQU1DLFlBQVksSUFBTSxJQUFJLENBQUNDLFVBQVU7WUFDdkMsSUFBSSxDQUFDTCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlLEdBQ3ZDdEkscUJBQXFCLElBQUksQ0FBQ3NJLGVBQWUsRUFBRUksV0FBV0EsYUFDdERBO1lBQ0osT0FBTyxJQUFJLENBQUNKLGVBQWU7UUFDL0I7UUFDQU0sT0FBT3JLLEtBQUssRUFBRTtZQUNWLE1BQU1zSyxjQUFjLElBQU0sSUFBSSxDQUFDQyxZQUFZLENBQUN2SztZQUM1QyxPQUFPLElBQUksQ0FBQytKLGVBQWUsR0FDdkJ0SSxxQkFBcUIsSUFBSSxDQUFDc0ksZUFBZSxFQUFFTyxhQUFhQSxlQUN4REE7UUFDUjtRQUNBRixhQUFhO1lBQ1QsSUFBSSxJQUFJLENBQUNKLFdBQVcsRUFBRTtnQkFDbEIsT0FBTzVKLFFBQVFVLE9BQU8sQ0FBQztvQkFBRWQsT0FBT1Q7b0JBQVcySSxNQUFNO2dCQUFLO1lBQzFEO1lBQ0EsTUFBTXhELFNBQVMsSUFBSSxDQUFDRyxPQUFPO1lBQzNCLElBQUlnRTtZQUNKLElBQUlDO1lBQ0osTUFBTTVILFVBQVVQLFdBQVcsQ0FBQ0csU0FBU0w7Z0JBQ2pDb0ksaUJBQWlCL0g7Z0JBQ2pCZ0ksZ0JBQWdCckk7WUFDcEI7WUFDQSxNQUFNcUgsY0FBYztnQkFDaEJNLGFBQWFILENBQUFBO29CQUNULElBQUksQ0FBQzhCLGVBQWUsR0FBR3hLO29CQUN2QixzR0FBc0c7b0JBQ3RHLDREQUE0RDtvQkFDNURzQyxnQkFBZ0IsSUFBTWdILGVBQWU7NEJBQUU3SSxPQUFPaUk7NEJBQU9DLE1BQU07d0JBQU07Z0JBQ3JFO2dCQUNBQyxhQUFhO29CQUNULElBQUksQ0FBQzRCLGVBQWUsR0FBR3hLO29CQUN2QixJQUFJLENBQUN5SyxXQUFXLEdBQUc7b0JBQ25CM0UsbUNBQW1DWDtvQkFDbkNtRSxlQUFlO3dCQUFFN0ksT0FBT1Q7d0JBQVcySSxNQUFNO29CQUFLO2dCQUNsRDtnQkFDQWEsYUFBYS9ILENBQUFBO29CQUNULElBQUksQ0FBQytJLGVBQWUsR0FBR3hLO29CQUN2QixJQUFJLENBQUN5SyxXQUFXLEdBQUc7b0JBQ25CM0UsbUNBQW1DWDtvQkFDbkNvRSxjQUFjOUg7Z0JBQ2xCO1lBQ0o7WUFDQWlJLGdDQUFnQ3ZFLFFBQVFvRDtZQUN4QyxPQUFPNUc7UUFDWDtRQUNBcUosYUFBYXZLLEtBQUssRUFBRTtZQUNoQixJQUFJLElBQUksQ0FBQ2dLLFdBQVcsRUFBRTtnQkFDbEIsT0FBTzVKLFFBQVFVLE9BQU8sQ0FBQztvQkFBRWQ7b0JBQU9rSSxNQUFNO2dCQUFLO1lBQy9DO1lBQ0EsSUFBSSxDQUFDOEIsV0FBVyxHQUFHO1lBQ25CLE1BQU10RixTQUFTLElBQUksQ0FBQ0csT0FBTztZQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDb0YsY0FBYyxFQUFFO2dCQUN0QixNQUFNTyxTQUFTckYsa0NBQWtDVCxRQUFRMUU7Z0JBQ3pEcUYsbUNBQW1DWDtnQkFDbkMsT0FBT2pELHFCQUFxQitJLFFBQVEsSUFBTzt3QkFBRXhLO3dCQUFPa0ksTUFBTTtvQkFBSztZQUNuRTtZQUNBN0MsbUNBQW1DWDtZQUNuQyxPQUFPN0Qsb0JBQW9CO2dCQUFFYjtnQkFBT2tJLE1BQU07WUFBSztRQUNuRDtJQUNKO0lBQ0EsTUFBTXVDLHVDQUF1QztRQUN6Q1A7WUFDSSxJQUFJLENBQUNRLDhCQUE4QixJQUFJLEdBQUc7Z0JBQ3RDLE9BQU8zSixvQkFBb0I0Six1Q0FBdUM7WUFDdEU7WUFDQSxPQUFPLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNWLElBQUk7UUFDdkM7UUFDQUcsUUFBT3JLLEtBQUs7WUFDUixJQUFJLENBQUMwSyw4QkFBOEIsSUFBSSxHQUFHO2dCQUN0QyxPQUFPM0osb0JBQW9CNEosdUNBQXVDO1lBQ3RFO1lBQ0EsT0FBTyxJQUFJLENBQUNDLGtCQUFrQixDQUFDUCxNQUFNLENBQUNySztRQUMxQztJQUNKO0lBQ0EsSUFBSTJKLDJCQUEyQnBLLFdBQVc7UUFDdENPLE9BQU8rSyxjQUFjLENBQUNKLHNDQUFzQ2Q7SUFDaEU7SUFDQSw4Q0FBOEM7SUFDOUMsU0FBU21CLG1DQUFtQ25HLE1BQU0sRUFBRW1GLGFBQWE7UUFDN0QsTUFBTXBGLFNBQVNpRCxtQ0FBbUNoRDtRQUNsRCxNQUFNb0csT0FBTyxJQUFJbEIsZ0NBQWdDbkYsUUFBUW9GO1FBQ3pELE1BQU0xSyxXQUFXVSxPQUFPa0wsTUFBTSxDQUFDUDtRQUMvQnJMLFNBQVN3TCxrQkFBa0IsR0FBR0c7UUFDOUIsT0FBTzNMO0lBQ1g7SUFDQSxTQUFTc0wsOEJBQThCakwsQ0FBQztRQUNwQyxJQUFJLENBQUNELGFBQWFDLElBQUk7WUFDbEIsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDSyxPQUFPUSxTQUFTLENBQUNpSixjQUFjLENBQUNsSSxJQUFJLENBQUM1QixHQUFHLHVCQUF1QjtZQUNoRSxPQUFPO1FBQ1g7UUFDQSxJQUFJO1lBQ0EscUNBQXFDO1lBQ3JDLE9BQU9BLEVBQUVtTCxrQkFBa0IsWUFDdkJmO1FBQ1IsRUFDQSxPQUFPM0osSUFBSTtZQUNQLE9BQU87UUFDWDtJQUNKO0lBQ0EsMkNBQTJDO0lBQzNDLFNBQVN5Syx1Q0FBdUM5SyxJQUFJO1FBQ2hELE9BQU8sSUFBSXlDLFVBQVUsQ0FBQyw0QkFBNEIsRUFBRXpDLEtBQUssaURBQWlELENBQUM7SUFDL0c7SUFFQSxtQ0FBbUM7SUFDbkMseUdBQXlHO0lBQ3pHLE1BQU1vTCxjQUFjbEYsT0FBT21GLEtBQUssSUFBSSxTQUFVekwsQ0FBQztRQUMzQywyQ0FBMkM7UUFDM0MsT0FBT0EsTUFBTUE7SUFDakI7SUFFQSxTQUFTMEwsb0JBQW9CdEgsUUFBUTtRQUNqQyxrRUFBa0U7UUFDbEUseUVBQXlFO1FBQ3pFLE9BQU9BLFNBQVN1SCxLQUFLO0lBQ3pCO0lBQ0EsU0FBU0MsbUJBQW1CQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsR0FBRyxFQUFFQyxTQUFTLEVBQUVDLENBQUM7UUFDM0QsSUFBSUMsV0FBV0wsTUFBTU0sR0FBRyxDQUFDLElBQUlELFdBQVdILEtBQUtDLFdBQVdDLElBQUlIO0lBQ2hFO0lBQ0EsSUFBSU0sc0JBQXNCLENBQUNDO1FBQ3ZCLElBQUksT0FBT0EsRUFBRUMsUUFBUSxLQUFLLFlBQVk7WUFDbENGLHNCQUFzQkcsQ0FBQUEsU0FBVUEsT0FBT0QsUUFBUTtRQUNuRCxPQUNLLElBQUksT0FBT0Usb0JBQW9CLFlBQVk7WUFDNUNKLHNCQUFzQkcsQ0FBQUEsU0FBVUMsZ0JBQWdCRCxRQUFRO29CQUFFRCxVQUFVO3dCQUFDQztxQkFBTztnQkFBQztRQUNqRixPQUNLO1lBQ0QsNEJBQTRCO1lBQzVCSCxzQkFBc0JHLENBQUFBLFNBQVVBO1FBQ3BDO1FBQ0EsT0FBT0gsb0JBQW9CQztJQUMvQjtJQUNBLElBQUlJLG1CQUFtQixDQUFDSjtRQUNwQixJQUFJLE9BQU9BLEVBQUVLLFFBQVEsS0FBSyxXQUFXO1lBQ2pDRCxtQkFBbUJGLENBQUFBLFNBQVVBLE9BQU9HLFFBQVE7UUFDaEQsT0FDSztZQUNELDRCQUE0QjtZQUM1QkQsbUJBQW1CRixDQUFBQSxTQUFVQSxPQUFPSSxVQUFVLEtBQUs7UUFDdkQ7UUFDQSxPQUFPRixpQkFBaUJKO0lBQzVCO0lBQ0EsU0FBU08saUJBQWlCTCxNQUFNLEVBQUVNLEtBQUssRUFBRUMsR0FBRztRQUN4Qyx1REFBdUQ7UUFDdkQsb0VBQW9FO1FBQ3BFLElBQUlQLE9BQU9aLEtBQUssRUFBRTtZQUNkLE9BQU9ZLE9BQU9aLEtBQUssQ0FBQ2tCLE9BQU9DO1FBQy9CO1FBQ0EsTUFBTXBKLFNBQVNvSixNQUFNRDtRQUNyQixNQUFNbEIsUUFBUSxJQUFJb0IsWUFBWXJKO1FBQzlCa0ksbUJBQW1CRCxPQUFPLEdBQUdZLFFBQVFNLE9BQU9uSjtRQUM1QyxPQUFPaUk7SUFDWDtJQUNBLFNBQVNxQixVQUFVQyxRQUFRLEVBQUVDLElBQUk7UUFDN0IsTUFBTUMsT0FBT0YsUUFBUSxDQUFDQyxLQUFLO1FBQzNCLElBQUlDLFNBQVNyTixhQUFhcU4sU0FBUyxNQUFNO1lBQ3JDLE9BQU9yTjtRQUNYO1FBQ0EsSUFBSSxPQUFPcU4sU0FBUyxZQUFZO1lBQzVCLE1BQU0sSUFBSXRLLFVBQVUsQ0FBQyxFQUFFdUssT0FBT0YsTUFBTSxrQkFBa0IsQ0FBQztRQUMzRDtRQUNBLE9BQU9DO0lBQ1g7SUFDQSxTQUFTRSw0QkFBNEJDLGtCQUFrQjtRQUNuRCwrRkFBK0Y7UUFDL0YsK0VBQStFO1FBQy9FLCtFQUErRTtRQUMvRSxNQUFNQyxlQUFlO1lBQ2pCLENBQUM5TixlQUFlRSxRQUFRLENBQUMsRUFBRSxJQUFNMk4sbUJBQW1CM04sUUFBUTtRQUNoRTtRQUNBLGdFQUFnRTtRQUNoRSxNQUFNNk4sZ0JBQWlCO1lBQ25CLE9BQU8sT0FBT0Q7UUFDbEI7UUFDQSxzQ0FBc0M7UUFDdEMsTUFBTUUsYUFBYUQsY0FBYy9DLElBQUk7UUFDckMsT0FBTztZQUFFOUssVUFBVTZOO1lBQWVDO1lBQVloRixNQUFNO1FBQU07SUFDOUQ7SUFDQSxTQUFTaUYsWUFBWTFHLEdBQUcsRUFBRTJHLE9BQU8sTUFBTSxFQUFFQyxNQUFNO1FBQzNDLElBQUlBLFdBQVc5TixXQUFXO1lBQ3RCLElBQUk2TixTQUFTLFNBQVM7Z0JBQ2xCQyxTQUFTWixVQUFVaEcsS0FBS3ZILGVBQWUrTixhQUFhO2dCQUNwRCxJQUFJSSxXQUFXOU4sV0FBVztvQkFDdEIsTUFBTStOLGFBQWFiLFVBQVVoRyxLQUFLdkgsZUFBZUUsUUFBUTtvQkFDekQsTUFBTTJOLHFCQUFxQkksWUFBWTFHLEtBQUssUUFBUTZHO29CQUNwRCxPQUFPUiw0QkFBNEJDO2dCQUN2QztZQUNKLE9BQ0s7Z0JBQ0RNLFNBQVNaLFVBQVVoRyxLQUFLdkgsZUFBZUUsUUFBUTtZQUNuRDtRQUNKO1FBQ0EsSUFBSWlPLFdBQVc5TixXQUFXO1lBQ3RCLE1BQU0sSUFBSStDLFVBQVU7UUFDeEI7UUFDQSxNQUFNbEQsV0FBVzhDLFlBQVltTCxRQUFRNUcsS0FBSyxFQUFFO1FBQzVDLElBQUksQ0FBQ2pILGFBQWFKLFdBQVc7WUFDekIsTUFBTSxJQUFJa0QsVUFBVTtRQUN4QjtRQUNBLE1BQU00SyxhQUFhOU4sU0FBUzhLLElBQUk7UUFDaEMsT0FBTztZQUFFOUs7WUFBVThOO1lBQVloRixNQUFNO1FBQU07SUFDL0M7SUFDQSxTQUFTcUYsYUFBYUMsY0FBYztRQUNoQyxNQUFNaEQsU0FBU3RJLFlBQVlzTCxlQUFlTixVQUFVLEVBQUVNLGVBQWVwTyxRQUFRLEVBQUUsRUFBRTtRQUNqRixJQUFJLENBQUNJLGFBQWFnTCxTQUFTO1lBQ3ZCLE1BQU0sSUFBSWxJLFVBQVU7UUFDeEI7UUFDQSxPQUFPa0k7SUFDWDtJQUNBLFNBQVNpRCxpQkFBaUJDLFVBQVU7UUFDaEMsT0FBT0MsUUFBUUQsV0FBV3hGLElBQUk7SUFDbEM7SUFDQSxTQUFTMEYsY0FBY0YsVUFBVTtRQUM3QixPQUFPQSxXQUFXMU4sS0FBSztJQUMzQjtJQUVBLFNBQVM2TixvQkFBb0J6SCxDQUFDO1FBQzFCLElBQUksT0FBT0EsTUFBTSxVQUFVO1lBQ3ZCLE9BQU87UUFDWDtRQUNBLElBQUk2RSxZQUFZN0UsSUFBSTtZQUNoQixPQUFPO1FBQ1g7UUFDQSxJQUFJQSxJQUFJLEdBQUc7WUFDUCxPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQSxTQUFTMEgsa0JBQWtCaEMsQ0FBQztRQUN4QixNQUFNRSxTQUFTSyxpQkFBaUJQLEVBQUVFLE1BQU0sRUFBRUYsRUFBRWlDLFVBQVUsRUFBRWpDLEVBQUVpQyxVQUFVLEdBQUdqQyxFQUFFTSxVQUFVO1FBQ25GLE9BQU8sSUFBSVQsV0FBV0s7SUFDMUI7SUFFQSxTQUFTZ0MsYUFBYUMsU0FBUztRQUMzQixNQUFNQyxPQUFPRCxVQUFVRSxNQUFNLENBQUMzSyxLQUFLO1FBQ25DeUssVUFBVUcsZUFBZSxJQUFJRixLQUFLRyxJQUFJO1FBQ3RDLElBQUlKLFVBQVVHLGVBQWUsR0FBRyxHQUFHO1lBQy9CSCxVQUFVRyxlQUFlLEdBQUc7UUFDaEM7UUFDQSxPQUFPRixLQUFLbE8sS0FBSztJQUNyQjtJQUNBLFNBQVNzTyxxQkFBcUJMLFNBQVMsRUFBRWpPLEtBQUssRUFBRXFPLElBQUk7UUFDaEQsSUFBSSxDQUFDUixvQkFBb0JRLFNBQVNBLFNBQVNFLFVBQVU7WUFDakQsTUFBTSxJQUFJQyxXQUFXO1FBQ3pCO1FBQ0FQLFVBQVVFLE1BQU0sQ0FBQy9LLElBQUksQ0FBQztZQUFFcEQ7WUFBT3FPO1FBQUs7UUFDcENKLFVBQVVHLGVBQWUsSUFBSUM7SUFDakM7SUFDQSxTQUFTSSxlQUFlUixTQUFTO1FBQzdCLE1BQU1DLE9BQU9ELFVBQVVFLE1BQU0sQ0FBQ2xLLElBQUk7UUFDbEMsT0FBT2lLLEtBQUtsTyxLQUFLO0lBQ3JCO0lBQ0EsU0FBUzBPLFdBQVdULFNBQVM7UUFDekJBLFVBQVVFLE1BQU0sR0FBRyxJQUFJeEw7UUFDdkJzTCxVQUFVRyxlQUFlLEdBQUc7SUFDaEM7SUFFQSxTQUFTTyxzQkFBc0JDLElBQUk7UUFDL0IsT0FBT0EsU0FBU0M7SUFDcEI7SUFDQSxTQUFTQyxXQUFXQyxJQUFJO1FBQ3BCLE9BQU9KLHNCQUFzQkksS0FBS25NLFdBQVc7SUFDakQ7SUFDQSxTQUFTb00sMkJBQTJCSixJQUFJO1FBQ3BDLElBQUlELHNCQUFzQkMsT0FBTztZQUM3QixPQUFPO1FBQ1g7UUFDQSxPQUFPQSxLQUFLSyxpQkFBaUI7SUFDakM7SUFFQTs7OztLQUlDLEdBQ0QsTUFBTUM7UUFDRnRNLGFBQWM7WUFDVixNQUFNLElBQUlOLFVBQVU7UUFDeEI7UUFDQTs7U0FFQyxHQUNELElBQUl5TSxPQUFPO1lBQ1AsSUFBSSxDQUFDSSw0QkFBNEIsSUFBSSxHQUFHO2dCQUNwQyxNQUFNQywrQkFBK0I7WUFDekM7WUFDQSxPQUFPLElBQUksQ0FBQ0MsS0FBSztRQUNyQjtRQUNBQyxRQUFRQyxZQUFZLEVBQUU7WUFDbEIsSUFBSSxDQUFDSiw0QkFBNEIsSUFBSSxHQUFHO2dCQUNwQyxNQUFNQywrQkFBK0I7WUFDekM7WUFDQXRJLHVCQUF1QnlJLGNBQWMsR0FBRztZQUN4Q0EsZUFBZWxJLHdDQUF3Q2tJLGNBQWM7WUFDckUsSUFBSSxJQUFJLENBQUNDLHVDQUF1QyxLQUFLalEsV0FBVztnQkFDNUQsTUFBTSxJQUFJK0MsVUFBVTtZQUN4QjtZQUNBLElBQUk0SixpQkFBaUIsSUFBSSxDQUFDbUQsS0FBSyxDQUFDckQsTUFBTSxHQUFHO2dCQUNyQyxNQUFNLElBQUkxSixVQUFVLENBQUMsK0VBQStFLENBQUM7WUFDekc7WUFDQW1OLG9DQUFvQyxJQUFJLENBQUNELHVDQUF1QyxFQUFFRDtRQUN0RjtRQUNBRyxtQkFBbUJYLElBQUksRUFBRTtZQUNyQixJQUFJLENBQUNJLDRCQUE0QixJQUFJLEdBQUc7Z0JBQ3BDLE1BQU1DLCtCQUErQjtZQUN6QztZQUNBdEksdUJBQXVCaUksTUFBTSxHQUFHO1lBQ2hDLElBQUksQ0FBQ3ZDLFlBQVltRCxNQUFNLENBQUNaLE9BQU87Z0JBQzNCLE1BQU0sSUFBSXpNLFVBQVU7WUFDeEI7WUFDQSxJQUFJLElBQUksQ0FBQ2tOLHVDQUF1QyxLQUFLalEsV0FBVztnQkFDNUQsTUFBTSxJQUFJK0MsVUFBVTtZQUN4QjtZQUNBLElBQUk0SixpQkFBaUI2QyxLQUFLL0MsTUFBTSxHQUFHO2dCQUMvQixNQUFNLElBQUkxSixVQUFVO1lBQ3hCO1lBQ0FzTiwrQ0FBK0MsSUFBSSxDQUFDSix1Q0FBdUMsRUFBRVQ7UUFDakc7SUFDSjtJQUNBalAsT0FBT3NKLGdCQUFnQixDQUFDOEYsMEJBQTBCNU8sU0FBUyxFQUFFO1FBQ3pEZ1AsU0FBUztZQUFFakcsWUFBWTtRQUFLO1FBQzVCcUcsb0JBQW9CO1lBQUVyRyxZQUFZO1FBQUs7UUFDdkMwRixNQUFNO1lBQUUxRixZQUFZO1FBQUs7SUFDN0I7SUFDQTFKLGdCQUFnQnVQLDBCQUEwQjVPLFNBQVMsQ0FBQ2dQLE9BQU8sRUFBRTtJQUM3RDNQLGdCQUFnQnVQLDBCQUEwQjVPLFNBQVMsQ0FBQ29QLGtCQUFrQixFQUFFO0lBQ3hFLElBQUksT0FBT3hRLGVBQWVvSyxXQUFXLEtBQUssVUFBVTtRQUNoRHhKLE9BQU9DLGNBQWMsQ0FBQ21QLDBCQUEwQjVPLFNBQVMsRUFBRXBCLGVBQWVvSyxXQUFXLEVBQUU7WUFDbkZ0SixPQUFPO1lBQ1BDLGNBQWM7UUFDbEI7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRCxNQUFNNFA7UUFDRmpOLGFBQWM7WUFDVixNQUFNLElBQUlOLFVBQVU7UUFDeEI7UUFDQTs7U0FFQyxHQUNELElBQUl3TixjQUFjO1lBQ2QsSUFBSSxDQUFDQywrQkFBK0IsSUFBSSxHQUFHO2dCQUN2QyxNQUFNQyx3Q0FBd0M7WUFDbEQ7WUFDQSxPQUFPQywyQ0FBMkMsSUFBSTtRQUMxRDtRQUNBOzs7U0FHQyxHQUNELElBQUlDLGNBQWM7WUFDZCxJQUFJLENBQUNILCtCQUErQixJQUFJLEdBQUc7Z0JBQ3ZDLE1BQU1DLHdDQUF3QztZQUNsRDtZQUNBLE9BQU9HLDJDQUEyQyxJQUFJO1FBQzFEO1FBQ0E7OztTQUdDLEdBQ0RDLFFBQVE7WUFDSixJQUFJLENBQUNMLCtCQUErQixJQUFJLEdBQUc7Z0JBQ3ZDLE1BQU1DLHdDQUF3QztZQUNsRDtZQUNBLElBQUksSUFBSSxDQUFDSyxlQUFlLEVBQUU7Z0JBQ3RCLE1BQU0sSUFBSS9OLFVBQVU7WUFDeEI7WUFDQSxNQUFNZ08sUUFBUSxJQUFJLENBQUNDLDZCQUE2QixDQUFDekwsTUFBTTtZQUN2RCxJQUFJd0wsVUFBVSxZQUFZO2dCQUN0QixNQUFNLElBQUloTyxVQUFVLENBQUMsZUFBZSxFQUFFZ08sTUFBTSx5REFBeUQsQ0FBQztZQUMxRztZQUNBRSxrQ0FBa0MsSUFBSTtRQUMxQztRQUNBQyxRQUFReEksS0FBSyxFQUFFO1lBQ1gsSUFBSSxDQUFDOEgsK0JBQStCLElBQUksR0FBRztnQkFDdkMsTUFBTUMsd0NBQXdDO1lBQ2xEO1lBQ0FsSix1QkFBdUJtQixPQUFPLEdBQUc7WUFDakMsSUFBSSxDQUFDdUUsWUFBWW1ELE1BQU0sQ0FBQzFILFFBQVE7Z0JBQzVCLE1BQU0sSUFBSTNGLFVBQVU7WUFDeEI7WUFDQSxJQUFJMkYsTUFBTW1FLFVBQVUsS0FBSyxHQUFHO2dCQUN4QixNQUFNLElBQUk5SixVQUFVO1lBQ3hCO1lBQ0EsSUFBSTJGLE1BQU0rRCxNQUFNLENBQUNJLFVBQVUsS0FBSyxHQUFHO2dCQUMvQixNQUFNLElBQUk5SixVQUFVLENBQUMsNENBQTRDLENBQUM7WUFDdEU7WUFDQSxJQUFJLElBQUksQ0FBQytOLGVBQWUsRUFBRTtnQkFDdEIsTUFBTSxJQUFJL04sVUFBVTtZQUN4QjtZQUNBLE1BQU1nTyxRQUFRLElBQUksQ0FBQ0MsNkJBQTZCLENBQUN6TCxNQUFNO1lBQ3ZELElBQUl3TCxVQUFVLFlBQVk7Z0JBQ3RCLE1BQU0sSUFBSWhPLFVBQVUsQ0FBQyxlQUFlLEVBQUVnTyxNQUFNLDhEQUE4RCxDQUFDO1lBQy9HO1lBQ0FJLG9DQUFvQyxJQUFJLEVBQUV6STtRQUM5QztRQUNBOztTQUVDLEdBQ0QwSSxNQUFNM0gsSUFBSXpKLFNBQVMsRUFBRTtZQUNqQixJQUFJLENBQUN3USwrQkFBK0IsSUFBSSxHQUFHO2dCQUN2QyxNQUFNQyx3Q0FBd0M7WUFDbEQ7WUFDQVksa0NBQWtDLElBQUksRUFBRTVIO1FBQzVDO1FBQ0EsY0FBYyxHQUNkLENBQUMxRSxZQUFZLENBQUN0RCxNQUFNLEVBQUU7WUFDbEI2UCxrREFBa0QsSUFBSTtZQUN0RG5DLFdBQVcsSUFBSTtZQUNmLE1BQU1sRSxTQUFTLElBQUksQ0FBQ3NHLGdCQUFnQixDQUFDOVA7WUFDckMrUCw0Q0FBNEMsSUFBSTtZQUNoRCxPQUFPdkc7UUFDWDtRQUNBLGNBQWMsR0FDZCxDQUFDakcsVUFBVSxDQUFDdUQsV0FBVyxFQUFFO1lBQ3JCLE1BQU1uRCxTQUFTLElBQUksQ0FBQzRMLDZCQUE2QjtZQUNqRCxJQUFJLElBQUksQ0FBQ25DLGVBQWUsR0FBRyxHQUFHO2dCQUMxQjRDLHFEQUFxRCxJQUFJLEVBQUVsSjtnQkFDM0Q7WUFDSjtZQUNBLE1BQU1tSix3QkFBd0IsSUFBSSxDQUFDQyxzQkFBc0I7WUFDekQsSUFBSUQsMEJBQTBCMVIsV0FBVztnQkFDckMsSUFBSXlNO2dCQUNKLElBQUk7b0JBQ0FBLFNBQVMsSUFBSVEsWUFBWXlFO2dCQUM3QixFQUNBLE9BQU9FLFNBQVM7b0JBQ1pySixZQUFZaUIsV0FBVyxDQUFDb0k7b0JBQ3hCO2dCQUNKO2dCQUNBLE1BQU1DLHFCQUFxQjtvQkFDdkJwRjtvQkFDQXFGLGtCQUFrQko7b0JBQ2xCbEQsWUFBWTtvQkFDWjNCLFlBQVk2RTtvQkFDWkssYUFBYTtvQkFDYkMsYUFBYTtvQkFDYkMsYUFBYTtvQkFDYkMsaUJBQWlCOUY7b0JBQ2pCK0YsWUFBWTtnQkFDaEI7Z0JBQ0EsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ3ZPLElBQUksQ0FBQ2dPO1lBQ2hDO1lBQ0F2Siw2QkFBNkJsRCxRQUFRbUQ7WUFDckM4Siw2Q0FBNkMsSUFBSTtRQUNyRDtRQUNBLGNBQWMsR0FDZCxDQUFDcE4sYUFBYSxHQUFHO1lBQ2IsSUFBSSxJQUFJLENBQUNtTixpQkFBaUIsQ0FBQ3hPLE1BQU0sR0FBRyxHQUFHO2dCQUNuQyxNQUFNME8sZ0JBQWdCLElBQUksQ0FBQ0YsaUJBQWlCLENBQUMxTixJQUFJO2dCQUNqRDROLGNBQWNILFVBQVUsR0FBRztnQkFDM0IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxJQUFJaFA7Z0JBQzdCLElBQUksQ0FBQ2dQLGlCQUFpQixDQUFDdk8sSUFBSSxDQUFDeU87WUFDaEM7UUFDSjtJQUNKO0lBQ0EvUixPQUFPc0osZ0JBQWdCLENBQUN5Ryw2QkFBNkJ2UCxTQUFTLEVBQUU7UUFDNUQ4UCxPQUFPO1lBQUUvRyxZQUFZO1FBQUs7UUFDMUJvSCxTQUFTO1lBQUVwSCxZQUFZO1FBQUs7UUFDNUJzSCxPQUFPO1lBQUV0SCxZQUFZO1FBQUs7UUFDMUJ5RyxhQUFhO1lBQUV6RyxZQUFZO1FBQUs7UUFDaEM2RyxhQUFhO1lBQUU3RyxZQUFZO1FBQUs7SUFDcEM7SUFDQTFKLGdCQUFnQmtRLDZCQUE2QnZQLFNBQVMsQ0FBQzhQLEtBQUssRUFBRTtJQUM5RHpRLGdCQUFnQmtRLDZCQUE2QnZQLFNBQVMsQ0FBQ21RLE9BQU8sRUFBRTtJQUNoRTlRLGdCQUFnQmtRLDZCQUE2QnZQLFNBQVMsQ0FBQ3FRLEtBQUssRUFBRTtJQUM5RCxJQUFJLE9BQU96UixlQUFlb0ssV0FBVyxLQUFLLFVBQVU7UUFDaER4SixPQUFPQyxjQUFjLENBQUM4UCw2QkFBNkJ2UCxTQUFTLEVBQUVwQixlQUFlb0ssV0FBVyxFQUFFO1lBQ3RGdEosT0FBTztZQUNQQyxjQUFjO1FBQ2xCO0lBQ0o7SUFDQSw0REFBNEQ7SUFDNUQsU0FBUzhQLCtCQUErQnRRLENBQUM7UUFDckMsSUFBSSxDQUFDRCxhQUFhQyxJQUFJO1lBQ2xCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0ssT0FBT1EsU0FBUyxDQUFDaUosY0FBYyxDQUFDbEksSUFBSSxDQUFDNUIsR0FBRyxrQ0FBa0M7WUFDM0UsT0FBTztRQUNYO1FBQ0EsT0FBT0EsYUFBYW9RO0lBQ3hCO0lBQ0EsU0FBU1YsNEJBQTRCMVAsQ0FBQztRQUNsQyxJQUFJLENBQUNELGFBQWFDLElBQUk7WUFDbEIsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDSyxPQUFPUSxTQUFTLENBQUNpSixjQUFjLENBQUNsSSxJQUFJLENBQUM1QixHQUFHLDRDQUE0QztZQUNyRixPQUFPO1FBQ1g7UUFDQSxPQUFPQSxhQUFheVA7SUFDeEI7SUFDQSxTQUFTMEMsNkNBQTZDRSxVQUFVO1FBQzVELE1BQU1DLGFBQWFDLDJDQUEyQ0Y7UUFDOUQsSUFBSSxDQUFDQyxZQUFZO1lBQ2I7UUFDSjtRQUNBLElBQUlELFdBQVdHLFFBQVEsRUFBRTtZQUNyQkgsV0FBV0ksVUFBVSxHQUFHO1lBQ3hCO1FBQ0o7UUFDQUosV0FBV0csUUFBUSxHQUFHO1FBQ3RCLGlDQUFpQztRQUNqQyxNQUFNRSxjQUFjTCxXQUFXTSxjQUFjO1FBQzdDOVEsWUFBWTZRLGFBQWE7WUFDckJMLFdBQVdHLFFBQVEsR0FBRztZQUN0QixJQUFJSCxXQUFXSSxVQUFVLEVBQUU7Z0JBQ3ZCSixXQUFXSSxVQUFVLEdBQUc7Z0JBQ3hCTiw2Q0FBNkNFO1lBQ2pEO1lBQ0EsT0FBTztRQUNYLEdBQUc5SSxDQUFBQTtZQUNDNEgsa0NBQWtDa0IsWUFBWTlJO1lBQzlDLE9BQU87UUFDWDtJQUNKO0lBQ0EsU0FBUzZILGtEQUFrRGlCLFVBQVU7UUFDakVPLGtEQUFrRFA7UUFDbERBLFdBQVdILGlCQUFpQixHQUFHLElBQUloUDtJQUN2QztJQUNBLFNBQVMyUCxxREFBcUQzTixNQUFNLEVBQUV5TSxrQkFBa0I7UUFDcEYsSUFBSWxKLE9BQU87UUFDWCxJQUFJdkQsT0FBT0csTUFBTSxLQUFLLFVBQVU7WUFDNUJvRCxPQUFPO1FBQ1g7UUFDQSxNQUFNcUssYUFBYUMsc0RBQXNEcEI7UUFDekUsSUFBSUEsbUJBQW1CTSxVQUFVLEtBQUssV0FBVztZQUM3QzFKLGlDQUFpQ3JELFFBQVE0TixZQUFZcks7UUFDekQsT0FDSztZQUNEdUsscUNBQXFDOU4sUUFBUTROLFlBQVlySztRQUM3RDtJQUNKO0lBQ0EsU0FBU3NLLHNEQUFzRHBCLGtCQUFrQjtRQUM3RSxNQUFNRSxjQUFjRixtQkFBbUJFLFdBQVc7UUFDbEQsTUFBTUUsY0FBY0osbUJBQW1CSSxXQUFXO1FBQ2xELE9BQU8sSUFBSUosbUJBQW1CSyxlQUFlLENBQUNMLG1CQUFtQnBGLE1BQU0sRUFBRW9GLG1CQUFtQnJELFVBQVUsRUFBRXVELGNBQWNFO0lBQzFIO0lBQ0EsU0FBU2tCLGdEQUFnRFosVUFBVSxFQUFFOUYsTUFBTSxFQUFFK0IsVUFBVSxFQUFFM0IsVUFBVTtRQUMvRjBGLFdBQVczRCxNQUFNLENBQUMvSyxJQUFJLENBQUM7WUFBRTRJO1lBQVErQjtZQUFZM0I7UUFBVztRQUN4RDBGLFdBQVcxRCxlQUFlLElBQUloQztJQUNsQztJQUNBLFNBQVN1RyxzREFBc0RiLFVBQVUsRUFBRTlGLE1BQU0sRUFBRStCLFVBQVUsRUFBRTNCLFVBQVU7UUFDckcsSUFBSXdHO1FBQ0osSUFBSTtZQUNBQSxjQUFjdkcsaUJBQWlCTCxRQUFRK0IsWUFBWUEsYUFBYTNCO1FBQ3BFLEVBQ0EsT0FBT3lHLFFBQVE7WUFDWGpDLGtDQUFrQ2tCLFlBQVllO1lBQzlDLE1BQU1BO1FBQ1Y7UUFDQUgsZ0RBQWdEWixZQUFZYyxhQUFhLEdBQUd4RztJQUNoRjtJQUNBLFNBQVMwRywyREFBMkRoQixVQUFVLEVBQUVpQixlQUFlO1FBQzNGLElBQUlBLGdCQUFnQnpCLFdBQVcsR0FBRyxHQUFHO1lBQ2pDcUIsc0RBQXNEYixZQUFZaUIsZ0JBQWdCL0csTUFBTSxFQUFFK0csZ0JBQWdCaEYsVUFBVSxFQUFFZ0YsZ0JBQWdCekIsV0FBVztRQUNySjtRQUNBMEIsaURBQWlEbEI7SUFDckQ7SUFDQSxTQUFTbUIsNERBQTREbkIsVUFBVSxFQUFFVixrQkFBa0I7UUFDL0YsTUFBTThCLGlCQUFpQmhOLEtBQUtpTixHQUFHLENBQUNyQixXQUFXMUQsZUFBZSxFQUFFZ0QsbUJBQW1CaEYsVUFBVSxHQUFHZ0YsbUJBQW1CRSxXQUFXO1FBQzFILE1BQU04QixpQkFBaUJoQyxtQkFBbUJFLFdBQVcsR0FBRzRCO1FBQ3hELElBQUlHLDRCQUE0Qkg7UUFDaEMsSUFBSUksUUFBUTtRQUNaLE1BQU1DLGlCQUFpQkgsaUJBQWlCaEMsbUJBQW1CSSxXQUFXO1FBQ3RFLE1BQU1nQyxrQkFBa0JKLGlCQUFpQkc7UUFDekMsMEdBQTBHO1FBQzFHLDhEQUE4RDtRQUM5RCxJQUFJQyxtQkFBbUJwQyxtQkFBbUJHLFdBQVcsRUFBRTtZQUNuRDhCLDRCQUE0Qkcsa0JBQWtCcEMsbUJBQW1CRSxXQUFXO1lBQzVFZ0MsUUFBUTtRQUNaO1FBQ0EsTUFBTUcsUUFBUTNCLFdBQVczRCxNQUFNO1FBQy9CLE1BQU9rRiw0QkFBNEIsRUFBRztZQUNsQyxNQUFNSyxjQUFjRCxNQUFNeFAsSUFBSTtZQUM5QixNQUFNMFAsY0FBY3pOLEtBQUtpTixHQUFHLENBQUNFLDJCQUEyQkssWUFBWXRILFVBQVU7WUFDOUUsTUFBTXdILFlBQVl4QyxtQkFBbUJyRCxVQUFVLEdBQUdxRCxtQkFBbUJFLFdBQVc7WUFDaEZqRyxtQkFBbUIrRixtQkFBbUJwRixNQUFNLEVBQUU0SCxXQUFXRixZQUFZMUgsTUFBTSxFQUFFMEgsWUFBWTNGLFVBQVUsRUFBRTRGO1lBQ3JHLElBQUlELFlBQVl0SCxVQUFVLEtBQUt1SCxhQUFhO2dCQUN4Q0YsTUFBTWpRLEtBQUs7WUFDZixPQUNLO2dCQUNEa1EsWUFBWTNGLFVBQVUsSUFBSTRGO2dCQUMxQkQsWUFBWXRILFVBQVUsSUFBSXVIO1lBQzlCO1lBQ0E3QixXQUFXMUQsZUFBZSxJQUFJdUY7WUFDOUJFLHVEQUF1RC9CLFlBQVk2QixhQUFhdkM7WUFDaEZpQyw2QkFBNkJNO1FBQ2pDO1FBQ0EsT0FBT0w7SUFDWDtJQUNBLFNBQVNPLHVEQUF1RC9CLFVBQVUsRUFBRXpELElBQUksRUFBRStDLGtCQUFrQjtRQUNoR0EsbUJBQW1CRSxXQUFXLElBQUlqRDtJQUN0QztJQUNBLFNBQVN5Riw2Q0FBNkNoQyxVQUFVO1FBQzVELElBQUlBLFdBQVcxRCxlQUFlLEtBQUssS0FBSzBELFdBQVd6QixlQUFlLEVBQUU7WUFDaEVVLDRDQUE0Q2U7WUFDNUNpQyxvQkFBb0JqQyxXQUFXdkIsNkJBQTZCO1FBQ2hFLE9BQ0s7WUFDRHFCLDZDQUE2Q0U7UUFDakQ7SUFDSjtJQUNBLFNBQVNPLGtEQUFrRFAsVUFBVTtRQUNqRSxJQUFJQSxXQUFXa0MsWUFBWSxLQUFLLE1BQU07WUFDbEM7UUFDSjtRQUNBbEMsV0FBV2tDLFlBQVksQ0FBQ3hFLHVDQUF1QyxHQUFHalE7UUFDbEV1UyxXQUFXa0MsWUFBWSxDQUFDM0UsS0FBSyxHQUFHO1FBQ2hDeUMsV0FBV2tDLFlBQVksR0FBRztJQUM5QjtJQUNBLFNBQVNDLGlFQUFpRW5DLFVBQVU7UUFDaEYsTUFBT0EsV0FBV0gsaUJBQWlCLENBQUN4TyxNQUFNLEdBQUcsRUFBRztZQUM1QyxJQUFJMk8sV0FBVzFELGVBQWUsS0FBSyxHQUFHO2dCQUNsQztZQUNKO1lBQ0EsTUFBTWdELHFCQUFxQlUsV0FBV0gsaUJBQWlCLENBQUMxTixJQUFJO1lBQzVELElBQUlnUCw0REFBNERuQixZQUFZVixxQkFBcUI7Z0JBQzdGNEIsaURBQWlEbEI7Z0JBQ2pEUSxxREFBcURSLFdBQVd2Qiw2QkFBNkIsRUFBRWE7WUFDbkc7UUFDSjtJQUNKO0lBQ0EsU0FBUzhDLDBEQUEwRHBDLFVBQVU7UUFDekUsTUFBTXBOLFNBQVNvTixXQUFXdkIsNkJBQTZCLENBQUMxTCxPQUFPO1FBQy9ELE1BQU9ILE9BQU9xRCxhQUFhLENBQUM1RSxNQUFNLEdBQUcsRUFBRztZQUNwQyxJQUFJMk8sV0FBVzFELGVBQWUsS0FBSyxHQUFHO2dCQUNsQztZQUNKO1lBQ0EsTUFBTXRHLGNBQWNwRCxPQUFPcUQsYUFBYSxDQUFDdkUsS0FBSztZQUM5Q3dOLHFEQUFxRGMsWUFBWWhLO1FBQ3JFO0lBQ0o7SUFDQSxTQUFTcU0scUNBQXFDckMsVUFBVSxFQUFFL0MsSUFBSSxFQUFFb0UsR0FBRyxFQUFFaUIsZUFBZTtRQUNoRixNQUFNelAsU0FBU21OLFdBQVd2Qiw2QkFBNkI7UUFDdkQsTUFBTTNCLE9BQU9HLEtBQUtuTSxXQUFXO1FBQzdCLE1BQU00TyxjQUFjeEMsMkJBQTJCSjtRQUMvQyxNQUFNLEVBQUViLFVBQVUsRUFBRTNCLFVBQVUsRUFBRSxHQUFHMkM7UUFDbkMsTUFBTXdDLGNBQWM0QixNQUFNM0I7UUFDMUIsSUFBSXhGO1FBQ0osSUFBSTtZQUNBQSxTQUFTSCxvQkFBb0JrRCxLQUFLL0MsTUFBTTtRQUM1QyxFQUNBLE9BQU9oRCxHQUFHO1lBQ05vTCxnQkFBZ0JyTCxXQUFXLENBQUNDO1lBQzVCO1FBQ0o7UUFDQSxNQUFNb0kscUJBQXFCO1lBQ3ZCcEY7WUFDQXFGLGtCQUFrQnJGLE9BQU9JLFVBQVU7WUFDbkMyQjtZQUNBM0I7WUFDQWtGLGFBQWE7WUFDYkM7WUFDQUM7WUFDQUMsaUJBQWlCN0M7WUFDakI4QyxZQUFZO1FBQ2hCO1FBQ0EsSUFBSUksV0FBV0gsaUJBQWlCLENBQUN4TyxNQUFNLEdBQUcsR0FBRztZQUN6QzJPLFdBQVdILGlCQUFpQixDQUFDdk8sSUFBSSxDQUFDZ087WUFDbEMsZ0VBQWdFO1lBQ2hFLHFDQUFxQztZQUNyQyx1RkFBdUY7WUFDdkZpRCxpQ0FBaUMxUCxRQUFReVA7WUFDekM7UUFDSjtRQUNBLElBQUl6UCxPQUFPRyxNQUFNLEtBQUssVUFBVTtZQUM1QixNQUFNd1AsWUFBWSxJQUFJMUYsS0FBS3dDLG1CQUFtQnBGLE1BQU0sRUFBRW9GLG1CQUFtQnJELFVBQVUsRUFBRTtZQUNyRnFHLGdCQUFnQmpNLFdBQVcsQ0FBQ21NO1lBQzVCO1FBQ0o7UUFDQSxJQUFJeEMsV0FBVzFELGVBQWUsR0FBRyxHQUFHO1lBQ2hDLElBQUk2RSw0REFBNERuQixZQUFZVixxQkFBcUI7Z0JBQzdGLE1BQU1tQixhQUFhQyxzREFBc0RwQjtnQkFDekUwQyw2Q0FBNkNoQztnQkFDN0NzQyxnQkFBZ0JoTSxXQUFXLENBQUNtSztnQkFDNUI7WUFDSjtZQUNBLElBQUlULFdBQVd6QixlQUFlLEVBQUU7Z0JBQzVCLE1BQU1ySCxJQUFJLElBQUkxRyxVQUFVO2dCQUN4QnNPLGtDQUFrQ2tCLFlBQVk5STtnQkFDOUNvTCxnQkFBZ0JyTCxXQUFXLENBQUNDO2dCQUM1QjtZQUNKO1FBQ0o7UUFDQThJLFdBQVdILGlCQUFpQixDQUFDdk8sSUFBSSxDQUFDZ087UUFDbENpRCxpQ0FBaUMxUCxRQUFReVA7UUFDekN4Qyw2Q0FBNkNFO0lBQ2pEO0lBQ0EsU0FBU3lDLGlEQUFpRHpDLFVBQVUsRUFBRWlCLGVBQWU7UUFDakYsSUFBSUEsZ0JBQWdCckIsVUFBVSxLQUFLLFFBQVE7WUFDdkNzQixpREFBaURsQjtRQUNyRDtRQUNBLE1BQU1uTixTQUFTbU4sV0FBV3ZCLDZCQUE2QjtRQUN2RCxJQUFJaUUsNEJBQTRCN1AsU0FBUztZQUNyQyxNQUFPOFAscUNBQXFDOVAsVUFBVSxFQUFHO2dCQUNyRCxNQUFNeU0scUJBQXFCNEIsaURBQWlEbEI7Z0JBQzVFUSxxREFBcUQzTixRQUFReU07WUFDakU7UUFDSjtJQUNKO0lBQ0EsU0FBU3NELG1EQUFtRDVDLFVBQVUsRUFBRXZDLFlBQVksRUFBRTZCLGtCQUFrQjtRQUNwR3lDLHVEQUF1RC9CLFlBQVl2QyxjQUFjNkI7UUFDakYsSUFBSUEsbUJBQW1CTSxVQUFVLEtBQUssUUFBUTtZQUMxQ29CLDJEQUEyRGhCLFlBQVlWO1lBQ3ZFNkMsaUVBQWlFbkM7WUFDakU7UUFDSjtRQUNBLElBQUlWLG1CQUFtQkUsV0FBVyxHQUFHRixtQkFBbUJHLFdBQVcsRUFBRTtZQUNqRSwwR0FBMEc7WUFDMUcsOERBQThEO1lBQzlEO1FBQ0o7UUFDQXlCLGlEQUFpRGxCO1FBQ2pELE1BQU02QyxnQkFBZ0J2RCxtQkFBbUJFLFdBQVcsR0FBR0YsbUJBQW1CSSxXQUFXO1FBQ3JGLElBQUltRCxnQkFBZ0IsR0FBRztZQUNuQixNQUFNcEksTUFBTTZFLG1CQUFtQnJELFVBQVUsR0FBR3FELG1CQUFtQkUsV0FBVztZQUMxRXFCLHNEQUFzRGIsWUFBWVYsbUJBQW1CcEYsTUFBTSxFQUFFTyxNQUFNb0ksZUFBZUE7UUFDdEg7UUFDQXZELG1CQUFtQkUsV0FBVyxJQUFJcUQ7UUFDbENyQyxxREFBcURSLFdBQVd2Qiw2QkFBNkIsRUFBRWE7UUFDL0Y2QyxpRUFBaUVuQztJQUNyRTtJQUNBLFNBQVM4Qyw0Q0FBNEM5QyxVQUFVLEVBQUV2QyxZQUFZO1FBQ3pFLE1BQU13RCxrQkFBa0JqQixXQUFXSCxpQkFBaUIsQ0FBQzFOLElBQUk7UUFDekRvTyxrREFBa0RQO1FBQ2xELE1BQU14QixRQUFRd0IsV0FBV3ZCLDZCQUE2QixDQUFDekwsTUFBTTtRQUM3RCxJQUFJd0wsVUFBVSxVQUFVO1lBQ3BCaUUsaURBQWlEekMsWUFBWWlCO1FBQ2pFLE9BQ0s7WUFDRDJCLG1EQUFtRDVDLFlBQVl2QyxjQUFjd0Q7UUFDakY7UUFDQW5CLDZDQUE2Q0U7SUFDakQ7SUFDQSxTQUFTa0IsaURBQWlEbEIsVUFBVTtRQUNoRSxNQUFNK0MsYUFBYS9DLFdBQVdILGlCQUFpQixDQUFDbk8sS0FBSztRQUNyRCxPQUFPcVI7SUFDWDtJQUNBLFNBQVM3QywyQ0FBMkNGLFVBQVU7UUFDMUQsTUFBTW5OLFNBQVNtTixXQUFXdkIsNkJBQTZCO1FBQ3ZELElBQUk1TCxPQUFPRyxNQUFNLEtBQUssWUFBWTtZQUM5QixPQUFPO1FBQ1g7UUFDQSxJQUFJZ04sV0FBV3pCLGVBQWUsRUFBRTtZQUM1QixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUN5QixXQUFXZ0QsUUFBUSxFQUFFO1lBQ3RCLE9BQU87UUFDWDtRQUNBLElBQUl4TSwrQkFBK0IzRCxXQUFXMEQsaUNBQWlDMUQsVUFBVSxHQUFHO1lBQ3hGLE9BQU87UUFDWDtRQUNBLElBQUk2UCw0QkFBNEI3UCxXQUFXOFAscUNBQXFDOVAsVUFBVSxHQUFHO1lBQ3pGLE9BQU87UUFDWDtRQUNBLE1BQU11TCxjQUFjQywyQ0FBMkMyQjtRQUMvRCxJQUFJNUIsY0FBYyxHQUFHO1lBQ2pCLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBLFNBQVNhLDRDQUE0Q2UsVUFBVTtRQUMzREEsV0FBV00sY0FBYyxHQUFHN1M7UUFDNUJ1UyxXQUFXaEIsZ0JBQWdCLEdBQUd2UjtJQUNsQztJQUNBLG1HQUFtRztJQUNuRyxTQUFTaVIsa0NBQWtDc0IsVUFBVTtRQUNqRCxNQUFNbk4sU0FBU21OLFdBQVd2Qiw2QkFBNkI7UUFDdkQsSUFBSXVCLFdBQVd6QixlQUFlLElBQUkxTCxPQUFPRyxNQUFNLEtBQUssWUFBWTtZQUM1RDtRQUNKO1FBQ0EsSUFBSWdOLFdBQVcxRCxlQUFlLEdBQUcsR0FBRztZQUNoQzBELFdBQVd6QixlQUFlLEdBQUc7WUFDN0I7UUFDSjtRQUNBLElBQUl5QixXQUFXSCxpQkFBaUIsQ0FBQ3hPLE1BQU0sR0FBRyxHQUFHO1lBQ3pDLE1BQU00Uix1QkFBdUJqRCxXQUFXSCxpQkFBaUIsQ0FBQzFOLElBQUk7WUFDOUQsSUFBSThRLHFCQUFxQnpELFdBQVcsR0FBR3lELHFCQUFxQnZELFdBQVcsS0FBSyxHQUFHO2dCQUMzRSxNQUFNeEksSUFBSSxJQUFJMUcsVUFBVTtnQkFDeEJzTyxrQ0FBa0NrQixZQUFZOUk7Z0JBQzlDLE1BQU1BO1lBQ1Y7UUFDSjtRQUNBK0gsNENBQTRDZTtRQUM1Q2lDLG9CQUFvQnBQO0lBQ3hCO0lBQ0EsU0FBUytMLG9DQUFvQ29CLFVBQVUsRUFBRTdKLEtBQUs7UUFDMUQsTUFBTXRELFNBQVNtTixXQUFXdkIsNkJBQTZCO1FBQ3ZELElBQUl1QixXQUFXekIsZUFBZSxJQUFJMUwsT0FBT0csTUFBTSxLQUFLLFlBQVk7WUFDNUQ7UUFDSjtRQUNBLE1BQU0sRUFBRWtILE1BQU0sRUFBRStCLFVBQVUsRUFBRTNCLFVBQVUsRUFBRSxHQUFHbkU7UUFDM0MsSUFBSWlFLGlCQUFpQkYsU0FBUztZQUMxQixNQUFNLElBQUkxSixVQUFVO1FBQ3hCO1FBQ0EsTUFBTTBTLG9CQUFvQm5KLG9CQUFvQkc7UUFDOUMsSUFBSThGLFdBQVdILGlCQUFpQixDQUFDeE8sTUFBTSxHQUFHLEdBQUc7WUFDekMsTUFBTTRSLHVCQUF1QmpELFdBQVdILGlCQUFpQixDQUFDMU4sSUFBSTtZQUM5RCxJQUFJaUksaUJBQWlCNkkscUJBQXFCL0ksTUFBTSxHQUFHO2dCQUMvQyxNQUFNLElBQUkxSixVQUFVO1lBQ3hCO1lBQ0ErUCxrREFBa0RQO1lBQ2xEaUQscUJBQXFCL0ksTUFBTSxHQUFHSCxvQkFBb0JrSixxQkFBcUIvSSxNQUFNO1lBQzdFLElBQUkrSSxxQkFBcUJyRCxVQUFVLEtBQUssUUFBUTtnQkFDNUNvQiwyREFBMkRoQixZQUFZaUQ7WUFDM0U7UUFDSjtRQUNBLElBQUl6TSwrQkFBK0IzRCxTQUFTO1lBQ3hDdVAsMERBQTBEcEM7WUFDMUQsSUFBSXpKLGlDQUFpQzFELFlBQVksR0FBRztnQkFDaEQrTixnREFBZ0RaLFlBQVlrRCxtQkFBbUJqSCxZQUFZM0I7WUFDL0YsT0FDSztnQkFDRCxJQUFJMEYsV0FBV0gsaUJBQWlCLENBQUN4TyxNQUFNLEdBQUcsR0FBRztvQkFDekM2UCxpREFBaURsQjtnQkFDckQ7Z0JBQ0EsTUFBTW1ELGtCQUFrQixJQUFJdEosV0FBV3FKLG1CQUFtQmpILFlBQVkzQjtnQkFDdEVwRSxpQ0FBaUNyRCxRQUFRc1EsaUJBQWlCO1lBQzlEO1FBQ0osT0FDSyxJQUFJVCw0QkFBNEI3UCxTQUFTO1lBQzFDLGlHQUFpRztZQUNqRytOLGdEQUFnRFosWUFBWWtELG1CQUFtQmpILFlBQVkzQjtZQUMzRjZILGlFQUFpRW5DO1FBQ3JFLE9BQ0s7WUFDRFksZ0RBQWdEWixZQUFZa0QsbUJBQW1CakgsWUFBWTNCO1FBQy9GO1FBQ0F3Riw2Q0FBNkNFO0lBQ2pEO0lBQ0EsU0FBU2xCLGtDQUFrQ2tCLFVBQVUsRUFBRTlJLENBQUM7UUFDcEQsTUFBTXJFLFNBQVNtTixXQUFXdkIsNkJBQTZCO1FBQ3ZELElBQUk1TCxPQUFPRyxNQUFNLEtBQUssWUFBWTtZQUM5QjtRQUNKO1FBQ0ErTCxrREFBa0RpQjtRQUNsRHBELFdBQVdvRDtRQUNYZiw0Q0FBNENlO1FBQzVDb0Qsb0JBQW9CdlEsUUFBUXFFO0lBQ2hDO0lBQ0EsU0FBU2dJLHFEQUFxRGMsVUFBVSxFQUFFaEssV0FBVztRQUNqRixNQUFNcU4sUUFBUXJELFdBQVczRCxNQUFNLENBQUMzSyxLQUFLO1FBQ3JDc08sV0FBVzFELGVBQWUsSUFBSStHLE1BQU0vSSxVQUFVO1FBQzlDMEgsNkNBQTZDaEM7UUFDN0MsTUFBTS9DLE9BQU8sSUFBSXBELFdBQVd3SixNQUFNbkosTUFBTSxFQUFFbUosTUFBTXBILFVBQVUsRUFBRW9ILE1BQU0vSSxVQUFVO1FBQzVFdEUsWUFBWU0sV0FBVyxDQUFDMkc7SUFDNUI7SUFDQSxTQUFTa0IsMkNBQTJDNkIsVUFBVTtRQUMxRCxJQUFJQSxXQUFXa0MsWUFBWSxLQUFLLFFBQVFsQyxXQUFXSCxpQkFBaUIsQ0FBQ3hPLE1BQU0sR0FBRyxHQUFHO1lBQzdFLE1BQU00UCxrQkFBa0JqQixXQUFXSCxpQkFBaUIsQ0FBQzFOLElBQUk7WUFDekQsTUFBTThLLE9BQU8sSUFBSXBELFdBQVdvSCxnQkFBZ0IvRyxNQUFNLEVBQUUrRyxnQkFBZ0JoRixVQUFVLEdBQUdnRixnQkFBZ0J6QixXQUFXLEVBQUV5QixnQkFBZ0IzRyxVQUFVLEdBQUcyRyxnQkFBZ0J6QixXQUFXO1lBQ3RLLE1BQU14QixjQUFjaFEsT0FBT2tMLE1BQU0sQ0FBQ2tFLDBCQUEwQjVPLFNBQVM7WUFDckU4VSwrQkFBK0J0RixhQUFhZ0MsWUFBWS9DO1lBQ3hEK0MsV0FBV2tDLFlBQVksR0FBR2xFO1FBQzlCO1FBQ0EsT0FBT2dDLFdBQVdrQyxZQUFZO0lBQ2xDO0lBQ0EsU0FBUzdELDJDQUEyQzJCLFVBQVU7UUFDMUQsTUFBTXhCLFFBQVF3QixXQUFXdkIsNkJBQTZCLENBQUN6TCxNQUFNO1FBQzdELElBQUl3TCxVQUFVLFdBQVc7WUFDckIsT0FBTztRQUNYO1FBQ0EsSUFBSUEsVUFBVSxVQUFVO1lBQ3BCLE9BQU87UUFDWDtRQUNBLE9BQU93QixXQUFXdUQsWUFBWSxHQUFHdkQsV0FBVzFELGVBQWU7SUFDL0Q7SUFDQSxTQUFTcUIsb0NBQW9DcUMsVUFBVSxFQUFFdkMsWUFBWTtRQUNqRSxNQUFNd0Qsa0JBQWtCakIsV0FBV0gsaUJBQWlCLENBQUMxTixJQUFJO1FBQ3pELE1BQU1xTSxRQUFRd0IsV0FBV3ZCLDZCQUE2QixDQUFDekwsTUFBTTtRQUM3RCxJQUFJd0wsVUFBVSxVQUFVO1lBQ3BCLElBQUlmLGlCQUFpQixHQUFHO2dCQUNwQixNQUFNLElBQUlqTixVQUFVO1lBQ3hCO1FBQ0osT0FDSztZQUNELElBQUlpTixpQkFBaUIsR0FBRztnQkFDcEIsTUFBTSxJQUFJak4sVUFBVTtZQUN4QjtZQUNBLElBQUl5USxnQkFBZ0J6QixXQUFXLEdBQUcvQixlQUFld0QsZ0JBQWdCM0csVUFBVSxFQUFFO2dCQUN6RSxNQUFNLElBQUlvQyxXQUFXO1lBQ3pCO1FBQ0o7UUFDQXVFLGdCQUFnQi9HLE1BQU0sR0FBR0gsb0JBQW9Ca0gsZ0JBQWdCL0csTUFBTTtRQUNuRTRJLDRDQUE0QzlDLFlBQVl2QztJQUM1RDtJQUNBLFNBQVNLLCtDQUErQ2tDLFVBQVUsRUFBRS9DLElBQUk7UUFDcEUsTUFBTWdFLGtCQUFrQmpCLFdBQVdILGlCQUFpQixDQUFDMU4sSUFBSTtRQUN6RCxNQUFNcU0sUUFBUXdCLFdBQVd2Qiw2QkFBNkIsQ0FBQ3pMLE1BQU07UUFDN0QsSUFBSXdMLFVBQVUsVUFBVTtZQUNwQixJQUFJdkIsS0FBSzNDLFVBQVUsS0FBSyxHQUFHO2dCQUN2QixNQUFNLElBQUk5SixVQUFVO1lBQ3hCO1FBQ0osT0FDSztZQUNELElBQUl5TSxLQUFLM0MsVUFBVSxLQUFLLEdBQUc7Z0JBQ3ZCLE1BQU0sSUFBSTlKLFVBQVU7WUFDeEI7UUFDSjtRQUNBLElBQUl5USxnQkFBZ0JoRixVQUFVLEdBQUdnRixnQkFBZ0J6QixXQUFXLEtBQUt2QyxLQUFLaEIsVUFBVSxFQUFFO1lBQzlFLE1BQU0sSUFBSVMsV0FBVztRQUN6QjtRQUNBLElBQUl1RSxnQkFBZ0IxQixnQkFBZ0IsS0FBS3RDLEtBQUsvQyxNQUFNLENBQUNJLFVBQVUsRUFBRTtZQUM3RCxNQUFNLElBQUlvQyxXQUFXO1FBQ3pCO1FBQ0EsSUFBSXVFLGdCQUFnQnpCLFdBQVcsR0FBR3ZDLEtBQUszQyxVQUFVLEdBQUcyRyxnQkFBZ0IzRyxVQUFVLEVBQUU7WUFDNUUsTUFBTSxJQUFJb0MsV0FBVztRQUN6QjtRQUNBLE1BQU04RyxpQkFBaUJ2RyxLQUFLM0MsVUFBVTtRQUN0QzJHLGdCQUFnQi9HLE1BQU0sR0FBR0gsb0JBQW9Ca0QsS0FBSy9DLE1BQU07UUFDeEQ0SSw0Q0FBNEM5QyxZQUFZd0Q7SUFDNUQ7SUFDQSxTQUFTQyxrQ0FBa0M1USxNQUFNLEVBQUVtTixVQUFVLEVBQUUwRCxjQUFjLEVBQUVDLGFBQWEsRUFBRUMsZUFBZSxFQUFFQyxhQUFhLEVBQUUxRSxxQkFBcUI7UUFDL0lhLFdBQVd2Qiw2QkFBNkIsR0FBRzVMO1FBQzNDbU4sV0FBV0ksVUFBVSxHQUFHO1FBQ3hCSixXQUFXRyxRQUFRLEdBQUc7UUFDdEJILFdBQVdrQyxZQUFZLEdBQUc7UUFDMUIseUdBQXlHO1FBQ3pHbEMsV0FBVzNELE1BQU0sR0FBRzJELFdBQVcxRCxlQUFlLEdBQUc3TztRQUNqRG1QLFdBQVdvRDtRQUNYQSxXQUFXekIsZUFBZSxHQUFHO1FBQzdCeUIsV0FBV2dELFFBQVEsR0FBRztRQUN0QmhELFdBQVd1RCxZQUFZLEdBQUdNO1FBQzFCN0QsV0FBV00sY0FBYyxHQUFHcUQ7UUFDNUIzRCxXQUFXaEIsZ0JBQWdCLEdBQUc0RTtRQUM5QjVELFdBQVdaLHNCQUFzQixHQUFHRDtRQUNwQ2EsV0FBV0gsaUJBQWlCLEdBQUcsSUFBSWhQO1FBQ25DZ0MsT0FBT2EseUJBQXlCLEdBQUdzTTtRQUNuQyxNQUFNOEQsY0FBY0o7UUFDcEJsVSxZQUFZVCxvQkFBb0IrVSxjQUFjO1lBQzFDOUQsV0FBV2dELFFBQVEsR0FBRztZQUN0QmxELDZDQUE2Q0U7WUFDN0MsT0FBTztRQUNYLEdBQUcrRCxDQUFBQTtZQUNDakYsa0NBQWtDa0IsWUFBWStEO1lBQzlDLE9BQU87UUFDWDtJQUNKO0lBQ0EsU0FBU0Msc0RBQXNEblIsTUFBTSxFQUFFb1Isb0JBQW9CLEVBQUVKLGFBQWE7UUFDdEcsTUFBTTdELGFBQWFoUyxPQUFPa0wsTUFBTSxDQUFDNkUsNkJBQTZCdlAsU0FBUztRQUN2RSxJQUFJa1Y7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUsscUJBQXFCQyxLQUFLLEtBQUt6VyxXQUFXO1lBQzFDaVcsaUJBQWlCLElBQU1PLHFCQUFxQkMsS0FBSyxDQUFDbEU7UUFDdEQsT0FDSztZQUNEMEQsaUJBQWlCLElBQU1qVztRQUMzQjtRQUNBLElBQUl3VyxxQkFBcUJFLElBQUksS0FBSzFXLFdBQVc7WUFDekNrVyxnQkFBZ0IsSUFBTU0scUJBQXFCRSxJQUFJLENBQUNuRTtRQUNwRCxPQUNLO1lBQ0QyRCxnQkFBZ0IsSUFBTTVVLG9CQUFvQnRCO1FBQzlDO1FBQ0EsSUFBSXdXLHFCQUFxQnBOLE1BQU0sS0FBS3BKLFdBQVc7WUFDM0NtVyxrQkFBa0IxVSxDQUFBQSxTQUFVK1UscUJBQXFCcE4sTUFBTSxDQUFDM0g7UUFDNUQsT0FDSztZQUNEMFUsa0JBQWtCLElBQU03VSxvQkFBb0J0QjtRQUNoRDtRQUNBLE1BQU0wUix3QkFBd0I4RSxxQkFBcUI5RSxxQkFBcUI7UUFDeEUsSUFBSUEsMEJBQTBCLEdBQUc7WUFDN0IsTUFBTSxJQUFJM08sVUFBVTtRQUN4QjtRQUNBaVQsa0NBQWtDNVEsUUFBUW1OLFlBQVkwRCxnQkFBZ0JDLGVBQWVDLGlCQUFpQkMsZUFBZTFFO0lBQ3pIO0lBQ0EsU0FBU21FLCtCQUErQmMsT0FBTyxFQUFFcEUsVUFBVSxFQUFFL0MsSUFBSTtRQUM3RG1ILFFBQVExRyx1Q0FBdUMsR0FBR3NDO1FBQ2xEb0UsUUFBUTdHLEtBQUssR0FBR047SUFDcEI7SUFDQSxzREFBc0Q7SUFDdEQsU0FBU0ssK0JBQStCdlAsSUFBSTtRQUN4QyxPQUFPLElBQUl5QyxVQUFVLENBQUMsb0NBQW9DLEVBQUV6QyxLQUFLLGdEQUFnRCxDQUFDO0lBQ3RIO0lBQ0EseURBQXlEO0lBQ3pELFNBQVNtUSx3Q0FBd0NuUSxJQUFJO1FBQ2pELE9BQU8sSUFBSXlDLFVBQVUsQ0FBQyx1Q0FBdUMsRUFBRXpDLEtBQUssbURBQW1ELENBQUM7SUFDNUg7SUFFQSxTQUFTc1cscUJBQXFCQyxPQUFPLEVBQUUxUCxPQUFPO1FBQzFDRixpQkFBaUI0UCxTQUFTMVA7UUFDMUIsTUFBTTJQLE9BQU9ELFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRQyxJQUFJO1FBQzNFLE9BQU87WUFDSEEsTUFBTUEsU0FBUzlXLFlBQVlBLFlBQVkrVyxnQ0FBZ0NELE1BQU0sQ0FBQyxFQUFFM1AsUUFBUSx1QkFBdUIsQ0FBQztRQUNwSDtJQUNKO0lBQ0EsU0FBUzRQLGdDQUFnQ0QsSUFBSSxFQUFFM1AsT0FBTztRQUNsRDJQLE9BQU8sQ0FBQyxFQUFFQSxLQUFLLENBQUM7UUFDaEIsSUFBSUEsU0FBUyxRQUFRO1lBQ2pCLE1BQU0sSUFBSS9ULFVBQVUsQ0FBQyxFQUFFb0UsUUFBUSxFQUFFLEVBQUUyUCxLQUFLLCtEQUErRCxDQUFDO1FBQzVHO1FBQ0EsT0FBT0E7SUFDWDtJQUNBLFNBQVNFLHVCQUF1QkgsT0FBTyxFQUFFMVAsT0FBTztRQUM1QyxJQUFJeEc7UUFDSnNHLGlCQUFpQjRQLFNBQVMxUDtRQUMxQixNQUFNeU0sTUFBTSxDQUFDalQsS0FBS2tXLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRakQsR0FBRyxNQUFNLFFBQVFqVCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUNsSCxPQUFPO1lBQ0hpVCxLQUFLOUwsd0NBQXdDOEwsS0FBSyxDQUFDLEVBQUV6TSxRQUFRLHNCQUFzQixDQUFDO1FBQ3hGO0lBQ0o7SUFFQSw4Q0FBOEM7SUFDOUMsU0FBUzhQLGdDQUFnQzdSLE1BQU07UUFDM0MsT0FBTyxJQUFJOFIseUJBQXlCOVI7SUFDeEM7SUFDQSw4Q0FBOEM7SUFDOUMsU0FBUzBQLGlDQUFpQzFQLE1BQU0sRUFBRXlQLGVBQWU7UUFDN0R6UCxPQUFPRSxPQUFPLENBQUM2UixpQkFBaUIsQ0FBQ3RULElBQUksQ0FBQ2dSO0lBQzFDO0lBQ0EsU0FBUzNCLHFDQUFxQzlOLE1BQU0sRUFBRXNELEtBQUssRUFBRUMsSUFBSTtRQUM3RCxNQUFNeEQsU0FBU0MsT0FBT0UsT0FBTztRQUM3QixNQUFNdVAsa0JBQWtCMVAsT0FBT2dTLGlCQUFpQixDQUFDbFQsS0FBSztRQUN0RCxJQUFJMEUsTUFBTTtZQUNOa00sZ0JBQWdCak0sV0FBVyxDQUFDRjtRQUNoQyxPQUNLO1lBQ0RtTSxnQkFBZ0JoTSxXQUFXLENBQUNIO1FBQ2hDO0lBQ0o7SUFDQSxTQUFTd00scUNBQXFDOVAsTUFBTTtRQUNoRCxPQUFPQSxPQUFPRSxPQUFPLENBQUM2UixpQkFBaUIsQ0FBQ3ZULE1BQU07SUFDbEQ7SUFDQSxTQUFTcVIsNEJBQTRCN1AsTUFBTTtRQUN2QyxNQUFNRCxTQUFTQyxPQUFPRSxPQUFPO1FBQzdCLElBQUlILFdBQVduRixXQUFXO1lBQ3RCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ29YLDJCQUEyQmpTLFNBQVM7WUFDckMsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0lBQ0E7Ozs7S0FJQyxHQUNELE1BQU0rUjtRQUNGN1QsWUFBWStCLE1BQU0sQ0FBRTtZQUNoQm1DLHVCQUF1Qm5DLFFBQVEsR0FBRztZQUNsQzhDLHFCQUFxQjlDLFFBQVE7WUFDN0IsSUFBSTZELHVCQUF1QjdELFNBQVM7Z0JBQ2hDLE1BQU0sSUFBSXJDLFVBQVU7WUFDeEI7WUFDQSxJQUFJLENBQUN5TiwrQkFBK0JwTCxPQUFPYSx5QkFBeUIsR0FBRztnQkFDbkUsTUFBTSxJQUFJbEQsVUFBVSwwRkFDaEI7WUFDUjtZQUNBbUMsc0NBQXNDLElBQUksRUFBRUU7WUFDNUMsSUFBSSxDQUFDK1IsaUJBQWlCLEdBQUcsSUFBSS9UO1FBQ2pDO1FBQ0E7OztTQUdDLEdBQ0QsSUFBSThGLFNBQVM7WUFDVCxJQUFJLENBQUNrTywyQkFBMkIsSUFBSSxHQUFHO2dCQUNuQyxPQUFPNVYsb0JBQW9CNlYsOEJBQThCO1lBQzdEO1lBQ0EsT0FBTyxJQUFJLENBQUNsUixjQUFjO1FBQzlCO1FBQ0E7O1NBRUMsR0FDRGlELE9BQU8zSCxTQUFTekIsU0FBUyxFQUFFO1lBQ3ZCLElBQUksQ0FBQ29YLDJCQUEyQixJQUFJLEdBQUc7Z0JBQ25DLE9BQU81VixvQkFBb0I2Viw4QkFBOEI7WUFDN0Q7WUFDQSxJQUFJLElBQUksQ0FBQ2hTLG9CQUFvQixLQUFLckYsV0FBVztnQkFDekMsT0FBT3dCLG9CQUFvQjBFLG9CQUFvQjtZQUNuRDtZQUNBLE9BQU9OLGtDQUFrQyxJQUFJLEVBQUVuRTtRQUNuRDtRQUNBNEgsS0FBS21HLElBQUksRUFBRThILGFBQWEsQ0FBQyxDQUFDLEVBQUU7WUFDeEIsSUFBSSxDQUFDRiwyQkFBMkIsSUFBSSxHQUFHO2dCQUNuQyxPQUFPNVYsb0JBQW9CNlYsOEJBQThCO1lBQzdEO1lBQ0EsSUFBSSxDQUFDcEssWUFBWW1ELE1BQU0sQ0FBQ1osT0FBTztnQkFDM0IsT0FBT2hPLG9CQUFvQixJQUFJdUIsVUFBVTtZQUM3QztZQUNBLElBQUl5TSxLQUFLM0MsVUFBVSxLQUFLLEdBQUc7Z0JBQ3ZCLE9BQU9yTCxvQkFBb0IsSUFBSXVCLFVBQVU7WUFDN0M7WUFDQSxJQUFJeU0sS0FBSy9DLE1BQU0sQ0FBQ0ksVUFBVSxLQUFLLEdBQUc7Z0JBQzlCLE9BQU9yTCxvQkFBb0IsSUFBSXVCLFVBQVUsQ0FBQywyQ0FBMkMsQ0FBQztZQUMxRjtZQUNBLElBQUk0SixpQkFBaUI2QyxLQUFLL0MsTUFBTSxHQUFHO2dCQUMvQixPQUFPakwsb0JBQW9CLElBQUl1QixVQUFVO1lBQzdDO1lBQ0EsSUFBSThUO1lBQ0osSUFBSTtnQkFDQUEsVUFBVUcsdUJBQXVCTSxZQUFZO1lBQ2pELEVBQ0EsT0FBTzdOLEdBQUc7Z0JBQ04sT0FBT2pJLG9CQUFvQmlJO1lBQy9CO1lBQ0EsTUFBTW1LLE1BQU1pRCxRQUFRakQsR0FBRztZQUN2QixJQUFJQSxRQUFRLEdBQUc7Z0JBQ1gsT0FBT3BTLG9CQUFvQixJQUFJdUIsVUFBVTtZQUM3QztZQUNBLElBQUksQ0FBQ3dNLFdBQVdDLE9BQU87Z0JBQ25CLElBQUlvRSxNQUFNcEUsS0FBSzVMLE1BQU0sRUFBRTtvQkFDbkIsT0FBT3BDLG9CQUFvQixJQUFJeU4sV0FBVztnQkFDOUM7WUFDSixPQUNLLElBQUkyRSxNQUFNcEUsS0FBSzNDLFVBQVUsRUFBRTtnQkFDNUIsT0FBT3JMLG9CQUFvQixJQUFJeU4sV0FBVztZQUM5QztZQUNBLElBQUksSUFBSSxDQUFDNUosb0JBQW9CLEtBQUtyRixXQUFXO2dCQUN6QyxPQUFPd0Isb0JBQW9CMEUsb0JBQW9CO1lBQ25EO1lBQ0EsSUFBSW9EO1lBQ0osSUFBSUM7WUFDSixNQUFNNUgsVUFBVVAsV0FBVyxDQUFDRyxTQUFTTDtnQkFDakNvSSxpQkFBaUIvSDtnQkFDakJnSSxnQkFBZ0JySTtZQUNwQjtZQUNBLE1BQU0yVCxrQkFBa0I7Z0JBQ3BCaE0sYUFBYUgsQ0FBQUEsUUFBU1ksZUFBZTt3QkFBRTdJLE9BQU9pSTt3QkFBT0MsTUFBTTtvQkFBTTtnQkFDakVDLGFBQWFGLENBQUFBLFFBQVNZLGVBQWU7d0JBQUU3SSxPQUFPaUk7d0JBQU9DLE1BQU07b0JBQUs7Z0JBQ2hFYSxhQUFhQyxDQUFBQSxJQUFLRixjQUFjRTtZQUNwQztZQUNBOE4sNkJBQTZCLElBQUksRUFBRS9ILE1BQU1vRSxLQUFLaUI7WUFDOUMsT0FBT2xUO1FBQ1g7UUFDQTs7Ozs7Ozs7U0FRQyxHQUNEZ0ksY0FBYztZQUNWLElBQUksQ0FBQ3lOLDJCQUEyQixJQUFJLEdBQUc7Z0JBQ25DLE1BQU1DLDhCQUE4QjtZQUN4QztZQUNBLElBQUksSUFBSSxDQUFDaFMsb0JBQW9CLEtBQUtyRixXQUFXO2dCQUN6QztZQUNKO1lBQ0F3WCxnQ0FBZ0MsSUFBSTtRQUN4QztJQUNKO0lBQ0FqWCxPQUFPc0osZ0JBQWdCLENBQUNxTix5QkFBeUJuVyxTQUFTLEVBQUU7UUFDeERxSSxRQUFRO1lBQUVVLFlBQVk7UUFBSztRQUMzQlQsTUFBTTtZQUFFUyxZQUFZO1FBQUs7UUFDekJILGFBQWE7WUFBRUcsWUFBWTtRQUFLO1FBQ2hDWixRQUFRO1lBQUVZLFlBQVk7UUFBSztJQUMvQjtJQUNBMUosZ0JBQWdCOFcseUJBQXlCblcsU0FBUyxDQUFDcUksTUFBTSxFQUFFO0lBQzNEaEosZ0JBQWdCOFcseUJBQXlCblcsU0FBUyxDQUFDc0ksSUFBSSxFQUFFO0lBQ3pEakosZ0JBQWdCOFcseUJBQXlCblcsU0FBUyxDQUFDNEksV0FBVyxFQUFFO0lBQ2hFLElBQUksT0FBT2hLLGVBQWVvSyxXQUFXLEtBQUssVUFBVTtRQUNoRHhKLE9BQU9DLGNBQWMsQ0FBQzBXLHlCQUF5Qm5XLFNBQVMsRUFBRXBCLGVBQWVvSyxXQUFXLEVBQUU7WUFDbEZ0SixPQUFPO1lBQ1BDLGNBQWM7UUFDbEI7SUFDSjtJQUNBLHVDQUF1QztJQUN2QyxTQUFTMFcsMkJBQTJCbFgsQ0FBQztRQUNqQyxJQUFJLENBQUNELGFBQWFDLElBQUk7WUFDbEIsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDSyxPQUFPUSxTQUFTLENBQUNpSixjQUFjLENBQUNsSSxJQUFJLENBQUM1QixHQUFHLHNCQUFzQjtZQUMvRCxPQUFPO1FBQ1g7UUFDQSxPQUFPQSxhQUFhZ1g7SUFDeEI7SUFDQSxTQUFTSyw2QkFBNkJwUyxNQUFNLEVBQUVxSyxJQUFJLEVBQUVvRSxHQUFHLEVBQUVpQixlQUFlO1FBQ3BFLE1BQU16UCxTQUFTRCxPQUFPRSxvQkFBb0I7UUFDMUNELE9BQU82RSxVQUFVLEdBQUc7UUFDcEIsSUFBSTdFLE9BQU9HLE1BQU0sS0FBSyxXQUFXO1lBQzdCc1AsZ0JBQWdCckwsV0FBVyxDQUFDcEUsT0FBT08sWUFBWTtRQUNuRCxPQUNLO1lBQ0RpUCxxQ0FBcUN4UCxPQUFPYSx5QkFBeUIsRUFBRXVKLE1BQU1vRSxLQUFLaUI7UUFDdEY7SUFDSjtJQUNBLFNBQVMyQyxnQ0FBZ0NyUyxNQUFNO1FBQzNDVyxtQ0FBbUNYO1FBQ25DLE1BQU1zRSxJQUFJLElBQUkxRyxVQUFVO1FBQ3hCMFUsOENBQThDdFMsUUFBUXNFO0lBQzFEO0lBQ0EsU0FBU2dPLDhDQUE4Q3RTLE1BQU0sRUFBRXNFLENBQUM7UUFDNUQsTUFBTWlPLG1CQUFtQnZTLE9BQU9nUyxpQkFBaUI7UUFDakRoUyxPQUFPZ1MsaUJBQWlCLEdBQUcsSUFBSS9UO1FBQy9Cc1UsaUJBQWlCblQsT0FBTyxDQUFDc1EsQ0FBQUE7WUFDckJBLGdCQUFnQnJMLFdBQVcsQ0FBQ0M7UUFDaEM7SUFDSjtJQUNBLHFEQUFxRDtJQUNyRCxTQUFTNE4sOEJBQThCL1csSUFBSTtRQUN2QyxPQUFPLElBQUl5QyxVQUFVLENBQUMsbUNBQW1DLEVBQUV6QyxLQUFLLCtDQUErQyxDQUFDO0lBQ3BIO0lBRUEsU0FBU3FYLHFCQUFxQkMsUUFBUSxFQUFFQyxVQUFVO1FBQzlDLE1BQU0sRUFBRXpCLGFBQWEsRUFBRSxHQUFHd0I7UUFDMUIsSUFBSXhCLGtCQUFrQnBXLFdBQVc7WUFDN0IsT0FBTzZYO1FBQ1g7UUFDQSxJQUFJbk0sWUFBWTBLLGtCQUFrQkEsZ0JBQWdCLEdBQUc7WUFDakQsTUFBTSxJQUFJbkgsV0FBVztRQUN6QjtRQUNBLE9BQU9tSDtJQUNYO0lBQ0EsU0FBUzBCLHFCQUFxQkYsUUFBUTtRQUNsQyxNQUFNLEVBQUU5SSxJQUFJLEVBQUUsR0FBRzhJO1FBQ2pCLElBQUksQ0FBQzlJLE1BQU07WUFDUCxPQUFPLElBQU07UUFDakI7UUFDQSxPQUFPQTtJQUNYO0lBRUEsU0FBU2lKLHVCQUF1QkMsSUFBSSxFQUFFN1EsT0FBTztRQUN6Q0YsaUJBQWlCK1EsTUFBTTdRO1FBQ3ZCLE1BQU1pUCxnQkFBZ0I0QixTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSzVCLGFBQWE7UUFDcEYsTUFBTXRILE9BQU9rSixTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS2xKLElBQUk7UUFDbEUsT0FBTztZQUNIc0gsZUFBZUEsa0JBQWtCcFcsWUFBWUEsWUFBWTJILDBCQUEwQnlPO1lBQ25GdEgsTUFBTUEsU0FBUzlPLFlBQVlBLFlBQVlpWSwyQkFBMkJuSixNQUFNLENBQUMsRUFBRTNILFFBQVEsdUJBQXVCLENBQUM7UUFDL0c7SUFDSjtJQUNBLFNBQVM4USwyQkFBMkI1WCxFQUFFLEVBQUU4RyxPQUFPO1FBQzNDQyxlQUFlL0csSUFBSThHO1FBQ25CLE9BQU91QixDQUFBQSxRQUFTZiwwQkFBMEJ0SCxHQUFHcUk7SUFDakQ7SUFFQSxTQUFTd1Asc0JBQXNCQyxRQUFRLEVBQUVoUixPQUFPO1FBQzVDRixpQkFBaUJrUixVQUFVaFI7UUFDM0IsTUFBTWlSLFFBQVFELGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTQyxLQUFLO1FBQ2hGLE1BQU12SCxRQUFRc0gsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN0SCxLQUFLO1FBQ2hGLE1BQU00RixRQUFRMEIsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVMxQixLQUFLO1FBQ2hGLE1BQU00QixPQUFPRixhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU0UsSUFBSTtRQUM5RSxNQUFNQyxRQUFRSCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU0csS0FBSztRQUNoRixPQUFPO1lBQ0hGLE9BQU9BLFVBQVVwWSxZQUNiQSxZQUNBdVksbUNBQW1DSCxPQUFPRCxVQUFVLENBQUMsRUFBRWhSLFFBQVEsd0JBQXdCLENBQUM7WUFDNUYwSixPQUFPQSxVQUFVN1EsWUFDYkEsWUFDQXdZLG1DQUFtQzNILE9BQU9zSCxVQUFVLENBQUMsRUFBRWhSLFFBQVEsd0JBQXdCLENBQUM7WUFDNUZzUCxPQUFPQSxVQUFVelcsWUFDYkEsWUFDQXlZLG1DQUFtQ2hDLE9BQU8wQixVQUFVLENBQUMsRUFBRWhSLFFBQVEsd0JBQXdCLENBQUM7WUFDNUZtUixPQUFPQSxVQUFVdFksWUFDYkEsWUFDQTBZLG1DQUFtQ0osT0FBT0gsVUFBVSxDQUFDLEVBQUVoUixRQUFRLHdCQUF3QixDQUFDO1lBQzVGa1I7UUFDSjtJQUNKO0lBQ0EsU0FBU0UsbUNBQW1DbFksRUFBRSxFQUFFOFgsUUFBUSxFQUFFaFIsT0FBTztRQUM3REMsZUFBZS9HLElBQUk4RztRQUNuQixPQUFPLENBQUMxRixTQUFXeUIsWUFBWTdDLElBQUk4WCxVQUFVO2dCQUFDMVc7YUFBTztJQUN6RDtJQUNBLFNBQVMrVyxtQ0FBbUNuWSxFQUFFLEVBQUU4WCxRQUFRLEVBQUVoUixPQUFPO1FBQzdEQyxlQUFlL0csSUFBSThHO1FBQ25CLE9BQU8sSUFBTWpFLFlBQVk3QyxJQUFJOFgsVUFBVSxFQUFFO0lBQzdDO0lBQ0EsU0FBU00sbUNBQW1DcFksRUFBRSxFQUFFOFgsUUFBUSxFQUFFaFIsT0FBTztRQUM3REMsZUFBZS9HLElBQUk4RztRQUNuQixPQUFPLENBQUNvTCxhQUFlNVAsWUFBWXRDLElBQUk4WCxVQUFVO2dCQUFDNUY7YUFBVztJQUNqRTtJQUNBLFNBQVNtRyxtQ0FBbUNyWSxFQUFFLEVBQUU4WCxRQUFRLEVBQUVoUixPQUFPO1FBQzdEQyxlQUFlL0csSUFBSThHO1FBQ25CLE9BQU8sQ0FBQ3VCLE9BQU82SixhQUFlclAsWUFBWTdDLElBQUk4WCxVQUFVO2dCQUFDelA7Z0JBQU82SjthQUFXO0lBQy9FO0lBRUEsU0FBU29HLHFCQUFxQnpZLENBQUMsRUFBRWlILE9BQU87UUFDcEMsSUFBSSxDQUFDeVIsaUJBQWlCMVksSUFBSTtZQUN0QixNQUFNLElBQUk2QyxVQUFVLENBQUMsRUFBRW9FLFFBQVEseUJBQXlCLENBQUM7UUFDN0Q7SUFDSjtJQUVBLFNBQVMwUixjQUFjcFksS0FBSztRQUN4QixJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxNQUFNO1lBQzdDLE9BQU87UUFDWDtRQUNBLElBQUk7WUFDQSxPQUFPLE9BQU9BLE1BQU1xWSxPQUFPLEtBQUs7UUFDcEMsRUFDQSxPQUFPblksSUFBSTtZQUNQLGdFQUFnRTtZQUNoRSxPQUFPO1FBQ1g7SUFDSjtJQUNBLE1BQU1vWSwwQkFBMEIsT0FBT0Msb0JBQW9CO0lBQzNEOzs7O0tBSUMsR0FDRCxTQUFTQztRQUNMLElBQUlGLHlCQUF5QjtZQUN6QixPQUFPLElBQUlDO1FBQ2Y7UUFDQSxPQUFPaFo7SUFDWDtJQUVBOzs7O0tBSUMsR0FDRCxNQUFNa1o7UUFDRjdWLFlBQVk4VixvQkFBb0IsQ0FBQyxDQUFDLEVBQUVDLGNBQWMsQ0FBQyxDQUFDLENBQUU7WUFDbEQsSUFBSUQsc0JBQXNCblosV0FBVztnQkFDakNtWixvQkFBb0I7WUFDeEIsT0FDSztnQkFDRDdSLGFBQWE2UixtQkFBbUI7WUFDcEM7WUFDQSxNQUFNdkIsV0FBV0csdUJBQXVCcUIsYUFBYTtZQUNyRCxNQUFNQyxpQkFBaUJuQixzQkFBc0JpQixtQkFBbUI7WUFDaEVHLHlCQUF5QixJQUFJO1lBQzdCLE1BQU1qQixPQUFPZ0IsZUFBZWhCLElBQUk7WUFDaEMsSUFBSUEsU0FBU3JZLFdBQVc7Z0JBQ3BCLE1BQU0sSUFBSWlQLFdBQVc7WUFDekI7WUFDQSxNQUFNc0ssZ0JBQWdCekIscUJBQXFCRjtZQUMzQyxNQUFNeEIsZ0JBQWdCdUIscUJBQXFCQyxVQUFVO1lBQ3JENEIsdURBQXVELElBQUksRUFBRUgsZ0JBQWdCakQsZUFBZW1EO1FBQ2hHO1FBQ0E7O1NBRUMsR0FDRCxJQUFJRSxTQUFTO1lBQ1QsSUFBSSxDQUFDYixpQkFBaUIsSUFBSSxHQUFHO2dCQUN6QixNQUFNYyw0QkFBNEI7WUFDdEM7WUFDQSxPQUFPQyx1QkFBdUIsSUFBSTtRQUN0QztRQUNBOzs7Ozs7OztTQVFDLEdBQ0R2QixNQUFNM1csU0FBU3pCLFNBQVMsRUFBRTtZQUN0QixJQUFJLENBQUM0WSxpQkFBaUIsSUFBSSxHQUFHO2dCQUN6QixPQUFPcFgsb0JBQW9Ca1ksNEJBQTRCO1lBQzNEO1lBQ0EsSUFBSUMsdUJBQXVCLElBQUksR0FBRztnQkFDOUIsT0FBT25ZLG9CQUFvQixJQUFJdUIsVUFBVTtZQUM3QztZQUNBLE9BQU82VyxvQkFBb0IsSUFBSSxFQUFFblk7UUFDckM7UUFDQTs7Ozs7OztTQU9DLEdBQ0RvUCxRQUFRO1lBQ0osSUFBSSxDQUFDK0gsaUJBQWlCLElBQUksR0FBRztnQkFDekIsT0FBT3BYLG9CQUFvQmtZLDRCQUE0QjtZQUMzRDtZQUNBLElBQUlDLHVCQUF1QixJQUFJLEdBQUc7Z0JBQzlCLE9BQU9uWSxvQkFBb0IsSUFBSXVCLFVBQVU7WUFDN0M7WUFDQSxJQUFJOFcsb0NBQW9DLElBQUksR0FBRztnQkFDM0MsT0FBT3JZLG9CQUFvQixJQUFJdUIsVUFBVTtZQUM3QztZQUNBLE9BQU8rVyxvQkFBb0IsSUFBSTtRQUNuQztRQUNBOzs7Ozs7O1NBT0MsR0FDREMsWUFBWTtZQUNSLElBQUksQ0FBQ25CLGlCQUFpQixJQUFJLEdBQUc7Z0JBQ3pCLE1BQU1jLDRCQUE0QjtZQUN0QztZQUNBLE9BQU9NLG1DQUFtQyxJQUFJO1FBQ2xEO0lBQ0o7SUFDQXpaLE9BQU9zSixnQkFBZ0IsQ0FBQ3FQLGVBQWVuWSxTQUFTLEVBQUU7UUFDOUNxWCxPQUFPO1lBQUV0TyxZQUFZO1FBQUs7UUFDMUIrRyxPQUFPO1lBQUUvRyxZQUFZO1FBQUs7UUFDMUJpUSxXQUFXO1lBQUVqUSxZQUFZO1FBQUs7UUFDOUIyUCxRQUFRO1lBQUUzUCxZQUFZO1FBQUs7SUFDL0I7SUFDQTFKLGdCQUFnQjhZLGVBQWVuWSxTQUFTLENBQUNxWCxLQUFLLEVBQUU7SUFDaERoWSxnQkFBZ0I4WSxlQUFlblksU0FBUyxDQUFDOFAsS0FBSyxFQUFFO0lBQ2hEelEsZ0JBQWdCOFksZUFBZW5ZLFNBQVMsQ0FBQ2daLFNBQVMsRUFBRTtJQUNwRCxJQUFJLE9BQU9wYSxlQUFlb0ssV0FBVyxLQUFLLFVBQVU7UUFDaER4SixPQUFPQyxjQUFjLENBQUMwWSxlQUFlblksU0FBUyxFQUFFcEIsZUFBZW9LLFdBQVcsRUFBRTtZQUN4RXRKLE9BQU87WUFDUEMsY0FBYztRQUNsQjtJQUNKO0lBQ0EsOENBQThDO0lBQzlDLFNBQVNzWixtQ0FBbUM1VSxNQUFNO1FBQzlDLE9BQU8sSUFBSTZVLDRCQUE0QjdVO0lBQzNDO0lBQ0EsK0NBQStDO0lBQy9DLFNBQVM4VSxxQkFBcUJqRSxjQUFjLEVBQUVrRSxjQUFjLEVBQUVDLGNBQWMsRUFBRUMsY0FBYyxFQUFFakUsZ0JBQWdCLENBQUMsRUFBRW1ELGdCQUFnQixJQUFNLENBQUM7UUFDcEksTUFBTW5VLFNBQVM3RSxPQUFPa0wsTUFBTSxDQUFDeU4sZUFBZW5ZLFNBQVM7UUFDckR1WSx5QkFBeUJsVTtRQUN6QixNQUFNbU4sYUFBYWhTLE9BQU9rTCxNQUFNLENBQUM2TyxnQ0FBZ0N2WixTQUFTO1FBQzFFd1oscUNBQXFDblYsUUFBUW1OLFlBQVkwRCxnQkFBZ0JrRSxnQkFBZ0JDLGdCQUFnQkMsZ0JBQWdCakUsZUFBZW1EO1FBQ3hJLE9BQU9uVTtJQUNYO0lBQ0EsU0FBU2tVLHlCQUF5QmxVLE1BQU07UUFDcENBLE9BQU9HLE1BQU0sR0FBRztRQUNoQixpSEFBaUg7UUFDakgsNkRBQTZEO1FBQzdESCxPQUFPTyxZQUFZLEdBQUczRjtRQUN0Qm9GLE9BQU9vVixPQUFPLEdBQUd4YTtRQUNqQixzRkFBc0Y7UUFDdEYsbUNBQW1DO1FBQ25Db0YsT0FBT3FWLHlCQUF5QixHQUFHemE7UUFDbkMsZ0hBQWdIO1FBQ2hILDREQUE0RDtRQUM1RG9GLE9BQU9zVixjQUFjLEdBQUcsSUFBSXRYO1FBQzVCLDhHQUE4RztRQUM5Ryw2R0FBNkc7UUFDN0dnQyxPQUFPdVYscUJBQXFCLEdBQUczYTtRQUMvQiw4R0FBOEc7UUFDOUcscUJBQXFCO1FBQ3JCb0YsT0FBT3dWLGFBQWEsR0FBRzVhO1FBQ3ZCLDhHQUE4RztRQUM5Ryx3R0FBd0c7UUFDeEdvRixPQUFPeVYscUJBQXFCLEdBQUc3YTtRQUMvQiwrR0FBK0c7UUFDL0dvRixPQUFPMFYsb0JBQW9CLEdBQUc5YTtRQUM5QixpREFBaUQ7UUFDakRvRixPQUFPMlYsYUFBYSxHQUFHO0lBQzNCO0lBQ0EsU0FBU25DLGlCQUFpQjFZLENBQUM7UUFDdkIsSUFBSSxDQUFDRCxhQUFhQyxJQUFJO1lBQ2xCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0ssT0FBT1EsU0FBUyxDQUFDaUosY0FBYyxDQUFDbEksSUFBSSxDQUFDNUIsR0FBRyw4QkFBOEI7WUFDdkUsT0FBTztRQUNYO1FBQ0EsT0FBT0EsYUFBYWdaO0lBQ3hCO0lBQ0EsU0FBU1MsdUJBQXVCdlUsTUFBTTtRQUNsQyxJQUFJQSxPQUFPb1YsT0FBTyxLQUFLeGEsV0FBVztZQUM5QixPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQSxTQUFTNFosb0JBQW9CeFUsTUFBTSxFQUFFM0QsTUFBTTtRQUN2QyxJQUFJZDtRQUNKLElBQUl5RSxPQUFPRyxNQUFNLEtBQUssWUFBWUgsT0FBT0csTUFBTSxLQUFLLFdBQVc7WUFDM0QsT0FBT2pFLG9CQUFvQnRCO1FBQy9CO1FBQ0FvRixPQUFPcVYseUJBQXlCLENBQUNPLFlBQVksR0FBR3ZaO1FBQy9DZCxDQUFBQSxLQUFLeUUsT0FBT3FWLHlCQUF5QixDQUFDUSxnQkFBZ0IsTUFBTSxRQUFRdGEsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeVgsS0FBSyxDQUFDM1c7UUFDdkcsa0ZBQWtGO1FBQ2xGLCtGQUErRjtRQUMvRiwwREFBMEQ7UUFDMUQsTUFBTXNQLFFBQVEzTCxPQUFPRyxNQUFNO1FBQzNCLElBQUl3TCxVQUFVLFlBQVlBLFVBQVUsV0FBVztZQUMzQyxPQUFPelAsb0JBQW9CdEI7UUFDL0I7UUFDQSxJQUFJb0YsT0FBTzBWLG9CQUFvQixLQUFLOWEsV0FBVztZQUMzQyxPQUFPb0YsT0FBTzBWLG9CQUFvQixDQUFDSSxRQUFRO1FBQy9DO1FBQ0EsSUFBSUMscUJBQXFCO1FBQ3pCLElBQUlwSyxVQUFVLFlBQVk7WUFDdEJvSyxxQkFBcUI7WUFDckIsNERBQTREO1lBQzVEMVosU0FBU3pCO1FBQ2I7UUFDQSxNQUFNMkIsVUFBVVAsV0FBVyxDQUFDRyxTQUFTTDtZQUNqQ2tFLE9BQU8wVixvQkFBb0IsR0FBRztnQkFDMUJJLFVBQVVsYjtnQkFDVm9iLFVBQVU3WjtnQkFDVjhaLFNBQVNuYTtnQkFDVG9hLFNBQVM3WjtnQkFDVDhaLHFCQUFxQko7WUFDekI7UUFDSjtRQUNBL1YsT0FBTzBWLG9CQUFvQixDQUFDSSxRQUFRLEdBQUd2WjtRQUN2QyxJQUFJLENBQUN3WixvQkFBb0I7WUFDckJLLDRCQUE0QnBXLFFBQVEzRDtRQUN4QztRQUNBLE9BQU9FO0lBQ1g7SUFDQSxTQUFTbVksb0JBQW9CMVUsTUFBTTtRQUMvQixNQUFNMkwsUUFBUTNMLE9BQU9HLE1BQU07UUFDM0IsSUFBSXdMLFVBQVUsWUFBWUEsVUFBVSxXQUFXO1lBQzNDLE9BQU92UCxvQkFBb0IsSUFBSXVCLFVBQVUsQ0FBQyxlQUFlLEVBQUVnTyxNQUFNLHlEQUF5RCxDQUFDO1FBQy9IO1FBQ0EsTUFBTXBQLFVBQVVQLFdBQVcsQ0FBQ0csU0FBU0w7WUFDakMsTUFBTXVhLGVBQWU7Z0JBQ2pCTCxVQUFVN1o7Z0JBQ1Y4WixTQUFTbmE7WUFDYjtZQUNBa0UsT0FBT3dWLGFBQWEsR0FBR2E7UUFDM0I7UUFDQSxNQUFNQyxTQUFTdFcsT0FBT29WLE9BQU87UUFDN0IsSUFBSWtCLFdBQVcxYixhQUFhb0YsT0FBTzJWLGFBQWEsSUFBSWhLLFVBQVUsWUFBWTtZQUN0RTRLLGlDQUFpQ0Q7UUFDckM7UUFDQUUscUNBQXFDeFcsT0FBT3FWLHlCQUF5QjtRQUNyRSxPQUFPOVk7SUFDWDtJQUNBLDhDQUE4QztJQUM5QyxTQUFTa2EsOEJBQThCelcsTUFBTTtRQUN6QyxNQUFNekQsVUFBVVAsV0FBVyxDQUFDRyxTQUFTTDtZQUNqQyxNQUFNNGEsZUFBZTtnQkFDakJWLFVBQVU3WjtnQkFDVjhaLFNBQVNuYTtZQUNiO1lBQ0FrRSxPQUFPc1YsY0FBYyxDQUFDN1csSUFBSSxDQUFDaVk7UUFDL0I7UUFDQSxPQUFPbmE7SUFDWDtJQUNBLFNBQVNvYSxnQ0FBZ0MzVyxNQUFNLEVBQUVnTSxLQUFLO1FBQ2xELE1BQU1MLFFBQVEzTCxPQUFPRyxNQUFNO1FBQzNCLElBQUl3TCxVQUFVLFlBQVk7WUFDdEJ5Syw0QkFBNEJwVyxRQUFRZ007WUFDcEM7UUFDSjtRQUNBNEssNkJBQTZCNVc7SUFDakM7SUFDQSxTQUFTb1csNEJBQTRCcFcsTUFBTSxFQUFFM0QsTUFBTTtRQUMvQyxNQUFNOFEsYUFBYW5OLE9BQU9xVix5QkFBeUI7UUFDbkRyVixPQUFPRyxNQUFNLEdBQUc7UUFDaEJILE9BQU9PLFlBQVksR0FBR2xFO1FBQ3RCLE1BQU1pYSxTQUFTdFcsT0FBT29WLE9BQU87UUFDN0IsSUFBSWtCLFdBQVcxYixXQUFXO1lBQ3RCaWMsc0RBQXNEUCxRQUFRamE7UUFDbEU7UUFDQSxJQUFJLENBQUN5YSx5Q0FBeUM5VyxXQUFXbU4sV0FBV2dELFFBQVEsRUFBRTtZQUMxRXlHLDZCQUE2QjVXO1FBQ2pDO0lBQ0o7SUFDQSxTQUFTNFcsNkJBQTZCNVcsTUFBTTtRQUN4Q0EsT0FBT0csTUFBTSxHQUFHO1FBQ2hCSCxPQUFPcVYseUJBQXlCLENBQUMzVixXQUFXO1FBQzVDLE1BQU1xWCxjQUFjL1csT0FBT08sWUFBWTtRQUN2Q1AsT0FBT3NWLGNBQWMsQ0FBQ25XLE9BQU8sQ0FBQ3VYLENBQUFBO1lBQzFCQSxhQUFhVCxPQUFPLENBQUNjO1FBQ3pCO1FBQ0EvVyxPQUFPc1YsY0FBYyxHQUFHLElBQUl0WDtRQUM1QixJQUFJZ0MsT0FBTzBWLG9CQUFvQixLQUFLOWEsV0FBVztZQUMzQ29jLGtEQUFrRGhYO1lBQ2xEO1FBQ0o7UUFDQSxNQUFNaVgsZUFBZWpYLE9BQU8wVixvQkFBb0I7UUFDaEQxVixPQUFPMFYsb0JBQW9CLEdBQUc5YTtRQUM5QixJQUFJcWMsYUFBYWQsbUJBQW1CLEVBQUU7WUFDbENjLGFBQWFoQixPQUFPLENBQUNjO1lBQ3JCQyxrREFBa0RoWDtZQUNsRDtRQUNKO1FBQ0EsTUFBTXpELFVBQVV5RCxPQUFPcVYseUJBQXlCLENBQUM1VixXQUFXLENBQUN3WCxhQUFhZixPQUFPO1FBQ2pGdlosWUFBWUosU0FBUztZQUNqQjBhLGFBQWFqQixRQUFRO1lBQ3JCZ0Isa0RBQWtEaFg7WUFDbEQsT0FBTztRQUNYLEdBQUcsQ0FBQzNEO1lBQ0E0YSxhQUFhaEIsT0FBTyxDQUFDNVo7WUFDckIyYSxrREFBa0RoWDtZQUNsRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLFNBQVNrWCxrQ0FBa0NsWCxNQUFNO1FBQzdDQSxPQUFPdVYscUJBQXFCLENBQUNTLFFBQVEsQ0FBQ3BiO1FBQ3RDb0YsT0FBT3VWLHFCQUFxQixHQUFHM2E7SUFDbkM7SUFDQSxTQUFTdWMsMkNBQTJDblgsTUFBTSxFQUFFZ00sS0FBSztRQUM3RGhNLE9BQU91VixxQkFBcUIsQ0FBQ1UsT0FBTyxDQUFDaks7UUFDckNoTSxPQUFPdVYscUJBQXFCLEdBQUczYTtRQUMvQitiLGdDQUFnQzNXLFFBQVFnTTtJQUM1QztJQUNBLFNBQVNvTCxrQ0FBa0NwWCxNQUFNO1FBQzdDQSxPQUFPeVYscUJBQXFCLENBQUNPLFFBQVEsQ0FBQ3BiO1FBQ3RDb0YsT0FBT3lWLHFCQUFxQixHQUFHN2E7UUFDL0IsTUFBTStRLFFBQVEzTCxPQUFPRyxNQUFNO1FBQzNCLElBQUl3TCxVQUFVLFlBQVk7WUFDdEIsMkRBQTJEO1lBQzNEM0wsT0FBT08sWUFBWSxHQUFHM0Y7WUFDdEIsSUFBSW9GLE9BQU8wVixvQkFBb0IsS0FBSzlhLFdBQVc7Z0JBQzNDb0YsT0FBTzBWLG9CQUFvQixDQUFDTSxRQUFRO2dCQUNwQ2hXLE9BQU8wVixvQkFBb0IsR0FBRzlhO1lBQ2xDO1FBQ0o7UUFDQW9GLE9BQU9HLE1BQU0sR0FBRztRQUNoQixNQUFNbVcsU0FBU3RXLE9BQU9vVixPQUFPO1FBQzdCLElBQUlrQixXQUFXMWIsV0FBVztZQUN0QnljLGtDQUFrQ2Y7UUFDdEM7SUFDSjtJQUNBLFNBQVNnQiwyQ0FBMkN0WCxNQUFNLEVBQUVnTSxLQUFLO1FBQzdEaE0sT0FBT3lWLHFCQUFxQixDQUFDUSxPQUFPLENBQUNqSztRQUNyQ2hNLE9BQU95VixxQkFBcUIsR0FBRzdhO1FBQy9CLGlEQUFpRDtRQUNqRCxJQUFJb0YsT0FBTzBWLG9CQUFvQixLQUFLOWEsV0FBVztZQUMzQ29GLE9BQU8wVixvQkFBb0IsQ0FBQ08sT0FBTyxDQUFDaks7WUFDcENoTSxPQUFPMFYsb0JBQW9CLEdBQUc5YTtRQUNsQztRQUNBK2IsZ0NBQWdDM1csUUFBUWdNO0lBQzVDO0lBQ0EsdUNBQXVDO0lBQ3ZDLFNBQVN5SSxvQ0FBb0N6VSxNQUFNO1FBQy9DLElBQUlBLE9BQU93VixhQUFhLEtBQUs1YSxhQUFhb0YsT0FBT3lWLHFCQUFxQixLQUFLN2EsV0FBVztZQUNsRixPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQSxTQUFTa2MseUNBQXlDOVcsTUFBTTtRQUNwRCxJQUFJQSxPQUFPdVYscUJBQXFCLEtBQUszYSxhQUFhb0YsT0FBT3lWLHFCQUFxQixLQUFLN2EsV0FBVztZQUMxRixPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQSxTQUFTMmMsdUNBQXVDdlgsTUFBTTtRQUNsREEsT0FBT3lWLHFCQUFxQixHQUFHelYsT0FBT3dWLGFBQWE7UUFDbkR4VixPQUFPd1YsYUFBYSxHQUFHNWE7SUFDM0I7SUFDQSxTQUFTNGMsNENBQTRDeFgsTUFBTTtRQUN2REEsT0FBT3VWLHFCQUFxQixHQUFHdlYsT0FBT3NWLGNBQWMsQ0FBQ3pXLEtBQUs7SUFDOUQ7SUFDQSxTQUFTbVksa0RBQWtEaFgsTUFBTTtRQUM3RCxJQUFJQSxPQUFPd1YsYUFBYSxLQUFLNWEsV0FBVztZQUNwQ29GLE9BQU93VixhQUFhLENBQUNTLE9BQU8sQ0FBQ2pXLE9BQU9PLFlBQVk7WUFDaERQLE9BQU93VixhQUFhLEdBQUc1YTtRQUMzQjtRQUNBLE1BQU0wYixTQUFTdFcsT0FBT29WLE9BQU87UUFDN0IsSUFBSWtCLFdBQVcxYixXQUFXO1lBQ3RCNmMsaUNBQWlDbkIsUUFBUXRXLE9BQU9PLFlBQVk7UUFDaEU7SUFDSjtJQUNBLFNBQVNtWCxpQ0FBaUMxWCxNQUFNLEVBQUUyWCxZQUFZO1FBQzFELE1BQU1yQixTQUFTdFcsT0FBT29WLE9BQU87UUFDN0IsSUFBSWtCLFdBQVcxYixhQUFhK2MsaUJBQWlCM1gsT0FBTzJWLGFBQWEsRUFBRTtZQUMvRCxJQUFJZ0MsY0FBYztnQkFDZEMsK0JBQStCdEI7WUFDbkMsT0FDSztnQkFDREMsaUNBQWlDRDtZQUNyQztRQUNKO1FBQ0F0VyxPQUFPMlYsYUFBYSxHQUFHZ0M7SUFDM0I7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTTlDO1FBQ0Y1VyxZQUFZK0IsTUFBTSxDQUFFO1lBQ2hCbUMsdUJBQXVCbkMsUUFBUSxHQUFHO1lBQ2xDdVQscUJBQXFCdlQsUUFBUTtZQUM3QixJQUFJdVUsdUJBQXVCdlUsU0FBUztnQkFDaEMsTUFBTSxJQUFJckMsVUFBVTtZQUN4QjtZQUNBLElBQUksQ0FBQ2thLG9CQUFvQixHQUFHN1g7WUFDNUJBLE9BQU9vVixPQUFPLEdBQUcsSUFBSTtZQUNyQixNQUFNekosUUFBUTNMLE9BQU9HLE1BQU07WUFDM0IsSUFBSXdMLFVBQVUsWUFBWTtnQkFDdEIsSUFBSSxDQUFDOEksb0NBQW9DelUsV0FBV0EsT0FBTzJWLGFBQWEsRUFBRTtvQkFDdEVtQyxvQ0FBb0MsSUFBSTtnQkFDNUMsT0FDSztvQkFDREMsOENBQThDLElBQUk7Z0JBQ3REO2dCQUNBQyxxQ0FBcUMsSUFBSTtZQUM3QyxPQUNLLElBQUlyTSxVQUFVLFlBQVk7Z0JBQzNCc00sOENBQThDLElBQUksRUFBRWpZLE9BQU9PLFlBQVk7Z0JBQ3ZFeVgscUNBQXFDLElBQUk7WUFDN0MsT0FDSyxJQUFJck0sVUFBVSxVQUFVO2dCQUN6Qm9NLDhDQUE4QyxJQUFJO2dCQUNsREcsK0NBQStDLElBQUk7WUFDdkQsT0FDSztnQkFDRCxNQUFNbkIsY0FBYy9XLE9BQU9PLFlBQVk7Z0JBQ3ZDMFgsOENBQThDLElBQUksRUFBRWxCO2dCQUNwRG9CLCtDQUErQyxJQUFJLEVBQUVwQjtZQUN6RDtRQUNKO1FBQ0E7OztTQUdDLEdBQ0QsSUFBSWpULFNBQVM7WUFDVCxJQUFJLENBQUNzVSw4QkFBOEIsSUFBSSxHQUFHO2dCQUN0QyxPQUFPaGMsb0JBQW9CaWMsaUNBQWlDO1lBQ2hFO1lBQ0EsT0FBTyxJQUFJLENBQUN0WCxjQUFjO1FBQzlCO1FBQ0E7Ozs7Ozs7U0FPQyxHQUNELElBQUl3SyxjQUFjO1lBQ2QsSUFBSSxDQUFDNk0sOEJBQThCLElBQUksR0FBRztnQkFDdEMsTUFBTUMsaUNBQWlDO1lBQzNDO1lBQ0EsSUFBSSxJQUFJLENBQUNSLG9CQUFvQixLQUFLamQsV0FBVztnQkFDekMsTUFBTTBkLDJCQUEyQjtZQUNyQztZQUNBLE9BQU9DLDBDQUEwQyxJQUFJO1FBQ3pEO1FBQ0E7Ozs7Ozs7U0FPQyxHQUNELElBQUk1SixRQUFRO1lBQ1IsSUFBSSxDQUFDeUosOEJBQThCLElBQUksR0FBRztnQkFDdEMsT0FBT2hjLG9CQUFvQmljLGlDQUFpQztZQUNoRTtZQUNBLE9BQU8sSUFBSSxDQUFDRyxhQUFhO1FBQzdCO1FBQ0E7O1NBRUMsR0FDRHhGLE1BQU0zVyxTQUFTekIsU0FBUyxFQUFFO1lBQ3RCLElBQUksQ0FBQ3dkLDhCQUE4QixJQUFJLEdBQUc7Z0JBQ3RDLE9BQU9oYyxvQkFBb0JpYyxpQ0FBaUM7WUFDaEU7WUFDQSxJQUFJLElBQUksQ0FBQ1Isb0JBQW9CLEtBQUtqZCxXQUFXO2dCQUN6QyxPQUFPd0Isb0JBQW9Ca2MsMkJBQTJCO1lBQzFEO1lBQ0EsT0FBT0csaUNBQWlDLElBQUksRUFBRXBjO1FBQ2xEO1FBQ0E7O1NBRUMsR0FDRG9QLFFBQVE7WUFDSixJQUFJLENBQUMyTSw4QkFBOEIsSUFBSSxHQUFHO2dCQUN0QyxPQUFPaGMsb0JBQW9CaWMsaUNBQWlDO1lBQ2hFO1lBQ0EsTUFBTXJZLFNBQVMsSUFBSSxDQUFDNlgsb0JBQW9CO1lBQ3hDLElBQUk3WCxXQUFXcEYsV0FBVztnQkFDdEIsT0FBT3dCLG9CQUFvQmtjLDJCQUEyQjtZQUMxRDtZQUNBLElBQUk3RCxvQ0FBb0N6VSxTQUFTO2dCQUM3QyxPQUFPNUQsb0JBQW9CLElBQUl1QixVQUFVO1lBQzdDO1lBQ0EsT0FBTythLGlDQUFpQyxJQUFJO1FBQ2hEO1FBQ0E7Ozs7Ozs7OztTQVNDLEdBQ0RuVSxjQUFjO1lBQ1YsSUFBSSxDQUFDNlQsOEJBQThCLElBQUksR0FBRztnQkFDdEMsTUFBTUMsaUNBQWlDO1lBQzNDO1lBQ0EsTUFBTXJZLFNBQVMsSUFBSSxDQUFDNlgsb0JBQW9CO1lBQ3hDLElBQUk3WCxXQUFXcEYsV0FBVztnQkFDdEI7WUFDSjtZQUNBK2QsbUNBQW1DLElBQUk7UUFDM0M7UUFDQXpGLE1BQU01UCxRQUFRMUksU0FBUyxFQUFFO1lBQ3JCLElBQUksQ0FBQ3dkLDhCQUE4QixJQUFJLEdBQUc7Z0JBQ3RDLE9BQU9oYyxvQkFBb0JpYyxpQ0FBaUM7WUFDaEU7WUFDQSxJQUFJLElBQUksQ0FBQ1Isb0JBQW9CLEtBQUtqZCxXQUFXO2dCQUN6QyxPQUFPd0Isb0JBQW9Ca2MsMkJBQTJCO1lBQzFEO1lBQ0EsT0FBT00saUNBQWlDLElBQUksRUFBRXRWO1FBQ2xEO0lBQ0o7SUFDQW5JLE9BQU9zSixnQkFBZ0IsQ0FBQ29RLDRCQUE0QmxaLFNBQVMsRUFBRTtRQUMzRHFYLE9BQU87WUFBRXRPLFlBQVk7UUFBSztRQUMxQitHLE9BQU87WUFBRS9HLFlBQVk7UUFBSztRQUMxQkgsYUFBYTtZQUFFRyxZQUFZO1FBQUs7UUFDaEN3TyxPQUFPO1lBQUV4TyxZQUFZO1FBQUs7UUFDMUJaLFFBQVE7WUFBRVksWUFBWTtRQUFLO1FBQzNCNkcsYUFBYTtZQUFFN0csWUFBWTtRQUFLO1FBQ2hDaUssT0FBTztZQUFFakssWUFBWTtRQUFLO0lBQzlCO0lBQ0ExSixnQkFBZ0I2Wiw0QkFBNEJsWixTQUFTLENBQUNxWCxLQUFLLEVBQUU7SUFDN0RoWSxnQkFBZ0I2Wiw0QkFBNEJsWixTQUFTLENBQUM4UCxLQUFLLEVBQUU7SUFDN0R6USxnQkFBZ0I2Wiw0QkFBNEJsWixTQUFTLENBQUM0SSxXQUFXLEVBQUU7SUFDbkV2SixnQkFBZ0I2Wiw0QkFBNEJsWixTQUFTLENBQUN1WCxLQUFLLEVBQUU7SUFDN0QsSUFBSSxPQUFPM1ksZUFBZW9LLFdBQVcsS0FBSyxVQUFVO1FBQ2hEeEosT0FBT0MsY0FBYyxDQUFDeVosNEJBQTRCbFosU0FBUyxFQUFFcEIsZUFBZW9LLFdBQVcsRUFBRTtZQUNyRnRKLE9BQU87WUFDUEMsY0FBYztRQUNsQjtJQUNKO0lBQ0EsMkRBQTJEO0lBQzNELFNBQVM4Yyw4QkFBOEJ0ZCxDQUFDO1FBQ3BDLElBQUksQ0FBQ0QsYUFBYUMsSUFBSTtZQUNsQixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUNLLE9BQU9RLFNBQVMsQ0FBQ2lKLGNBQWMsQ0FBQ2xJLElBQUksQ0FBQzVCLEdBQUcseUJBQXlCO1lBQ2xFLE9BQU87UUFDWDtRQUNBLE9BQU9BLGFBQWErWjtJQUN4QjtJQUNBLGtHQUFrRztJQUNsRyxTQUFTNEQsaUNBQWlDbkMsTUFBTSxFQUFFamEsTUFBTTtRQUNwRCxNQUFNMkQsU0FBU3NXLE9BQU91QixvQkFBb0I7UUFDMUMsT0FBT3JELG9CQUFvQnhVLFFBQVEzRDtJQUN2QztJQUNBLFNBQVNxYyxpQ0FBaUNwQyxNQUFNO1FBQzVDLE1BQU10VyxTQUFTc1csT0FBT3VCLG9CQUFvQjtRQUMxQyxPQUFPbkQsb0JBQW9CMVU7SUFDL0I7SUFDQSxTQUFTNlkscURBQXFEdkMsTUFBTTtRQUNoRSxNQUFNdFcsU0FBU3NXLE9BQU91QixvQkFBb0I7UUFDMUMsTUFBTWxNLFFBQVEzTCxPQUFPRyxNQUFNO1FBQzNCLElBQUlzVSxvQ0FBb0N6VSxXQUFXMkwsVUFBVSxVQUFVO1lBQ25FLE9BQU96UCxvQkFBb0J0QjtRQUMvQjtRQUNBLElBQUkrUSxVQUFVLFdBQVc7WUFDckIsT0FBT3ZQLG9CQUFvQjRELE9BQU9PLFlBQVk7UUFDbEQ7UUFDQSxPQUFPbVksaUNBQWlDcEM7SUFDNUM7SUFDQSxTQUFTd0MsdURBQXVEeEMsTUFBTSxFQUFFdEssS0FBSztRQUN6RSxJQUFJc0ssT0FBT3lDLG1CQUFtQixLQUFLLFdBQVc7WUFDMUN0QixpQ0FBaUNuQixRQUFRdEs7UUFDN0MsT0FDSztZQUNEZ04sMENBQTBDMUMsUUFBUXRLO1FBQ3REO0lBQ0o7SUFDQSxTQUFTNkssc0RBQXNEUCxNQUFNLEVBQUV0SyxLQUFLO1FBQ3hFLElBQUlzSyxPQUFPMkMsa0JBQWtCLEtBQUssV0FBVztZQUN6Q0MsZ0NBQWdDNUMsUUFBUXRLO1FBQzVDLE9BQ0s7WUFDRG1OLHlDQUF5QzdDLFFBQVF0SztRQUNyRDtJQUNKO0lBQ0EsU0FBU3VNLDBDQUEwQ2pDLE1BQU07UUFDckQsTUFBTXRXLFNBQVNzVyxPQUFPdUIsb0JBQW9CO1FBQzFDLE1BQU1sTSxRQUFRM0wsT0FBT0csTUFBTTtRQUMzQixJQUFJd0wsVUFBVSxhQUFhQSxVQUFVLFlBQVk7WUFDN0MsT0FBTztRQUNYO1FBQ0EsSUFBSUEsVUFBVSxVQUFVO1lBQ3BCLE9BQU87UUFDWDtRQUNBLE9BQU95Tiw4Q0FBOENwWixPQUFPcVYseUJBQXlCO0lBQ3pGO0lBQ0EsU0FBU3NELG1DQUFtQ3JDLE1BQU07UUFDOUMsTUFBTXRXLFNBQVNzVyxPQUFPdUIsb0JBQW9CO1FBQzFDLE1BQU13QixnQkFBZ0IsSUFBSTFiLFVBQVUsQ0FBQyxnRkFBZ0YsQ0FBQztRQUN0SGtaLHNEQUFzRFAsUUFBUStDO1FBQzlELCtHQUErRztRQUMvRyxpRkFBaUY7UUFDakZQLHVEQUF1RHhDLFFBQVErQztRQUMvRHJaLE9BQU9vVixPQUFPLEdBQUd4YTtRQUNqQjBiLE9BQU91QixvQkFBb0IsR0FBR2pkO0lBQ2xDO0lBQ0EsU0FBU2dlLGlDQUFpQ3RDLE1BQU0sRUFBRWhULEtBQUs7UUFDbkQsTUFBTXRELFNBQVNzVyxPQUFPdUIsb0JBQW9CO1FBQzFDLE1BQU0xSyxhQUFhbk4sT0FBT3FWLHlCQUF5QjtRQUNuRCxNQUFNaUUsWUFBWUMsNENBQTRDcE0sWUFBWTdKO1FBQzFFLElBQUl0RCxXQUFXc1csT0FBT3VCLG9CQUFvQixFQUFFO1lBQ3hDLE9BQU96YixvQkFBb0JrYywyQkFBMkI7UUFDMUQ7UUFDQSxNQUFNM00sUUFBUTNMLE9BQU9HLE1BQU07UUFDM0IsSUFBSXdMLFVBQVUsV0FBVztZQUNyQixPQUFPdlAsb0JBQW9CNEQsT0FBT08sWUFBWTtRQUNsRDtRQUNBLElBQUlrVSxvQ0FBb0N6VSxXQUFXMkwsVUFBVSxVQUFVO1lBQ25FLE9BQU92UCxvQkFBb0IsSUFBSXVCLFVBQVU7UUFDN0M7UUFDQSxJQUFJZ08sVUFBVSxZQUFZO1lBQ3RCLE9BQU92UCxvQkFBb0I0RCxPQUFPTyxZQUFZO1FBQ2xEO1FBQ0EsTUFBTWhFLFVBQVVrYSw4QkFBOEJ6VztRQUM5Q3daLHFDQUFxQ3JNLFlBQVk3SixPQUFPZ1c7UUFDeEQsT0FBTy9jO0lBQ1g7SUFDQSxNQUFNa2QsZ0JBQWdCLENBQUM7SUFDdkI7Ozs7S0FJQyxHQUNELE1BQU12RTtRQUNGalgsYUFBYztZQUNWLE1BQU0sSUFBSU4sVUFBVTtRQUN4QjtRQUNBOzs7Ozs7U0FNQyxHQUNELElBQUkrYixjQUFjO1lBQ2QsSUFBSSxDQUFDQyxrQ0FBa0MsSUFBSSxHQUFHO2dCQUMxQyxNQUFNQyx1Q0FBdUM7WUFDakQ7WUFDQSxPQUFPLElBQUksQ0FBQ2hFLFlBQVk7UUFDNUI7UUFDQTs7U0FFQyxHQUNELElBQUlpRSxTQUFTO1lBQ1QsSUFBSSxDQUFDRixrQ0FBa0MsSUFBSSxHQUFHO2dCQUMxQyxNQUFNQyx1Q0FBdUM7WUFDakQ7WUFDQSxJQUFJLElBQUksQ0FBQy9ELGdCQUFnQixLQUFLamIsV0FBVztnQkFDckMsNEZBQTRGO2dCQUM1Riw2RkFBNkY7Z0JBQzdGLHVHQUF1RztnQkFDdkcsTUFBTSxJQUFJK0MsVUFBVTtZQUN4QjtZQUNBLE9BQU8sSUFBSSxDQUFDa1ksZ0JBQWdCLENBQUNnRSxNQUFNO1FBQ3ZDO1FBQ0E7Ozs7OztTQU1DLEdBQ0Q3TixNQUFNM0gsSUFBSXpKLFNBQVMsRUFBRTtZQUNqQixJQUFJLENBQUMrZSxrQ0FBa0MsSUFBSSxHQUFHO2dCQUMxQyxNQUFNQyx1Q0FBdUM7WUFDakQ7WUFDQSxNQUFNak8sUUFBUSxJQUFJLENBQUNtTyx5QkFBeUIsQ0FBQzNaLE1BQU07WUFDbkQsSUFBSXdMLFVBQVUsWUFBWTtnQkFDdEIsZ0hBQWdIO2dCQUNoSCw0QkFBNEI7Z0JBQzVCO1lBQ0o7WUFDQW9PLHFDQUFxQyxJQUFJLEVBQUUxVjtRQUMvQztRQUNBLGNBQWMsR0FDZCxDQUFDNUUsV0FBVyxDQUFDcEQsTUFBTSxFQUFFO1lBQ2pCLE1BQU13SixTQUFTLElBQUksQ0FBQ21VLGVBQWUsQ0FBQzNkO1lBQ3BDNGQsK0NBQStDLElBQUk7WUFDbkQsT0FBT3BVO1FBQ1g7UUFDQSxjQUFjLEdBQ2QsQ0FBQ25HLFdBQVcsR0FBRztZQUNYcUssV0FBVyxJQUFJO1FBQ25CO0lBQ0o7SUFDQTVPLE9BQU9zSixnQkFBZ0IsQ0FBQ3lRLGdDQUFnQ3ZaLFNBQVMsRUFBRTtRQUMvRCtkLGFBQWE7WUFBRWhWLFlBQVk7UUFBSztRQUNoQ21WLFFBQVE7WUFBRW5WLFlBQVk7UUFBSztRQUMzQnNILE9BQU87WUFBRXRILFlBQVk7UUFBSztJQUM5QjtJQUNBLElBQUksT0FBT25LLGVBQWVvSyxXQUFXLEtBQUssVUFBVTtRQUNoRHhKLE9BQU9DLGNBQWMsQ0FBQzhaLGdDQUFnQ3ZaLFNBQVMsRUFBRXBCLGVBQWVvSyxXQUFXLEVBQUU7WUFDekZ0SixPQUFPO1lBQ1BDLGNBQWM7UUFDbEI7SUFDSjtJQUNBLDZFQUE2RTtJQUM3RSxTQUFTcWUsa0NBQWtDN2UsQ0FBQztRQUN4QyxJQUFJLENBQUNELGFBQWFDLElBQUk7WUFDbEIsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDSyxPQUFPUSxTQUFTLENBQUNpSixjQUFjLENBQUNsSSxJQUFJLENBQUM1QixHQUFHLDhCQUE4QjtZQUN2RSxPQUFPO1FBQ1g7UUFDQSxPQUFPQSxhQUFhb2E7SUFDeEI7SUFDQSxTQUFTQyxxQ0FBcUNuVixNQUFNLEVBQUVtTixVQUFVLEVBQUUwRCxjQUFjLEVBQUVrRSxjQUFjLEVBQUVDLGNBQWMsRUFBRUMsY0FBYyxFQUFFakUsYUFBYSxFQUFFbUQsYUFBYTtRQUMxSmhILFdBQVcyTSx5QkFBeUIsR0FBRzlaO1FBQ3ZDQSxPQUFPcVYseUJBQXlCLEdBQUdsSTtRQUNuQyx5R0FBeUc7UUFDekdBLFdBQVczRCxNQUFNLEdBQUc1TztRQUNwQnVTLFdBQVcxRCxlQUFlLEdBQUc3TztRQUM3Qm1QLFdBQVdvRDtRQUNYQSxXQUFXeUksWUFBWSxHQUFHaGI7UUFDMUJ1UyxXQUFXMEksZ0JBQWdCLEdBQUdoQztRQUM5QjFHLFdBQVdnRCxRQUFRLEdBQUc7UUFDdEJoRCxXQUFXK00sc0JBQXNCLEdBQUcvRjtRQUNwQ2hILFdBQVd1RCxZQUFZLEdBQUdNO1FBQzFCN0QsV0FBV2dOLGVBQWUsR0FBR3BGO1FBQzdCNUgsV0FBV2lOLGVBQWUsR0FBR3BGO1FBQzdCN0gsV0FBVzZNLGVBQWUsR0FBRy9FO1FBQzdCLE1BQU0wQyxlQUFlMEMsK0NBQStDbE47UUFDcEV1SyxpQ0FBaUMxWCxRQUFRMlg7UUFDekMsTUFBTTFHLGNBQWNKO1FBQ3BCLE1BQU15SixlQUFlcGUsb0JBQW9CK1U7UUFDekN0VSxZQUFZMmQsY0FBYztZQUN0Qm5OLFdBQVdnRCxRQUFRLEdBQUc7WUFDdEJvSyxvREFBb0RwTjtZQUNwRCxPQUFPO1FBQ1gsR0FBRytELENBQUFBO1lBQ0MvRCxXQUFXZ0QsUUFBUSxHQUFHO1lBQ3RCd0csZ0NBQWdDM1csUUFBUWtSO1lBQ3hDLE9BQU87UUFDWDtJQUNKO0lBQ0EsU0FBU2tELHVEQUF1RHBVLE1BQU0sRUFBRWlVLGNBQWMsRUFBRWpELGFBQWEsRUFBRW1ELGFBQWE7UUFDaEgsTUFBTWhILGFBQWFoUyxPQUFPa0wsTUFBTSxDQUFDNk8sZ0NBQWdDdlosU0FBUztRQUMxRSxJQUFJa1Y7UUFDSixJQUFJa0U7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSWhCLGVBQWU1QyxLQUFLLEtBQUt6VyxXQUFXO1lBQ3BDaVcsaUJBQWlCLElBQU1vRCxlQUFlNUMsS0FBSyxDQUFDbEU7UUFDaEQsT0FDSztZQUNEMEQsaUJBQWlCLElBQU1qVztRQUMzQjtRQUNBLElBQUlxWixlQUFlZixLQUFLLEtBQUt0WSxXQUFXO1lBQ3BDbWEsaUJBQWlCelIsQ0FBQUEsUUFBUzJRLGVBQWVmLEtBQUssQ0FBQzVQLE9BQU82SjtRQUMxRCxPQUNLO1lBQ0Q0SCxpQkFBaUIsSUFBTTdZLG9CQUFvQnRCO1FBQy9DO1FBQ0EsSUFBSXFaLGVBQWV4SSxLQUFLLEtBQUs3USxXQUFXO1lBQ3BDb2EsaUJBQWlCLElBQU1mLGVBQWV4SSxLQUFLO1FBQy9DLE9BQ0s7WUFDRHVKLGlCQUFpQixJQUFNOVksb0JBQW9CdEI7UUFDL0M7UUFDQSxJQUFJcVosZUFBZWpCLEtBQUssS0FBS3BZLFdBQVc7WUFDcENxYSxpQkFBaUI1WSxDQUFBQSxTQUFVNFgsZUFBZWpCLEtBQUssQ0FBQzNXO1FBQ3BELE9BQ0s7WUFDRDRZLGlCQUFpQixJQUFNL1ksb0JBQW9CdEI7UUFDL0M7UUFDQXVhLHFDQUFxQ25WLFFBQVFtTixZQUFZMEQsZ0JBQWdCa0UsZ0JBQWdCQyxnQkFBZ0JDLGdCQUFnQmpFLGVBQWVtRDtJQUM1STtJQUNBLHVIQUF1SDtJQUN2SCxTQUFTOEYsK0NBQStDOU0sVUFBVTtRQUM5REEsV0FBV2dOLGVBQWUsR0FBR3ZmO1FBQzdCdVMsV0FBV2lOLGVBQWUsR0FBR3hmO1FBQzdCdVMsV0FBVzZNLGVBQWUsR0FBR3BmO1FBQzdCdVMsV0FBVytNLHNCQUFzQixHQUFHdGY7SUFDeEM7SUFDQSxTQUFTNGIscUNBQXFDckosVUFBVTtRQUNwRHhELHFCQUFxQndELFlBQVlzTSxlQUFlO1FBQ2hEYyxvREFBb0RwTjtJQUN4RDtJQUNBLFNBQVNvTSw0Q0FBNENwTSxVQUFVLEVBQUU3SixLQUFLO1FBQ2xFLElBQUk7WUFDQSxPQUFPNkosV0FBVytNLHNCQUFzQixDQUFDNVc7UUFDN0MsRUFDQSxPQUFPa1gsWUFBWTtZQUNmQyw2Q0FBNkN0TixZQUFZcU47WUFDekQsT0FBTztRQUNYO0lBQ0o7SUFDQSxTQUFTcEIsOENBQThDak0sVUFBVTtRQUM3RCxPQUFPQSxXQUFXdUQsWUFBWSxHQUFHdkQsV0FBVzFELGVBQWU7SUFDL0Q7SUFDQSxTQUFTK1AscUNBQXFDck0sVUFBVSxFQUFFN0osS0FBSyxFQUFFZ1csU0FBUztRQUN0RSxJQUFJO1lBQ0EzUCxxQkFBcUJ3RCxZQUFZN0osT0FBT2dXO1FBQzVDLEVBQ0EsT0FBT29CLFVBQVU7WUFDYkQsNkNBQTZDdE4sWUFBWXVOO1lBQ3pEO1FBQ0o7UUFDQSxNQUFNMWEsU0FBU21OLFdBQVcyTSx5QkFBeUI7UUFDbkQsSUFBSSxDQUFDckYsb0NBQW9DelUsV0FBV0EsT0FBT0csTUFBTSxLQUFLLFlBQVk7WUFDOUUsTUFBTXdYLGVBQWUwQywrQ0FBK0NsTjtZQUNwRXVLLGlDQUFpQzFYLFFBQVEyWDtRQUM3QztRQUNBNEMsb0RBQW9EcE47SUFDeEQ7SUFDQSwrREFBK0Q7SUFDL0QsU0FBU29OLG9EQUFvRHBOLFVBQVU7UUFDbkUsTUFBTW5OLFNBQVNtTixXQUFXMk0seUJBQXlCO1FBQ25ELElBQUksQ0FBQzNNLFdBQVdnRCxRQUFRLEVBQUU7WUFDdEI7UUFDSjtRQUNBLElBQUluUSxPQUFPdVYscUJBQXFCLEtBQUszYSxXQUFXO1lBQzVDO1FBQ0o7UUFDQSxNQUFNK1EsUUFBUTNMLE9BQU9HLE1BQU07UUFDM0IsSUFBSXdMLFVBQVUsWUFBWTtZQUN0QmlMLDZCQUE2QjVXO1lBQzdCO1FBQ0o7UUFDQSxJQUFJbU4sV0FBVzNELE1BQU0sQ0FBQ2hMLE1BQU0sS0FBSyxHQUFHO1lBQ2hDO1FBQ0o7UUFDQSxNQUFNbkQsUUFBUXlPLGVBQWVxRDtRQUM3QixJQUFJOVIsVUFBVW9lLGVBQWU7WUFDekJrQiw0Q0FBNEN4TjtRQUNoRCxPQUNLO1lBQ0R5Tiw0Q0FBNEN6TixZQUFZOVI7UUFDNUQ7SUFDSjtJQUNBLFNBQVNvZiw2Q0FBNkN0TixVQUFVLEVBQUVuQixLQUFLO1FBQ25FLElBQUltQixXQUFXMk0seUJBQXlCLENBQUMzWixNQUFNLEtBQUssWUFBWTtZQUM1RDRaLHFDQUFxQzVNLFlBQVluQjtRQUNyRDtJQUNKO0lBQ0EsU0FBUzJPLDRDQUE0Q3hOLFVBQVU7UUFDM0QsTUFBTW5OLFNBQVNtTixXQUFXMk0seUJBQXlCO1FBQ25EdkMsdUNBQXVDdlg7UUFDdkNxSixhQUFhOEQ7UUFDYixNQUFNME4sbUJBQW1CMU4sV0FBV2lOLGVBQWU7UUFDbkRILCtDQUErQzlNO1FBQy9DeFEsWUFBWWtlLGtCQUFrQjtZQUMxQnpELGtDQUFrQ3BYO1lBQ2xDLE9BQU87UUFDWCxHQUFHM0QsQ0FBQUE7WUFDQ2liLDJDQUEyQ3RYLFFBQVEzRDtZQUNuRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLFNBQVN1ZSw0Q0FBNEN6TixVQUFVLEVBQUU3SixLQUFLO1FBQ2xFLE1BQU10RCxTQUFTbU4sV0FBVzJNLHlCQUF5QjtRQUNuRHRDLDRDQUE0Q3hYO1FBQzVDLE1BQU04YSxtQkFBbUIzTixXQUFXZ04sZUFBZSxDQUFDN1c7UUFDcEQzRyxZQUFZbWUsa0JBQWtCO1lBQzFCNUQsa0NBQWtDbFg7WUFDbEMsTUFBTTJMLFFBQVEzTCxPQUFPRyxNQUFNO1lBQzNCa0osYUFBYThEO1lBQ2IsSUFBSSxDQUFDc0gsb0NBQW9DelUsV0FBVzJMLFVBQVUsWUFBWTtnQkFDdEUsTUFBTWdNLGVBQWUwQywrQ0FBK0NsTjtnQkFDcEV1SyxpQ0FBaUMxWCxRQUFRMlg7WUFDN0M7WUFDQTRDLG9EQUFvRHBOO1lBQ3BELE9BQU87UUFDWCxHQUFHOVEsQ0FBQUE7WUFDQyxJQUFJMkQsT0FBT0csTUFBTSxLQUFLLFlBQVk7Z0JBQzlCOFosK0NBQStDOU07WUFDbkQ7WUFDQWdLLDJDQUEyQ25YLFFBQVEzRDtZQUNuRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLFNBQVNnZSwrQ0FBK0NsTixVQUFVO1FBQzlELE1BQU01QixjQUFjNk4sOENBQThDak07UUFDbEUsT0FBTzVCLGVBQWU7SUFDMUI7SUFDQSxzR0FBc0c7SUFDdEcsU0FBU3dPLHFDQUFxQzVNLFVBQVUsRUFBRW5CLEtBQUs7UUFDM0QsTUFBTWhNLFNBQVNtTixXQUFXMk0seUJBQXlCO1FBQ25ERywrQ0FBK0M5TTtRQUMvQ2lKLDRCQUE0QnBXLFFBQVFnTTtJQUN4QztJQUNBLDJDQUEyQztJQUMzQyxTQUFTc0ksNEJBQTRCcFosSUFBSTtRQUNyQyxPQUFPLElBQUl5QyxVQUFVLENBQUMseUJBQXlCLEVBQUV6QyxLQUFLLHFDQUFxQyxDQUFDO0lBQ2hHO0lBQ0EsNERBQTREO0lBQzVELFNBQVMwZSx1Q0FBdUMxZSxJQUFJO1FBQ2hELE9BQU8sSUFBSXlDLFVBQVUsQ0FBQywwQ0FBMEMsRUFBRXpDLEtBQUssc0RBQXNELENBQUM7SUFDbEk7SUFDQSx3REFBd0Q7SUFDeEQsU0FBU21kLGlDQUFpQ25kLElBQUk7UUFDMUMsT0FBTyxJQUFJeUMsVUFBVSxDQUFDLHNDQUFzQyxFQUFFekMsS0FBSyxrREFBa0QsQ0FBQztJQUMxSDtJQUNBLFNBQVNvZCwyQkFBMkJwZCxJQUFJO1FBQ3BDLE9BQU8sSUFBSXlDLFVBQVUsWUFBWXpDLE9BQU87SUFDNUM7SUFDQSxTQUFTOGMscUNBQXFDMUIsTUFBTTtRQUNoREEsT0FBT3ZWLGNBQWMsR0FBRy9FLFdBQVcsQ0FBQ0csU0FBU0w7WUFDekN3YSxPQUFPdFYsc0JBQXNCLEdBQUc3RTtZQUNoQ21hLE9BQU9yVixxQkFBcUIsR0FBR25GO1lBQy9Cd2EsT0FBT3lDLG1CQUFtQixHQUFHO1FBQ2pDO0lBQ0o7SUFDQSxTQUFTWiwrQ0FBK0M3QixNQUFNLEVBQUVqYSxNQUFNO1FBQ2xFMmIscUNBQXFDMUI7UUFDckNtQixpQ0FBaUNuQixRQUFRamE7SUFDN0M7SUFDQSxTQUFTNmIsK0NBQStDNUIsTUFBTTtRQUMxRDBCLHFDQUFxQzFCO1FBQ3JDZSxrQ0FBa0NmO0lBQ3RDO0lBQ0EsU0FBU21CLGlDQUFpQ25CLE1BQU0sRUFBRWphLE1BQU07UUFDcEQsSUFBSWlhLE9BQU9yVixxQkFBcUIsS0FBS3JHLFdBQVc7WUFDNUM7UUFDSjtRQUNBcUMsMEJBQTBCcVosT0FBT3ZWLGNBQWM7UUFDL0N1VixPQUFPclYscUJBQXFCLENBQUM1RTtRQUM3QmlhLE9BQU90VixzQkFBc0IsR0FBR3BHO1FBQ2hDMGIsT0FBT3JWLHFCQUFxQixHQUFHckc7UUFDL0IwYixPQUFPeUMsbUJBQW1CLEdBQUc7SUFDakM7SUFDQSxTQUFTQywwQ0FBMEMxQyxNQUFNLEVBQUVqYSxNQUFNO1FBQzdEOGIsK0NBQStDN0IsUUFBUWphO0lBQzNEO0lBQ0EsU0FBU2diLGtDQUFrQ2YsTUFBTTtRQUM3QyxJQUFJQSxPQUFPdFYsc0JBQXNCLEtBQUtwRyxXQUFXO1lBQzdDO1FBQ0o7UUFDQTBiLE9BQU90VixzQkFBc0IsQ0FBQ3BHO1FBQzlCMGIsT0FBT3RWLHNCQUFzQixHQUFHcEc7UUFDaEMwYixPQUFPclYscUJBQXFCLEdBQUdyRztRQUMvQjBiLE9BQU95QyxtQkFBbUIsR0FBRztJQUNqQztJQUNBLFNBQVNqQixvQ0FBb0N4QixNQUFNO1FBQy9DQSxPQUFPa0MsYUFBYSxHQUFHeGMsV0FBVyxDQUFDRyxTQUFTTDtZQUN4Q3dhLE9BQU95RSxxQkFBcUIsR0FBRzVlO1lBQy9CbWEsT0FBTzBFLG9CQUFvQixHQUFHbGY7UUFDbEM7UUFDQXdhLE9BQU8yQyxrQkFBa0IsR0FBRztJQUNoQztJQUNBLFNBQVNoQiw4Q0FBOEMzQixNQUFNLEVBQUVqYSxNQUFNO1FBQ2pFeWIsb0NBQW9DeEI7UUFDcEM0QyxnQ0FBZ0M1QyxRQUFRamE7SUFDNUM7SUFDQSxTQUFTMGIsOENBQThDekIsTUFBTTtRQUN6RHdCLG9DQUFvQ3hCO1FBQ3BDQyxpQ0FBaUNEO0lBQ3JDO0lBQ0EsU0FBUzRDLGdDQUFnQzVDLE1BQU0sRUFBRWphLE1BQU07UUFDbkQsSUFBSWlhLE9BQU8wRSxvQkFBb0IsS0FBS3BnQixXQUFXO1lBQzNDO1FBQ0o7UUFDQXFDLDBCQUEwQnFaLE9BQU9rQyxhQUFhO1FBQzlDbEMsT0FBTzBFLG9CQUFvQixDQUFDM2U7UUFDNUJpYSxPQUFPeUUscUJBQXFCLEdBQUduZ0I7UUFDL0IwYixPQUFPMEUsb0JBQW9CLEdBQUdwZ0I7UUFDOUIwYixPQUFPMkMsa0JBQWtCLEdBQUc7SUFDaEM7SUFDQSxTQUFTckIsK0JBQStCdEIsTUFBTTtRQUMxQ3dCLG9DQUFvQ3hCO0lBQ3hDO0lBQ0EsU0FBUzZDLHlDQUF5QzdDLE1BQU0sRUFBRWphLE1BQU07UUFDNUQ0Yiw4Q0FBOEMzQixRQUFRamE7SUFDMUQ7SUFDQSxTQUFTa2EsaUNBQWlDRCxNQUFNO1FBQzVDLElBQUlBLE9BQU95RSxxQkFBcUIsS0FBS25nQixXQUFXO1lBQzVDO1FBQ0o7UUFDQTBiLE9BQU95RSxxQkFBcUIsQ0FBQ25nQjtRQUM3QjBiLE9BQU95RSxxQkFBcUIsR0FBR25nQjtRQUMvQjBiLE9BQU8wRSxvQkFBb0IsR0FBR3BnQjtRQUM5QjBiLE9BQU8yQyxrQkFBa0IsR0FBRztJQUNoQztJQUVBLDJCQUEyQjtJQUMzQixTQUFTZ0M7UUFDTCxJQUFJLE9BQU83Z0IsZUFBZSxhQUFhO1lBQ25DLE9BQU9BO1FBQ1gsT0FDSyxJQUFJLE9BQU9DLFNBQVMsYUFBYTtZQUNsQyxPQUFPQTtRQUNYLE9BQ0ssSUFBSSxPQUFPUCxXQUFXLGFBQWE7WUFDcEMsT0FBT0E7UUFDWDtRQUNBLE9BQU9jO0lBQ1g7SUFDQSxNQUFNc2dCLFVBQVVEO0lBRWhCLDhCQUE4QjtJQUM5QixTQUFTRSwwQkFBMEJsUixJQUFJO1FBQ25DLElBQUksQ0FBRSxRQUFPQSxTQUFTLGNBQWMsT0FBT0EsU0FBUyxRQUFPLEdBQUk7WUFDM0QsT0FBTztRQUNYO1FBQ0EsSUFBSUEsS0FBSy9PLElBQUksS0FBSyxnQkFBZ0I7WUFDOUIsT0FBTztRQUNYO1FBQ0EsSUFBSTtZQUNBLElBQUkrTztZQUNKLE9BQU87UUFDWCxFQUNBLE9BQU8xTyxJQUFJO1lBQ1AsT0FBTztRQUNYO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0QsU0FBUzZmO1FBQ0wsTUFBTW5SLE9BQU9pUixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUUcsWUFBWTtRQUNuRixPQUFPRiwwQkFBMEJsUixRQUFRQSxPQUFPclA7SUFDcEQ7SUFDQTs7O0tBR0MsR0FDRCxTQUFTMGdCO1FBQ0wsd0RBQXdEO1FBQ3hELE1BQU1yUixPQUFPLFNBQVNvUixhQUFhRSxPQUFPLEVBQUVyZ0IsSUFBSTtZQUM1QyxJQUFJLENBQUNxZ0IsT0FBTyxHQUFHQSxXQUFXO1lBQzFCLElBQUksQ0FBQ3JnQixJQUFJLEdBQUdBLFFBQVE7WUFDcEIsSUFBSXNnQixNQUFNQyxpQkFBaUIsRUFBRTtnQkFDekJELE1BQU1DLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUN4ZCxXQUFXO1lBQ2xEO1FBQ0o7UUFDQWpELGdCQUFnQmlQLE1BQU07UUFDdEJBLEtBQUt0TyxTQUFTLEdBQUdSLE9BQU9rTCxNQUFNLENBQUNtVixNQUFNN2YsU0FBUztRQUM5Q1IsT0FBT0MsY0FBYyxDQUFDNk8sS0FBS3RPLFNBQVMsRUFBRSxlQUFlO1lBQUVOLE9BQU80TztZQUFNeVIsVUFBVTtZQUFNcGdCLGNBQWM7UUFBSztRQUN2RyxPQUFPMk87SUFDWDtJQUNBLDJEQUEyRDtJQUMzRCxNQUFNb1IsZUFBZUQsbUJBQW1CRTtJQUV4QyxTQUFTSyxxQkFBcUJDLE1BQU0sRUFBRWpWLElBQUksRUFBRWtWLFlBQVksRUFBRUMsWUFBWSxFQUFFM1csYUFBYSxFQUFFMFUsTUFBTTtRQUN6RixNQUFNOVosU0FBU2lELG1DQUFtQzRZO1FBQ2xELE1BQU10RixTQUFTMUIsbUNBQW1Dak87UUFDbERpVixPQUFPL1csVUFBVSxHQUFHO1FBQ3BCLElBQUlrWCxlQUFlO1FBQ25CLHdHQUF3RztRQUN4RyxJQUFJQyxlQUFlOWYsb0JBQW9CdEI7UUFDdkMsT0FBT29CLFdBQVcsQ0FBQ0csU0FBU0w7WUFDeEIsSUFBSW1aO1lBQ0osSUFBSTRFLFdBQVdqZixXQUFXO2dCQUN0QnFhLGlCQUFpQjtvQkFDYixNQUFNakosUUFBUTZOLE9BQU94ZCxNQUFNLEtBQUt6QixZQUFZaWYsT0FBT3hkLE1BQU0sR0FBRyxJQUFJZ2YsYUFBYSxXQUFXO29CQUN4RixNQUFNWSxVQUFVLEVBQUU7b0JBQ2xCLElBQUksQ0FBQ0gsY0FBYzt3QkFDZkcsUUFBUXhkLElBQUksQ0FBQzs0QkFDVCxJQUFJa0ksS0FBS3hHLE1BQU0sS0FBSyxZQUFZO2dDQUM1QixPQUFPcVUsb0JBQW9CN04sTUFBTXFGOzRCQUNyQzs0QkFDQSxPQUFPOVAsb0JBQW9CdEI7d0JBQy9CO29CQUNKO29CQUNBLElBQUksQ0FBQ3VLLGVBQWU7d0JBQ2hCOFcsUUFBUXhkLElBQUksQ0FBQzs0QkFDVCxJQUFJbWQsT0FBT3piLE1BQU0sS0FBSyxZQUFZO2dDQUM5QixPQUFPTSxxQkFBcUJtYixRQUFRNVA7NEJBQ3hDOzRCQUNBLE9BQU85UCxvQkFBb0J0Qjt3QkFDL0I7b0JBQ0o7b0JBQ0FzaEIsbUJBQW1CLElBQU16Z0IsUUFBUTBnQixHQUFHLENBQUNGLFFBQVFHLEdBQUcsQ0FBQ0MsQ0FBQUEsU0FBVUEsWUFBWSxNQUFNclE7Z0JBQ2pGO2dCQUNBLElBQUk2TixPQUFPbkcsT0FBTyxFQUFFO29CQUNoQnVCO29CQUNBO2dCQUNKO2dCQUNBNEUsT0FBT3lDLGdCQUFnQixDQUFDLFNBQVNySDtZQUNyQztZQUNBLDRFQUE0RTtZQUM1RSxrQ0FBa0M7WUFDbEMsb0NBQW9DO1lBQ3BDLFNBQVNzSDtnQkFDTCxPQUFPdmdCLFdBQVcsQ0FBQ3dnQixhQUFhQztvQkFDNUIsU0FBU2xYLEtBQUtoQyxJQUFJO3dCQUNkLElBQUlBLE1BQU07NEJBQ05pWjt3QkFDSixPQUNLOzRCQUNELDZEQUE2RDs0QkFDN0QsdUVBQXVFOzRCQUN2RWxnQixtQkFBbUJvZ0IsWUFBWW5YLE1BQU1rWDt3QkFDekM7b0JBQ0o7b0JBQ0FsWCxLQUFLO2dCQUNUO1lBQ0o7WUFDQSxTQUFTbVg7Z0JBQ0wsSUFBSVgsY0FBYztvQkFDZCxPQUFPN2Ysb0JBQW9CO2dCQUMvQjtnQkFDQSxPQUFPSSxtQkFBbUJnYSxPQUFPa0MsYUFBYSxFQUFFO29CQUM1QyxPQUFPeGMsV0FBVyxDQUFDMmdCLGFBQWFDO3dCQUM1QnRZLGdDQUFnQ3ZFLFFBQVE7NEJBQ3BDMEQsYUFBYUgsQ0FBQUE7Z0NBQ1QwWSxlQUFlMWYsbUJBQW1Cc2MsaUNBQWlDdEMsUUFBUWhULFFBQVExSSxXQUFXRDtnQ0FDOUZnaUIsWUFBWTs0QkFDaEI7NEJBQ0FuWixhQUFhLElBQU1tWixZQUFZOzRCQUMvQnZZLGFBQWF3WTt3QkFDakI7b0JBQ0o7Z0JBQ0o7WUFDSjtZQUNBLG9DQUFvQztZQUNwQ0MsbUJBQW1CakIsUUFBUTdiLE9BQU9nQixjQUFjLEVBQUVnVyxDQUFBQTtnQkFDOUMsSUFBSSxDQUFDK0UsY0FBYztvQkFDZkksbUJBQW1CLElBQU0xSCxvQkFBb0I3TixNQUFNb1EsY0FBYyxNQUFNQTtnQkFDM0UsT0FDSztvQkFDRCtGLFNBQVMsTUFBTS9GO2dCQUNuQjtnQkFDQSxPQUFPO1lBQ1g7WUFDQSxxQ0FBcUM7WUFDckM4RixtQkFBbUJsVyxNQUFNMlAsT0FBT3ZWLGNBQWMsRUFBRWdXLENBQUFBO2dCQUM1QyxJQUFJLENBQUM1UixlQUFlO29CQUNoQitXLG1CQUFtQixJQUFNemIscUJBQXFCbWIsUUFBUTdFLGNBQWMsTUFBTUE7Z0JBQzlFLE9BQ0s7b0JBQ0QrRixTQUFTLE1BQU0vRjtnQkFDbkI7Z0JBQ0EsT0FBTztZQUNYO1lBQ0EscUNBQXFDO1lBQ3JDZ0csa0JBQWtCbkIsUUFBUTdiLE9BQU9nQixjQUFjLEVBQUU7Z0JBQzdDLElBQUksQ0FBQzhhLGNBQWM7b0JBQ2ZLLG1CQUFtQixJQUFNckQscURBQXFEdkM7Z0JBQ2xGLE9BQ0s7b0JBQ0R3RztnQkFDSjtnQkFDQSxPQUFPO1lBQ1g7WUFDQSxzQ0FBc0M7WUFDdEMsSUFBSXJJLG9DQUFvQzlOLFNBQVNBLEtBQUt4RyxNQUFNLEtBQUssVUFBVTtnQkFDdkUsTUFBTTZjLGFBQWEsSUFBSXJmLFVBQVU7Z0JBQ2pDLElBQUksQ0FBQ3dILGVBQWU7b0JBQ2hCK1csbUJBQW1CLElBQU16YixxQkFBcUJtYixRQUFRb0IsYUFBYSxNQUFNQTtnQkFDN0UsT0FDSztvQkFDREYsU0FBUyxNQUFNRTtnQkFDbkI7WUFDSjtZQUNBL2YsMEJBQTBCc2Y7WUFDMUIsU0FBU1U7Z0JBQ0wsMkdBQTJHO2dCQUMzRyxnQkFBZ0I7Z0JBQ2hCLE1BQU1DLGtCQUFrQmxCO2dCQUN4QixPQUFPMWYsbUJBQW1CMGYsY0FBYyxJQUFNa0Isb0JBQW9CbEIsZUFBZWlCLDBCQUEwQnJpQjtZQUMvRztZQUNBLFNBQVNpaUIsbUJBQW1CN2MsTUFBTSxFQUFFekQsT0FBTyxFQUFFOGYsTUFBTTtnQkFDL0MsSUFBSXJjLE9BQU9HLE1BQU0sS0FBSyxXQUFXO29CQUM3QmtjLE9BQU9yYyxPQUFPTyxZQUFZO2dCQUM5QixPQUNLO29CQUNEMUQsY0FBY04sU0FBUzhmO2dCQUMzQjtZQUNKO1lBQ0EsU0FBU1Usa0JBQWtCL2MsTUFBTSxFQUFFekQsT0FBTyxFQUFFOGYsTUFBTTtnQkFDOUMsSUFBSXJjLE9BQU9HLE1BQU0sS0FBSyxVQUFVO29CQUM1QmtjO2dCQUNKLE9BQ0s7b0JBQ0R6ZixnQkFBZ0JMLFNBQVM4ZjtnQkFDN0I7WUFDSjtZQUNBLFNBQVNILG1CQUFtQkcsTUFBTSxFQUFFYyxlQUFlLEVBQUVDLGFBQWE7Z0JBQzlELElBQUlyQixjQUFjO29CQUNkO2dCQUNKO2dCQUNBQSxlQUFlO2dCQUNmLElBQUlwVixLQUFLeEcsTUFBTSxLQUFLLGNBQWMsQ0FBQ3NVLG9DQUFvQzlOLE9BQU87b0JBQzFFL0osZ0JBQWdCcWdCLHlCQUF5Qkk7Z0JBQzdDLE9BQ0s7b0JBQ0RBO2dCQUNKO2dCQUNBLFNBQVNBO29CQUNMMWdCLFlBQVkwZixVQUFVLElBQU1pQixTQUFTSCxpQkFBaUJDLGdCQUFnQkcsQ0FBQUEsV0FBWUQsU0FBUyxNQUFNQztvQkFDakcsT0FBTztnQkFDWDtZQUNKO1lBQ0EsU0FBU1QsU0FBU1UsT0FBTyxFQUFFeFIsS0FBSztnQkFDNUIsSUFBSStQLGNBQWM7b0JBQ2Q7Z0JBQ0o7Z0JBQ0FBLGVBQWU7Z0JBQ2YsSUFBSXBWLEtBQUt4RyxNQUFNLEtBQUssY0FBYyxDQUFDc1Usb0NBQW9DOU4sT0FBTztvQkFDMUUvSixnQkFBZ0JxZ0IseUJBQXlCLElBQU1LLFNBQVNFLFNBQVN4UjtnQkFDckUsT0FDSztvQkFDRHNSLFNBQVNFLFNBQVN4UjtnQkFDdEI7WUFDSjtZQUNBLFNBQVNzUixTQUFTRSxPQUFPLEVBQUV4UixLQUFLO2dCQUM1QjJNLG1DQUFtQ3JDO2dCQUNuQzVWLG1DQUFtQ1g7Z0JBQ25DLElBQUk4WixXQUFXamYsV0FBVztvQkFDdEJpZixPQUFPNEQsbUJBQW1CLENBQUMsU0FBU3hJO2dCQUN4QztnQkFDQSxJQUFJdUksU0FBUztvQkFDVDFoQixPQUFPa1E7Z0JBQ1gsT0FDSztvQkFDRDdQLFFBQVF2QjtnQkFDWjtnQkFDQSxPQUFPO1lBQ1g7UUFDSjtJQUNKO0lBRUE7Ozs7S0FJQyxHQUNELE1BQU04aUI7UUFDRnpmLGFBQWM7WUFDVixNQUFNLElBQUlOLFVBQVU7UUFDeEI7UUFDQTs7O1NBR0MsR0FDRCxJQUFJNE4sY0FBYztZQUNkLElBQUksQ0FBQ29TLGtDQUFrQyxJQUFJLEdBQUc7Z0JBQzFDLE1BQU1DLHVDQUF1QztZQUNqRDtZQUNBLE9BQU9DLDhDQUE4QyxJQUFJO1FBQzdEO1FBQ0E7OztTQUdDLEdBQ0RwUyxRQUFRO1lBQ0osSUFBSSxDQUFDa1Msa0NBQWtDLElBQUksR0FBRztnQkFDMUMsTUFBTUMsdUNBQXVDO1lBQ2pEO1lBQ0EsSUFBSSxDQUFDRSxpREFBaUQsSUFBSSxHQUFHO2dCQUN6RCxNQUFNLElBQUluZ0IsVUFBVTtZQUN4QjtZQUNBb2dCLHFDQUFxQyxJQUFJO1FBQzdDO1FBQ0FqUyxRQUFReEksUUFBUTFJLFNBQVMsRUFBRTtZQUN2QixJQUFJLENBQUMraUIsa0NBQWtDLElBQUksR0FBRztnQkFDMUMsTUFBTUMsdUNBQXVDO1lBQ2pEO1lBQ0EsSUFBSSxDQUFDRSxpREFBaUQsSUFBSSxHQUFHO2dCQUN6RCxNQUFNLElBQUluZ0IsVUFBVTtZQUN4QjtZQUNBLE9BQU9xZ0IsdUNBQXVDLElBQUksRUFBRTFhO1FBQ3hEO1FBQ0E7O1NBRUMsR0FDRDBJLE1BQU0zSCxJQUFJekosU0FBUyxFQUFFO1lBQ2pCLElBQUksQ0FBQytpQixrQ0FBa0MsSUFBSSxHQUFHO2dCQUMxQyxNQUFNQyx1Q0FBdUM7WUFDakQ7WUFDQUsscUNBQXFDLElBQUksRUFBRTVaO1FBQy9DO1FBQ0EsY0FBYyxHQUNkLENBQUMxRSxZQUFZLENBQUN0RCxNQUFNLEVBQUU7WUFDbEIwTixXQUFXLElBQUk7WUFDZixNQUFNbEUsU0FBUyxJQUFJLENBQUNzRyxnQkFBZ0IsQ0FBQzlQO1lBQ3JDNmhCLCtDQUErQyxJQUFJO1lBQ25ELE9BQU9yWTtRQUNYO1FBQ0EsY0FBYyxHQUNkLENBQUNqRyxVQUFVLENBQUN1RCxXQUFXLEVBQUU7WUFDckIsTUFBTW5ELFNBQVMsSUFBSSxDQUFDbWUseUJBQXlCO1lBQzdDLElBQUksSUFBSSxDQUFDM1UsTUFBTSxDQUFDaEwsTUFBTSxHQUFHLEdBQUc7Z0JBQ3hCLE1BQU04RSxRQUFRK0YsYUFBYSxJQUFJO2dCQUMvQixJQUFJLElBQUksQ0FBQ3FDLGVBQWUsSUFBSSxJQUFJLENBQUNsQyxNQUFNLENBQUNoTCxNQUFNLEtBQUssR0FBRztvQkFDbEQwZiwrQ0FBK0MsSUFBSTtvQkFDbkQ5TyxvQkFBb0JwUDtnQkFDeEIsT0FDSztvQkFDRG9lLGdEQUFnRCxJQUFJO2dCQUN4RDtnQkFDQWpiLFlBQVlNLFdBQVcsQ0FBQ0g7WUFDNUIsT0FDSztnQkFDREosNkJBQTZCbEQsUUFBUW1EO2dCQUNyQ2liLGdEQUFnRCxJQUFJO1lBQ3hEO1FBQ0o7UUFDQSxjQUFjLEdBQ2QsQ0FBQ3ZlLGFBQWEsR0FBRztRQUNiLGNBQWM7UUFDbEI7SUFDSjtJQUNBMUUsT0FBT3NKLGdCQUFnQixDQUFDaVosZ0NBQWdDL2hCLFNBQVMsRUFBRTtRQUMvRDhQLE9BQU87WUFBRS9HLFlBQVk7UUFBSztRQUMxQm9ILFNBQVM7WUFBRXBILFlBQVk7UUFBSztRQUM1QnNILE9BQU87WUFBRXRILFlBQVk7UUFBSztRQUMxQjZHLGFBQWE7WUFBRTdHLFlBQVk7UUFBSztJQUNwQztJQUNBMUosZ0JBQWdCMGlCLGdDQUFnQy9oQixTQUFTLENBQUM4UCxLQUFLLEVBQUU7SUFDakV6USxnQkFBZ0IwaUIsZ0NBQWdDL2hCLFNBQVMsQ0FBQ21RLE9BQU8sRUFBRTtJQUNuRTlRLGdCQUFnQjBpQixnQ0FBZ0MvaEIsU0FBUyxDQUFDcVEsS0FBSyxFQUFFO0lBQ2pFLElBQUksT0FBT3pSLGVBQWVvSyxXQUFXLEtBQUssVUFBVTtRQUNoRHhKLE9BQU9DLGNBQWMsQ0FBQ3NpQixnQ0FBZ0MvaEIsU0FBUyxFQUFFcEIsZUFBZW9LLFdBQVcsRUFBRTtZQUN6RnRKLE9BQU87WUFDUEMsY0FBYztRQUNsQjtJQUNKO0lBQ0EsK0RBQStEO0lBQy9ELFNBQVNxaUIsa0NBQWtDN2lCLENBQUM7UUFDeEMsSUFBSSxDQUFDRCxhQUFhQyxJQUFJO1lBQ2xCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0ssT0FBT1EsU0FBUyxDQUFDaUosY0FBYyxDQUFDbEksSUFBSSxDQUFDNUIsR0FBRyw4QkFBOEI7WUFDdkUsT0FBTztRQUNYO1FBQ0EsT0FBT0EsYUFBYTRpQjtJQUN4QjtJQUNBLFNBQVNVLGdEQUFnRGpSLFVBQVU7UUFDL0QsTUFBTUMsYUFBYWlSLDhDQUE4Q2xSO1FBQ2pFLElBQUksQ0FBQ0MsWUFBWTtZQUNiO1FBQ0o7UUFDQSxJQUFJRCxXQUFXRyxRQUFRLEVBQUU7WUFDckJILFdBQVdJLFVBQVUsR0FBRztZQUN4QjtRQUNKO1FBQ0FKLFdBQVdHLFFBQVEsR0FBRztRQUN0QixNQUFNRSxjQUFjTCxXQUFXTSxjQUFjO1FBQzdDOVEsWUFBWTZRLGFBQWE7WUFDckJMLFdBQVdHLFFBQVEsR0FBRztZQUN0QixJQUFJSCxXQUFXSSxVQUFVLEVBQUU7Z0JBQ3ZCSixXQUFXSSxVQUFVLEdBQUc7Z0JBQ3hCNlEsZ0RBQWdEalI7WUFDcEQ7WUFDQSxPQUFPO1FBQ1gsR0FBRzlJLENBQUFBO1lBQ0M0WixxQ0FBcUM5USxZQUFZOUk7WUFDakQsT0FBTztRQUNYO0lBQ0o7SUFDQSxTQUFTZ2EsOENBQThDbFIsVUFBVTtRQUM3RCxNQUFNbk4sU0FBU21OLFdBQVdnUix5QkFBeUI7UUFDbkQsSUFBSSxDQUFDTCxpREFBaUQzUSxhQUFhO1lBQy9ELE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0EsV0FBV2dELFFBQVEsRUFBRTtZQUN0QixPQUFPO1FBQ1g7UUFDQSxJQUFJdE0sdUJBQXVCN0QsV0FBVzBELGlDQUFpQzFELFVBQVUsR0FBRztZQUNoRixPQUFPO1FBQ1g7UUFDQSxNQUFNdUwsY0FBY3NTLDhDQUE4QzFRO1FBQ2xFLElBQUk1QixjQUFjLEdBQUc7WUFDakIsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0lBQ0EsU0FBUzJTLCtDQUErQy9RLFVBQVU7UUFDOURBLFdBQVdNLGNBQWMsR0FBRzdTO1FBQzVCdVMsV0FBV2hCLGdCQUFnQixHQUFHdlI7UUFDOUJ1UyxXQUFXK00sc0JBQXNCLEdBQUd0ZjtJQUN4QztJQUNBLHNHQUFzRztJQUN0RyxTQUFTbWpCLHFDQUFxQzVRLFVBQVU7UUFDcEQsSUFBSSxDQUFDMlEsaURBQWlEM1EsYUFBYTtZQUMvRDtRQUNKO1FBQ0EsTUFBTW5OLFNBQVNtTixXQUFXZ1IseUJBQXlCO1FBQ25EaFIsV0FBV3pCLGVBQWUsR0FBRztRQUM3QixJQUFJeUIsV0FBVzNELE1BQU0sQ0FBQ2hMLE1BQU0sS0FBSyxHQUFHO1lBQ2hDMGYsK0NBQStDL1E7WUFDL0NpQyxvQkFBb0JwUDtRQUN4QjtJQUNKO0lBQ0EsU0FBU2dlLHVDQUF1QzdRLFVBQVUsRUFBRTdKLEtBQUs7UUFDN0QsSUFBSSxDQUFDd2EsaURBQWlEM1EsYUFBYTtZQUMvRDtRQUNKO1FBQ0EsTUFBTW5OLFNBQVNtTixXQUFXZ1IseUJBQXlCO1FBQ25ELElBQUl0YSx1QkFBdUI3RCxXQUFXMEQsaUNBQWlDMUQsVUFBVSxHQUFHO1lBQ2hGcUQsaUNBQWlDckQsUUFBUXNELE9BQU87UUFDcEQsT0FDSztZQUNELElBQUlnVztZQUNKLElBQUk7Z0JBQ0FBLFlBQVluTSxXQUFXK00sc0JBQXNCLENBQUM1VztZQUNsRCxFQUNBLE9BQU9rWCxZQUFZO2dCQUNmeUQscUNBQXFDOVEsWUFBWXFOO2dCQUNqRCxNQUFNQTtZQUNWO1lBQ0EsSUFBSTtnQkFDQTdRLHFCQUFxQndELFlBQVk3SixPQUFPZ1c7WUFDNUMsRUFDQSxPQUFPb0IsVUFBVTtnQkFDYnVELHFDQUFxQzlRLFlBQVl1TjtnQkFDakQsTUFBTUE7WUFDVjtRQUNKO1FBQ0EwRCxnREFBZ0RqUjtJQUNwRDtJQUNBLFNBQVM4USxxQ0FBcUM5USxVQUFVLEVBQUU5SSxDQUFDO1FBQ3ZELE1BQU1yRSxTQUFTbU4sV0FBV2dSLHlCQUF5QjtRQUNuRCxJQUFJbmUsT0FBT0csTUFBTSxLQUFLLFlBQVk7WUFDOUI7UUFDSjtRQUNBNEosV0FBV29EO1FBQ1grUSwrQ0FBK0MvUTtRQUMvQ29ELG9CQUFvQnZRLFFBQVFxRTtJQUNoQztJQUNBLFNBQVN3Wiw4Q0FBOEMxUSxVQUFVO1FBQzdELE1BQU14QixRQUFRd0IsV0FBV2dSLHlCQUF5QixDQUFDaGUsTUFBTTtRQUN6RCxJQUFJd0wsVUFBVSxXQUFXO1lBQ3JCLE9BQU87UUFDWDtRQUNBLElBQUlBLFVBQVUsVUFBVTtZQUNwQixPQUFPO1FBQ1g7UUFDQSxPQUFPd0IsV0FBV3VELFlBQVksR0FBR3ZELFdBQVcxRCxlQUFlO0lBQy9EO0lBQ0EseURBQXlEO0lBQ3pELFNBQVM2VSwrQ0FBK0NuUixVQUFVO1FBQzlELElBQUlrUiw4Q0FBOENsUixhQUFhO1lBQzNELE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBLFNBQVMyUSxpREFBaUQzUSxVQUFVO1FBQ2hFLE1BQU14QixRQUFRd0IsV0FBV2dSLHlCQUF5QixDQUFDaGUsTUFBTTtRQUN6RCxJQUFJLENBQUNnTixXQUFXekIsZUFBZSxJQUFJQyxVQUFVLFlBQVk7WUFDckQsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0lBQ0EsU0FBUzRTLHFDQUFxQ3ZlLE1BQU0sRUFBRW1OLFVBQVUsRUFBRTBELGNBQWMsRUFBRUMsYUFBYSxFQUFFQyxlQUFlLEVBQUVDLGFBQWEsRUFBRW1ELGFBQWE7UUFDMUloSCxXQUFXZ1IseUJBQXlCLEdBQUduZTtRQUN2Q21OLFdBQVczRCxNQUFNLEdBQUc1TztRQUNwQnVTLFdBQVcxRCxlQUFlLEdBQUc3TztRQUM3Qm1QLFdBQVdvRDtRQUNYQSxXQUFXZ0QsUUFBUSxHQUFHO1FBQ3RCaEQsV0FBV3pCLGVBQWUsR0FBRztRQUM3QnlCLFdBQVdJLFVBQVUsR0FBRztRQUN4QkosV0FBV0csUUFBUSxHQUFHO1FBQ3RCSCxXQUFXK00sc0JBQXNCLEdBQUcvRjtRQUNwQ2hILFdBQVd1RCxZQUFZLEdBQUdNO1FBQzFCN0QsV0FBV00sY0FBYyxHQUFHcUQ7UUFDNUIzRCxXQUFXaEIsZ0JBQWdCLEdBQUc0RTtRQUM5Qi9RLE9BQU9hLHlCQUF5QixHQUFHc007UUFDbkMsTUFBTThELGNBQWNKO1FBQ3BCbFUsWUFBWVQsb0JBQW9CK1UsY0FBYztZQUMxQzlELFdBQVdnRCxRQUFRLEdBQUc7WUFDdEJpTyxnREFBZ0RqUjtZQUNoRCxPQUFPO1FBQ1gsR0FBRytELENBQUFBO1lBQ0MrTSxxQ0FBcUM5USxZQUFZK0Q7WUFDakQsT0FBTztRQUNYO0lBQ0o7SUFDQSxTQUFTc04seURBQXlEeGUsTUFBTSxFQUFFeWUsZ0JBQWdCLEVBQUV6TixhQUFhLEVBQUVtRCxhQUFhO1FBQ3BILE1BQU1oSCxhQUFhaFMsT0FBT2tMLE1BQU0sQ0FBQ3FYLGdDQUFnQy9oQixTQUFTO1FBQzFFLElBQUlrVjtRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJME4saUJBQWlCcE4sS0FBSyxLQUFLelcsV0FBVztZQUN0Q2lXLGlCQUFpQixJQUFNNE4saUJBQWlCcE4sS0FBSyxDQUFDbEU7UUFDbEQsT0FDSztZQUNEMEQsaUJBQWlCLElBQU1qVztRQUMzQjtRQUNBLElBQUk2akIsaUJBQWlCbk4sSUFBSSxLQUFLMVcsV0FBVztZQUNyQ2tXLGdCQUFnQixJQUFNMk4saUJBQWlCbk4sSUFBSSxDQUFDbkU7UUFDaEQsT0FDSztZQUNEMkQsZ0JBQWdCLElBQU01VSxvQkFBb0J0QjtRQUM5QztRQUNBLElBQUk2akIsaUJBQWlCemEsTUFBTSxLQUFLcEosV0FBVztZQUN2Q21XLGtCQUFrQjFVLENBQUFBLFNBQVVvaUIsaUJBQWlCemEsTUFBTSxDQUFDM0g7UUFDeEQsT0FDSztZQUNEMFUsa0JBQWtCLElBQU03VSxvQkFBb0J0QjtRQUNoRDtRQUNBMmpCLHFDQUFxQ3ZlLFFBQVFtTixZQUFZMEQsZ0JBQWdCQyxlQUFlQyxpQkFBaUJDLGVBQWVtRDtJQUM1SDtJQUNBLDREQUE0RDtJQUM1RCxTQUFTeUosdUNBQXVDMWlCLElBQUk7UUFDaEQsT0FBTyxJQUFJeUMsVUFBVSxDQUFDLDBDQUEwQyxFQUFFekMsS0FBSyxzREFBc0QsQ0FBQztJQUNsSTtJQUVBLFNBQVN3akIsa0JBQWtCMWUsTUFBTSxFQUFFMmUsZUFBZTtRQUM5QyxJQUFJdlQsK0JBQStCcEwsT0FBT2EseUJBQXlCLEdBQUc7WUFDbEUsT0FBTytkLHNCQUFzQjVlO1FBQ2pDO1FBQ0EsT0FBTzZlLHlCQUF5QjdlO0lBQ3BDO0lBQ0EsU0FBUzZlLHlCQUF5QjdlLE1BQU0sRUFBRTJlLGVBQWU7UUFDckQsTUFBTTVlLFNBQVNpRCxtQ0FBbUNoRDtRQUNsRCxJQUFJOGUsVUFBVTtRQUNkLElBQUlDLFlBQVk7UUFDaEIsSUFBSUMsWUFBWTtRQUNoQixJQUFJQyxZQUFZO1FBQ2hCLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixNQUFNQyxnQkFBZ0J2akIsV0FBV0csQ0FBQUE7WUFDN0JtakIsdUJBQXVCbmpCO1FBQzNCO1FBQ0EsU0FBUzJVO1lBQ0wsSUFBSWdPLFNBQVM7Z0JBQ1RDLFlBQVk7Z0JBQ1osT0FBTzdpQixvQkFBb0J0QjtZQUMvQjtZQUNBa2tCLFVBQVU7WUFDVixNQUFNM2IsY0FBYztnQkFDaEJNLGFBQWFILENBQUFBO29CQUNULHFHQUFxRztvQkFDckcsK0dBQStHO29CQUMvRyx5RkFBeUY7b0JBQ3pGcEcsZ0JBQWdCO3dCQUNaNmhCLFlBQVk7d0JBQ1osTUFBTVMsU0FBU2xjO3dCQUNmLE1BQU1tYyxTQUFTbmM7d0JBQ2Ysd0ZBQXdGO3dCQUN4Riw0RUFBNEU7d0JBQzVFLHVDQUF1Qzt3QkFDdkMsaUVBQWlFO3dCQUNqRSxJQUFJO3dCQUNKLElBQUksQ0FBQzBiLFdBQVc7NEJBQ1poQix1Q0FBdUNvQixRQUFRdmUseUJBQXlCLEVBQUUyZTt3QkFDOUU7d0JBQ0EsSUFBSSxDQUFDUCxXQUFXOzRCQUNaakIsdUNBQXVDcUIsUUFBUXhlLHlCQUF5QixFQUFFNGU7d0JBQzlFO3dCQUNBWCxVQUFVO3dCQUNWLElBQUlDLFdBQVc7NEJBQ1hqTzt3QkFDSjtvQkFDSjtnQkFDSjtnQkFDQXROLGFBQWE7b0JBQ1RzYixVQUFVO29CQUNWLElBQUksQ0FBQ0UsV0FBVzt3QkFDWmpCLHFDQUFxQ3FCLFFBQVF2ZSx5QkFBeUI7b0JBQzFFO29CQUNBLElBQUksQ0FBQ29lLFdBQVc7d0JBQ1psQixxQ0FBcUNzQixRQUFReGUseUJBQXlCO29CQUMxRTtvQkFDQSxJQUFJLENBQUNtZSxhQUFhLENBQUNDLFdBQVc7d0JBQzFCSyxxQkFBcUIxa0I7b0JBQ3pCO2dCQUNKO2dCQUNBd0osYUFBYTtvQkFDVDBhLFVBQVU7Z0JBQ2Q7WUFDSjtZQUNBeGEsZ0NBQWdDdkUsUUFBUW9EO1lBQ3hDLE9BQU9qSCxvQkFBb0J0QjtRQUMvQjtRQUNBLFNBQVM4a0IsaUJBQWlCcmpCLE1BQU07WUFDNUIyaUIsWUFBWTtZQUNaRSxVQUFVN2lCO1lBQ1YsSUFBSTRpQixXQUFXO2dCQUNYLE1BQU1VLGtCQUFrQm5aLG9CQUFvQjtvQkFBQzBZO29CQUFTQztpQkFBUTtnQkFDOUQsTUFBTVMsZUFBZW5mLHFCQUFxQlQsUUFBUTJmO2dCQUNsREwscUJBQXFCTTtZQUN6QjtZQUNBLE9BQU9MO1FBQ1g7UUFDQSxTQUFTTSxpQkFBaUJ4akIsTUFBTTtZQUM1QjRpQixZQUFZO1lBQ1pFLFVBQVU5aUI7WUFDVixJQUFJMmlCLFdBQVc7Z0JBQ1gsTUFBTVcsa0JBQWtCblosb0JBQW9CO29CQUFDMFk7b0JBQVNDO2lCQUFRO2dCQUM5RCxNQUFNUyxlQUFlbmYscUJBQXFCVCxRQUFRMmY7Z0JBQ2xETCxxQkFBcUJNO1lBQ3pCO1lBQ0EsT0FBT0w7UUFDWDtRQUNBLFNBQVMxTztRQUNMLGFBQWE7UUFDakI7UUFDQXVPLFVBQVVVLHFCQUFxQmpQLGdCQUFnQkMsZUFBZTRPO1FBQzlETCxVQUFVUyxxQkFBcUJqUCxnQkFBZ0JDLGVBQWUrTztRQUM5RGhqQixjQUFja0QsT0FBT2dCLGNBQWMsRUFBRSxDQUFDbVE7WUFDbEMrTSxxQ0FBcUNtQixRQUFRdmUseUJBQXlCLEVBQUVxUTtZQUN4RStNLHFDQUFxQ29CLFFBQVF4ZSx5QkFBeUIsRUFBRXFRO1lBQ3hFLElBQUksQ0FBQzhOLGFBQWEsQ0FBQ0MsV0FBVztnQkFDMUJLLHFCQUFxQjFrQjtZQUN6QjtZQUNBLE9BQU87UUFDWDtRQUNBLE9BQU87WUFBQ3drQjtZQUFTQztTQUFRO0lBQzdCO0lBQ0EsU0FBU1Qsc0JBQXNCNWUsTUFBTTtRQUNqQyxJQUFJRCxTQUFTaUQsbUNBQW1DaEQ7UUFDaEQsSUFBSThlLFVBQVU7UUFDZCxJQUFJaUIsc0JBQXNCO1FBQzFCLElBQUlDLHNCQUFzQjtRQUMxQixJQUFJaEIsWUFBWTtRQUNoQixJQUFJQyxZQUFZO1FBQ2hCLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixNQUFNQyxnQkFBZ0J2akIsV0FBV0csQ0FBQUE7WUFDN0JtakIsdUJBQXVCbmpCO1FBQzNCO1FBQ0EsU0FBUzhqQixtQkFBbUJDLFVBQVU7WUFDbENyakIsY0FBY3FqQixXQUFXbmYsY0FBYyxFQUFFbVEsQ0FBQUE7Z0JBQ3JDLElBQUlnUCxlQUFlbmdCLFFBQVE7b0JBQ3ZCLE9BQU87Z0JBQ1g7Z0JBQ0FrTSxrQ0FBa0NtVCxRQUFRdmUseUJBQXlCLEVBQUVxUTtnQkFDckVqRixrQ0FBa0NvVCxRQUFReGUseUJBQXlCLEVBQUVxUTtnQkFDckUsSUFBSSxDQUFDOE4sYUFBYSxDQUFDQyxXQUFXO29CQUMxQksscUJBQXFCMWtCO2dCQUN6QjtnQkFDQSxPQUFPO1lBQ1g7UUFDSjtRQUNBLFNBQVN1bEI7WUFDTCxJQUFJbk8sMkJBQTJCalMsU0FBUztnQkFDcENXLG1DQUFtQ1g7Z0JBQ25DQSxTQUFTaUQsbUNBQW1DaEQ7Z0JBQzVDaWdCLG1CQUFtQmxnQjtZQUN2QjtZQUNBLE1BQU1vRCxjQUFjO2dCQUNoQk0sYUFBYUgsQ0FBQUE7b0JBQ1QscUdBQXFHO29CQUNyRywrR0FBK0c7b0JBQy9HLHlGQUF5RjtvQkFDekZwRyxnQkFBZ0I7d0JBQ1o2aUIsc0JBQXNCO3dCQUN0QkMsc0JBQXNCO3dCQUN0QixNQUFNUixTQUFTbGM7d0JBQ2YsSUFBSW1jLFNBQVNuYzt3QkFDYixJQUFJLENBQUMwYixhQUFhLENBQUNDLFdBQVc7NEJBQzFCLElBQUk7Z0NBQ0FRLFNBQVN0VyxrQkFBa0I3Rjs0QkFDL0IsRUFDQSxPQUFPNEssUUFBUTtnQ0FDWGpDLGtDQUFrQ21ULFFBQVF2ZSx5QkFBeUIsRUFBRXFOO2dDQUNyRWpDLGtDQUFrQ29ULFFBQVF4ZSx5QkFBeUIsRUFBRXFOO2dDQUNyRW9SLHFCQUFxQjdlLHFCQUFxQlQsUUFBUWtPO2dDQUNsRDs0QkFDSjt3QkFDSjt3QkFDQSxJQUFJLENBQUM4USxXQUFXOzRCQUNaalQsb0NBQW9DcVQsUUFBUXZlLHlCQUF5QixFQUFFMmU7d0JBQzNFO3dCQUNBLElBQUksQ0FBQ1AsV0FBVzs0QkFDWmxULG9DQUFvQ3NULFFBQVF4ZSx5QkFBeUIsRUFBRTRlO3dCQUMzRTt3QkFDQVgsVUFBVTt3QkFDVixJQUFJaUIscUJBQXFCOzRCQUNyQks7d0JBQ0osT0FDSyxJQUFJSixxQkFBcUI7NEJBQzFCSzt3QkFDSjtvQkFDSjtnQkFDSjtnQkFDQTdjLGFBQWE7b0JBQ1RzYixVQUFVO29CQUNWLElBQUksQ0FBQ0UsV0FBVzt3QkFDWm5ULGtDQUFrQ3VULFFBQVF2ZSx5QkFBeUI7b0JBQ3ZFO29CQUNBLElBQUksQ0FBQ29lLFdBQVc7d0JBQ1pwVCxrQ0FBa0N3VCxRQUFReGUseUJBQXlCO29CQUN2RTtvQkFDQSxJQUFJdWUsUUFBUXZlLHlCQUF5QixDQUFDbU0saUJBQWlCLENBQUN4TyxNQUFNLEdBQUcsR0FBRzt3QkFDaEVzTSxvQ0FBb0NzVSxRQUFRdmUseUJBQXlCLEVBQUU7b0JBQzNFO29CQUNBLElBQUl3ZSxRQUFReGUseUJBQXlCLENBQUNtTSxpQkFBaUIsQ0FBQ3hPLE1BQU0sR0FBRyxHQUFHO3dCQUNoRXNNLG9DQUFvQ3VVLFFBQVF4ZSx5QkFBeUIsRUFBRTtvQkFDM0U7b0JBQ0EsSUFBSSxDQUFDbWUsYUFBYSxDQUFDQyxXQUFXO3dCQUMxQksscUJBQXFCMWtCO29CQUN6QjtnQkFDSjtnQkFDQXdKLGFBQWE7b0JBQ1QwYSxVQUFVO2dCQUNkO1lBQ0o7WUFDQXhhLGdDQUFnQ3ZFLFFBQVFvRDtRQUM1QztRQUNBLFNBQVNtZCxtQkFBbUJsVyxJQUFJLEVBQUVtVyxVQUFVO1lBQ3hDLElBQUkzYyw4QkFBOEI3RCxTQUFTO2dCQUN2Q1csbUNBQW1DWDtnQkFDbkNBLFNBQVM4UixnQ0FBZ0M3UjtnQkFDekNpZ0IsbUJBQW1CbGdCO1lBQ3ZCO1lBQ0EsTUFBTXlnQixhQUFhRCxhQUFhbEIsVUFBVUQ7WUFDMUMsTUFBTXFCLGNBQWNGLGFBQWFuQixVQUFVQztZQUMzQyxNQUFNNVAsa0JBQWtCO2dCQUNwQmhNLGFBQWFILENBQUFBO29CQUNULHFHQUFxRztvQkFDckcsK0dBQStHO29CQUMvRyx5RkFBeUY7b0JBQ3pGcEcsZ0JBQWdCO3dCQUNaNmlCLHNCQUFzQjt3QkFDdEJDLHNCQUFzQjt3QkFDdEIsTUFBTVUsZUFBZUgsYUFBYXRCLFlBQVlEO3dCQUM5QyxNQUFNMkIsZ0JBQWdCSixhQUFhdkIsWUFBWUM7d0JBQy9DLElBQUksQ0FBQzBCLGVBQWU7NEJBQ2hCLElBQUkxUzs0QkFDSixJQUFJO2dDQUNBQSxjQUFjOUUsa0JBQWtCN0Y7NEJBQ3BDLEVBQ0EsT0FBTzRLLFFBQVE7Z0NBQ1hqQyxrQ0FBa0N1VSxXQUFXM2YseUJBQXlCLEVBQUVxTjtnQ0FDeEVqQyxrQ0FBa0N3VSxZQUFZNWYseUJBQXlCLEVBQUVxTjtnQ0FDekVvUixxQkFBcUI3ZSxxQkFBcUJULFFBQVFrTztnQ0FDbEQ7NEJBQ0o7NEJBQ0EsSUFBSSxDQUFDd1MsY0FBYztnQ0FDZnpWLCtDQUErQ3VWLFdBQVczZix5QkFBeUIsRUFBRXlDOzRCQUN6Rjs0QkFDQXlJLG9DQUFvQzBVLFlBQVk1Zix5QkFBeUIsRUFBRW9OO3dCQUMvRSxPQUNLLElBQUksQ0FBQ3lTLGNBQWM7NEJBQ3BCelYsK0NBQStDdVYsV0FBVzNmLHlCQUF5QixFQUFFeUM7d0JBQ3pGO3dCQUNBd2IsVUFBVTt3QkFDVixJQUFJaUIscUJBQXFCOzRCQUNyQks7d0JBQ0osT0FDSyxJQUFJSixxQkFBcUI7NEJBQzFCSzt3QkFDSjtvQkFDSjtnQkFDSjtnQkFDQTdjLGFBQWFGLENBQUFBO29CQUNUd2IsVUFBVTtvQkFDVixNQUFNNEIsZUFBZUgsYUFBYXRCLFlBQVlEO29CQUM5QyxNQUFNMkIsZ0JBQWdCSixhQUFhdkIsWUFBWUM7b0JBQy9DLElBQUksQ0FBQ3lCLGNBQWM7d0JBQ2Y3VSxrQ0FBa0MyVSxXQUFXM2YseUJBQXlCO29CQUMxRTtvQkFDQSxJQUFJLENBQUM4ZixlQUFlO3dCQUNoQjlVLGtDQUFrQzRVLFlBQVk1Zix5QkFBeUI7b0JBQzNFO29CQUNBLElBQUl5QyxVQUFVMUksV0FBVzt3QkFDckIsSUFBSSxDQUFDOGxCLGNBQWM7NEJBQ2Z6ViwrQ0FBK0N1VixXQUFXM2YseUJBQXlCLEVBQUV5Qzt3QkFDekY7d0JBQ0EsSUFBSSxDQUFDcWQsaUJBQWlCRixZQUFZNWYseUJBQXlCLENBQUNtTSxpQkFBaUIsQ0FBQ3hPLE1BQU0sR0FBRyxHQUFHOzRCQUN0RnNNLG9DQUFvQzJWLFlBQVk1Zix5QkFBeUIsRUFBRTt3QkFDL0U7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDNmYsZ0JBQWdCLENBQUNDLGVBQWU7d0JBQ2pDckIscUJBQXFCMWtCO29CQUN6QjtnQkFDSjtnQkFDQXdKLGFBQWE7b0JBQ1QwYSxVQUFVO2dCQUNkO1lBQ0o7WUFDQTNNLDZCQUE2QnBTLFFBQVFxSyxNQUFNLEdBQUdxRjtRQUNsRDtRQUNBLFNBQVMyUTtZQUNMLElBQUl0QixTQUFTO2dCQUNUaUIsc0JBQXNCO2dCQUN0QixPQUFPN2pCLG9CQUFvQnRCO1lBQy9CO1lBQ0Fra0IsVUFBVTtZQUNWLE1BQU0zVCxjQUFjRywyQ0FBMkM4VCxRQUFRdmUseUJBQXlCO1lBQ2hHLElBQUlzSyxnQkFBZ0IsTUFBTTtnQkFDdEJnVjtZQUNKLE9BQ0s7Z0JBQ0RHLG1CQUFtQm5WLFlBQVlULEtBQUssRUFBRTtZQUMxQztZQUNBLE9BQU94TyxvQkFBb0J0QjtRQUMvQjtRQUNBLFNBQVN5bEI7WUFDTCxJQUFJdkIsU0FBUztnQkFDVGtCLHNCQUFzQjtnQkFDdEIsT0FBTzlqQixvQkFBb0J0QjtZQUMvQjtZQUNBa2tCLFVBQVU7WUFDVixNQUFNM1QsY0FBY0csMkNBQTJDK1QsUUFBUXhlLHlCQUF5QjtZQUNoRyxJQUFJc0ssZ0JBQWdCLE1BQU07Z0JBQ3RCZ1Y7WUFDSixPQUNLO2dCQUNERyxtQkFBbUJuVixZQUFZVCxLQUFLLEVBQUU7WUFDMUM7WUFDQSxPQUFPeE8sb0JBQW9CdEI7UUFDL0I7UUFDQSxTQUFTOGtCLGlCQUFpQnJqQixNQUFNO1lBQzVCMmlCLFlBQVk7WUFDWkUsVUFBVTdpQjtZQUNWLElBQUk0aUIsV0FBVztnQkFDWCxNQUFNVSxrQkFBa0JuWixvQkFBb0I7b0JBQUMwWTtvQkFBU0M7aUJBQVE7Z0JBQzlELE1BQU1TLGVBQWVuZixxQkFBcUJULFFBQVEyZjtnQkFDbERMLHFCQUFxQk07WUFDekI7WUFDQSxPQUFPTDtRQUNYO1FBQ0EsU0FBU00saUJBQWlCeGpCLE1BQU07WUFDNUI0aUIsWUFBWTtZQUNaRSxVQUFVOWlCO1lBQ1YsSUFBSTJpQixXQUFXO2dCQUNYLE1BQU1XLGtCQUFrQm5aLG9CQUFvQjtvQkFBQzBZO29CQUFTQztpQkFBUTtnQkFDOUQsTUFBTVMsZUFBZW5mLHFCQUFxQlQsUUFBUTJmO2dCQUNsREwscUJBQXFCTTtZQUN6QjtZQUNBLE9BQU9MO1FBQ1g7UUFDQSxTQUFTMU87WUFDTDtRQUNKO1FBQ0F1TyxVQUFVd0IseUJBQXlCL1AsZ0JBQWdCdVAsZ0JBQWdCVjtRQUNuRUwsVUFBVXVCLHlCQUF5Qi9QLGdCQUFnQndQLGdCQUFnQlI7UUFDbkVJLG1CQUFtQmxnQjtRQUNuQixPQUFPO1lBQUNxZjtZQUFTQztTQUFRO0lBQzdCO0lBRUEsU0FBU3dCLHFCQUFxQjdnQixNQUFNO1FBQ2hDLE9BQU9uRixhQUFhbUYsV0FBVyxPQUFPQSxPQUFPOGdCLFNBQVMsS0FBSztJQUMvRDtJQUVBLFNBQVNDLG1CQUFtQm5GLE1BQU07UUFDOUIsSUFBSWlGLHFCQUFxQmpGLFNBQVM7WUFDOUIsT0FBT29GLGdDQUFnQ3BGLE9BQU9rRixTQUFTO1FBQzNEO1FBQ0EsT0FBT0csMkJBQTJCckY7SUFDdEM7SUFDQSxTQUFTcUYsMkJBQTJCQyxhQUFhO1FBQzdDLElBQUlsaEI7UUFDSixNQUFNNkksaUJBQWlCTCxZQUFZMFksZUFBZTtRQUNsRCxNQUFNclEsaUJBQWlCbFc7UUFDdkIsU0FBU21XO1lBQ0wsSUFBSXFRO1lBQ0osSUFBSTtnQkFDQUEsYUFBYXZZLGFBQWFDO1lBQzlCLEVBQ0EsT0FBT3hFLEdBQUc7Z0JBQ04sT0FBT2pJLG9CQUFvQmlJO1lBQy9CO1lBQ0EsTUFBTStjLGNBQWNsbEIsb0JBQW9CaWxCO1lBQ3hDLE9BQU9ya0IscUJBQXFCc2tCLGFBQWFyWSxDQUFBQTtnQkFDckMsSUFBSSxDQUFDbE8sYUFBYWtPLGFBQWE7b0JBQzNCLE1BQU0sSUFBSXBMLFVBQVU7Z0JBQ3hCO2dCQUNBLE1BQU00RixPQUFPdUYsaUJBQWlCQztnQkFDOUIsSUFBSXhGLE1BQU07b0JBQ053YSxxQ0FBcUMvZCxPQUFPYSx5QkFBeUI7Z0JBQ3pFLE9BQ0s7b0JBQ0QsTUFBTXhGLFFBQVE0TixjQUFjRjtvQkFDNUJpVix1Q0FBdUNoZSxPQUFPYSx5QkFBeUIsRUFBRXhGO2dCQUM3RTtZQUNKO1FBQ0o7UUFDQSxTQUFTMFYsZ0JBQWdCMVUsTUFBTTtZQUMzQixNQUFNNUIsV0FBV29PLGVBQWVwTyxRQUFRO1lBQ3hDLElBQUk0bUI7WUFDSixJQUFJO2dCQUNBQSxlQUFldlosVUFBVXJOLFVBQVU7WUFDdkMsRUFDQSxPQUFPNEosR0FBRztnQkFDTixPQUFPakksb0JBQW9CaUk7WUFDL0I7WUFDQSxJQUFJZ2QsaUJBQWlCem1CLFdBQVc7Z0JBQzVCLE9BQU9zQixvQkFBb0J0QjtZQUMvQjtZQUNBLElBQUkwbUI7WUFDSixJQUFJO2dCQUNBQSxlQUFlL2pCLFlBQVk4akIsY0FBYzVtQixVQUFVO29CQUFDNEI7aUJBQU87WUFDL0QsRUFDQSxPQUFPZ0ksR0FBRztnQkFDTixPQUFPakksb0JBQW9CaUk7WUFDL0I7WUFDQSxNQUFNa2QsZ0JBQWdCcmxCLG9CQUFvQm9sQjtZQUMxQyxPQUFPeGtCLHFCQUFxQnlrQixlQUFleFksQ0FBQUE7Z0JBQ3ZDLElBQUksQ0FBQ2xPLGFBQWFrTyxhQUFhO29CQUMzQixNQUFNLElBQUlwTCxVQUFVO2dCQUN4QjtnQkFDQSxPQUFPL0M7WUFDWDtRQUNKO1FBQ0FvRixTQUFTOGYscUJBQXFCalAsZ0JBQWdCQyxlQUFlQyxpQkFBaUI7UUFDOUUsT0FBTy9RO0lBQ1g7SUFDQSxTQUFTZ2hCLGdDQUFnQ2poQixNQUFNO1FBQzNDLElBQUlDO1FBQ0osTUFBTTZRLGlCQUFpQmxXO1FBQ3ZCLFNBQVNtVztZQUNMLElBQUkwUTtZQUNKLElBQUk7Z0JBQ0FBLGNBQWN6aEIsT0FBT2tFLElBQUk7WUFDN0IsRUFDQSxPQUFPSSxHQUFHO2dCQUNOLE9BQU9qSSxvQkFBb0JpSTtZQUMvQjtZQUNBLE9BQU92SCxxQkFBcUIwa0IsYUFBYUMsQ0FBQUE7Z0JBQ3JDLElBQUksQ0FBQzVtQixhQUFhNG1CLGFBQWE7b0JBQzNCLE1BQU0sSUFBSTlqQixVQUFVO2dCQUN4QjtnQkFDQSxJQUFJOGpCLFdBQVdsZSxJQUFJLEVBQUU7b0JBQ2pCd2EscUNBQXFDL2QsT0FBT2EseUJBQXlCO2dCQUN6RSxPQUNLO29CQUNELE1BQU14RixRQUFRb21CLFdBQVdwbUIsS0FBSztvQkFDOUIyaUIsdUNBQXVDaGUsT0FBT2EseUJBQXlCLEVBQUV4RjtnQkFDN0U7WUFDSjtRQUNKO1FBQ0EsU0FBUzBWLGdCQUFnQjFVLE1BQU07WUFDM0IsSUFBSTtnQkFDQSxPQUFPSCxvQkFBb0I2RCxPQUFPaUUsTUFBTSxDQUFDM0g7WUFDN0MsRUFDQSxPQUFPZ0ksR0FBRztnQkFDTixPQUFPakksb0JBQW9CaUk7WUFDL0I7UUFDSjtRQUNBckUsU0FBUzhmLHFCQUFxQmpQLGdCQUFnQkMsZUFBZUMsaUJBQWlCO1FBQzlFLE9BQU8vUTtJQUNYO0lBRUEsU0FBUzBoQixxQ0FBcUM5RixNQUFNLEVBQUU3WixPQUFPO1FBQ3pERixpQkFBaUIrWixRQUFRN1o7UUFDekIsTUFBTWdSLFdBQVc2STtRQUNqQixNQUFNdFAsd0JBQXdCeUcsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN6RyxxQkFBcUI7UUFDaEgsTUFBTXRJLFNBQVMrTyxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBUy9PLE1BQU07UUFDbEYsTUFBTXNOLE9BQU95QixhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3pCLElBQUk7UUFDOUUsTUFBTUQsUUFBUTBCLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTMUIsS0FBSztRQUNoRixNQUFNNEIsT0FBT0YsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVNFLElBQUk7UUFDOUUsT0FBTztZQUNIM0csdUJBQXVCQSwwQkFBMEIxUixZQUM3Q0EsWUFDQThILHdDQUF3QzRKLHVCQUF1QixDQUFDLEVBQUV2SyxRQUFRLHdDQUF3QyxDQUFDO1lBQ3ZIaUMsUUFBUUEsV0FBV3BKLFlBQ2ZBLFlBQ0ErbUIsc0NBQXNDM2QsUUFBUStPLFVBQVUsQ0FBQyxFQUFFaFIsUUFBUSx5QkFBeUIsQ0FBQztZQUNqR3VQLE1BQU1BLFNBQVMxVyxZQUNYQSxZQUNBZ25CLG9DQUFvQ3RRLE1BQU15QixVQUFVLENBQUMsRUFBRWhSLFFBQVEsdUJBQXVCLENBQUM7WUFDM0ZzUCxPQUFPQSxVQUFVelcsWUFDYkEsWUFDQWluQixxQ0FBcUN4USxPQUFPMEIsVUFBVSxDQUFDLEVBQUVoUixRQUFRLHdCQUF3QixDQUFDO1lBQzlGa1IsTUFBTUEsU0FBU3JZLFlBQVlBLFlBQVlrbkIsMEJBQTBCN08sTUFBTSxDQUFDLEVBQUVsUixRQUFRLHVCQUF1QixDQUFDO1FBQzlHO0lBQ0o7SUFDQSxTQUFTNGYsc0NBQXNDMW1CLEVBQUUsRUFBRThYLFFBQVEsRUFBRWhSLE9BQU87UUFDaEVDLGVBQWUvRyxJQUFJOEc7UUFDbkIsT0FBTyxDQUFDMUYsU0FBV3lCLFlBQVk3QyxJQUFJOFgsVUFBVTtnQkFBQzFXO2FBQU87SUFDekQ7SUFDQSxTQUFTdWxCLG9DQUFvQzNtQixFQUFFLEVBQUU4WCxRQUFRLEVBQUVoUixPQUFPO1FBQzlEQyxlQUFlL0csSUFBSThHO1FBQ25CLE9BQU8sQ0FBQ29MLGFBQWVyUCxZQUFZN0MsSUFBSThYLFVBQVU7Z0JBQUM1RjthQUFXO0lBQ2pFO0lBQ0EsU0FBUzBVLHFDQUFxQzVtQixFQUFFLEVBQUU4WCxRQUFRLEVBQUVoUixPQUFPO1FBQy9EQyxlQUFlL0csSUFBSThHO1FBQ25CLE9BQU8sQ0FBQ29MLGFBQWU1UCxZQUFZdEMsSUFBSThYLFVBQVU7Z0JBQUM1RjthQUFXO0lBQ2pFO0lBQ0EsU0FBUzJVLDBCQUEwQjdPLElBQUksRUFBRWxSLE9BQU87UUFDNUNrUixPQUFPLENBQUMsRUFBRUEsS0FBSyxDQUFDO1FBQ2hCLElBQUlBLFNBQVMsU0FBUztZQUNsQixNQUFNLElBQUl0VixVQUFVLENBQUMsRUFBRW9FLFFBQVEsRUFBRSxFQUFFa1IsS0FBSyx5REFBeUQsQ0FBQztRQUN0RztRQUNBLE9BQU9BO0lBQ1g7SUFFQSxTQUFTOE8sdUJBQXVCdFEsT0FBTyxFQUFFMVAsT0FBTztRQUM1Q0YsaUJBQWlCNFAsU0FBUzFQO1FBQzFCLE1BQU1vRCxnQkFBZ0JzTSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXRNLGFBQWE7UUFDN0YsT0FBTztZQUFFQSxlQUFlNkQsUUFBUTdEO1FBQWU7SUFDbkQ7SUFFQSxTQUFTNmMsbUJBQW1CdlEsT0FBTyxFQUFFMVAsT0FBTztRQUN4Q0YsaUJBQWlCNFAsU0FBUzFQO1FBQzFCLE1BQU0rWixlQUFlckssWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFxSyxZQUFZO1FBQzNGLE1BQU0zVyxnQkFBZ0JzTSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXRNLGFBQWE7UUFDN0YsTUFBTTBXLGVBQWVwSyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUW9LLFlBQVk7UUFDM0YsTUFBTWhDLFNBQVNwSSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUW9JLE1BQU07UUFDL0UsSUFBSUEsV0FBV2pmLFdBQVc7WUFDdEJxbkIsa0JBQWtCcEksUUFBUSxDQUFDLEVBQUU5WCxRQUFRLHlCQUF5QixDQUFDO1FBQ25FO1FBQ0EsT0FBTztZQUNIK1osY0FBYzlTLFFBQVE4UztZQUN0QjNXLGVBQWU2RCxRQUFRN0Q7WUFDdkIwVyxjQUFjN1MsUUFBUTZTO1lBQ3RCaEM7UUFDSjtJQUNKO0lBQ0EsU0FBU29JLGtCQUFrQnBJLE1BQU0sRUFBRTlYLE9BQU87UUFDdEMsSUFBSSxDQUFDMFIsY0FBY29HLFNBQVM7WUFDeEIsTUFBTSxJQUFJbGMsVUFBVSxDQUFDLEVBQUVvRSxRQUFRLHVCQUF1QixDQUFDO1FBQzNEO0lBQ0o7SUFFQSxTQUFTbWdCLDRCQUE0QjNZLElBQUksRUFBRXhILE9BQU87UUFDOUNGLGlCQUFpQjBILE1BQU14SDtRQUN2QixNQUFNb2dCLFdBQVc1WSxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSzRZLFFBQVE7UUFDMUU5ZixvQkFBb0I4ZixVQUFVLFlBQVk7UUFDMUNyZixxQkFBcUJxZixVQUFVLENBQUMsRUFBRXBnQixRQUFRLDJCQUEyQixDQUFDO1FBQ3RFLE1BQU0yWixXQUFXblMsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUttUyxRQUFRO1FBQzFFclosb0JBQW9CcVosVUFBVSxZQUFZO1FBQzFDbkkscUJBQXFCbUksVUFBVSxDQUFDLEVBQUUzWixRQUFRLDJCQUEyQixDQUFDO1FBQ3RFLE9BQU87WUFBRW9nQjtZQUFVekc7UUFBUztJQUNoQztJQUVBOzs7O0tBSUMsR0FDRCxNQUFNMEc7UUFDRm5rQixZQUFZb2tCLHNCQUFzQixDQUFDLENBQUMsRUFBRXJPLGNBQWMsQ0FBQyxDQUFDLENBQUU7WUFDcEQsSUFBSXFPLHdCQUF3QnpuQixXQUFXO2dCQUNuQ3luQixzQkFBc0I7WUFDMUIsT0FDSztnQkFDRG5nQixhQUFhbWdCLHFCQUFxQjtZQUN0QztZQUNBLE1BQU03UCxXQUFXRyx1QkFBdUJxQixhQUFhO1lBQ3JELE1BQU15SyxtQkFBbUJpRCxxQ0FBcUNXLHFCQUFxQjtZQUNuRkMseUJBQXlCLElBQUk7WUFDN0IsSUFBSTdELGlCQUFpQnhMLElBQUksS0FBSyxTQUFTO2dCQUNuQyxJQUFJVCxTQUFTOUksSUFBSSxLQUFLOU8sV0FBVztvQkFDN0IsTUFBTSxJQUFJaVAsV0FBVztnQkFDekI7Z0JBQ0EsTUFBTW1ILGdCQUFnQnVCLHFCQUFxQkMsVUFBVTtnQkFDckRyQixzREFBc0QsSUFBSSxFQUFFc04sa0JBQWtCek47WUFDbEYsT0FDSztnQkFDRCxNQUFNbUQsZ0JBQWdCekIscUJBQXFCRjtnQkFDM0MsTUFBTXhCLGdCQUFnQnVCLHFCQUFxQkMsVUFBVTtnQkFDckRnTSx5REFBeUQsSUFBSSxFQUFFQyxrQkFBa0J6TixlQUFlbUQ7WUFDcEc7UUFDSjtRQUNBOztTQUVDLEdBQ0QsSUFBSUUsU0FBUztZQUNULElBQUksQ0FBQ3RSLGlCQUFpQixJQUFJLEdBQUc7Z0JBQ3pCLE1BQU13Ziw0QkFBNEI7WUFDdEM7WUFDQSxPQUFPMWUsdUJBQXVCLElBQUk7UUFDdEM7UUFDQTs7Ozs7U0FLQyxHQUNERyxPQUFPM0gsU0FBU3pCLFNBQVMsRUFBRTtZQUN2QixJQUFJLENBQUNtSSxpQkFBaUIsSUFBSSxHQUFHO2dCQUN6QixPQUFPM0csb0JBQW9CbW1CLDRCQUE0QjtZQUMzRDtZQUNBLElBQUkxZSx1QkFBdUIsSUFBSSxHQUFHO2dCQUM5QixPQUFPekgsb0JBQW9CLElBQUl1QixVQUFVO1lBQzdDO1lBQ0EsT0FBTzhDLHFCQUFxQixJQUFJLEVBQUVwRTtRQUN0QztRQUNBeWtCLFVBQVU1TyxhQUFhdFgsU0FBUyxFQUFFO1lBQzlCLElBQUksQ0FBQ21JLGlCQUFpQixJQUFJLEdBQUc7Z0JBQ3pCLE1BQU13Ziw0QkFBNEI7WUFDdEM7WUFDQSxNQUFNOVEsVUFBVUQscUJBQXFCVSxZQUFZO1lBQ2pELElBQUlULFFBQVFDLElBQUksS0FBSzlXLFdBQVc7Z0JBQzVCLE9BQU9vSSxtQ0FBbUMsSUFBSTtZQUNsRDtZQUNBLE9BQU82TyxnQ0FBZ0MsSUFBSTtRQUMvQztRQUNBMlEsWUFBWUMsWUFBWSxFQUFFdlEsYUFBYSxDQUFDLENBQUMsRUFBRTtZQUN2QyxJQUFJLENBQUNuUCxpQkFBaUIsSUFBSSxHQUFHO2dCQUN6QixNQUFNd2YsNEJBQTRCO1lBQ3RDO1lBQ0FwZ0IsdUJBQXVCc2dCLGNBQWMsR0FBRztZQUN4QyxNQUFNQyxZQUFZUiw0QkFBNEJPLGNBQWM7WUFDNUQsTUFBTWhSLFVBQVV1USxtQkFBbUI5UCxZQUFZO1lBQy9DLElBQUlyTyx1QkFBdUIsSUFBSSxHQUFHO2dCQUM5QixNQUFNLElBQUlsRyxVQUFVO1lBQ3hCO1lBQ0EsSUFBSTRXLHVCQUF1Qm1PLFVBQVVoSCxRQUFRLEdBQUc7Z0JBQzVDLE1BQU0sSUFBSS9kLFVBQVU7WUFDeEI7WUFDQSxNQUFNcEIsVUFBVW9mLHFCQUFxQixJQUFJLEVBQUUrRyxVQUFVaEgsUUFBUSxFQUFFakssUUFBUW9LLFlBQVksRUFBRXBLLFFBQVFxSyxZQUFZLEVBQUVySyxRQUFRdE0sYUFBYSxFQUFFc00sUUFBUW9JLE1BQU07WUFDaEo1YywwQkFBMEJWO1lBQzFCLE9BQU9tbUIsVUFBVVAsUUFBUTtRQUM3QjtRQUNBUSxPQUFPQyxXQUFXLEVBQUUxUSxhQUFhLENBQUMsQ0FBQyxFQUFFO1lBQ2pDLElBQUksQ0FBQ25QLGlCQUFpQixJQUFJLEdBQUc7Z0JBQ3pCLE9BQU8zRyxvQkFBb0JtbUIsNEJBQTRCO1lBQzNEO1lBQ0EsSUFBSUssZ0JBQWdCaG9CLFdBQVc7Z0JBQzNCLE9BQU93QixvQkFBb0IsQ0FBQyxvQ0FBb0MsQ0FBQztZQUNyRTtZQUNBLElBQUksQ0FBQ29YLGlCQUFpQm9QLGNBQWM7Z0JBQ2hDLE9BQU94bUIsb0JBQW9CLElBQUl1QixVQUFVLENBQUMseUVBQXlFLENBQUM7WUFDeEg7WUFDQSxJQUFJOFQ7WUFDSixJQUFJO2dCQUNBQSxVQUFVdVEsbUJBQW1COVAsWUFBWTtZQUM3QyxFQUNBLE9BQU83TixHQUFHO2dCQUNOLE9BQU9qSSxvQkFBb0JpSTtZQUMvQjtZQUNBLElBQUlSLHVCQUF1QixJQUFJLEdBQUc7Z0JBQzlCLE9BQU96SCxvQkFBb0IsSUFBSXVCLFVBQVU7WUFDN0M7WUFDQSxJQUFJNFcsdUJBQXVCcU8sY0FBYztnQkFDckMsT0FBT3htQixvQkFBb0IsSUFBSXVCLFVBQVU7WUFDN0M7WUFDQSxPQUFPZ2UscUJBQXFCLElBQUksRUFBRWlILGFBQWFuUixRQUFRb0ssWUFBWSxFQUFFcEssUUFBUXFLLFlBQVksRUFBRXJLLFFBQVF0TSxhQUFhLEVBQUVzTSxRQUFRb0ksTUFBTTtRQUNwSTtRQUNBOzs7Ozs7Ozs7O1NBVUMsR0FDRGdKLE1BQU07WUFDRixJQUFJLENBQUM5ZixpQkFBaUIsSUFBSSxHQUFHO2dCQUN6QixNQUFNd2YsNEJBQTRCO1lBQ3RDO1lBQ0EsTUFBTU8sV0FBV3BFLGtCQUFrQixJQUFJO1lBQ3ZDLE9BQU9sWSxvQkFBb0JzYztRQUMvQjtRQUNBQyxPQUFPN1EsYUFBYXRYLFNBQVMsRUFBRTtZQUMzQixJQUFJLENBQUNtSSxpQkFBaUIsSUFBSSxHQUFHO2dCQUN6QixNQUFNd2YsNEJBQTRCO1lBQ3RDO1lBQ0EsTUFBTTlRLFVBQVVzUSx1QkFBdUI3UCxZQUFZO1lBQ25ELE9BQU8vTCxtQ0FBbUMsSUFBSSxFQUFFc0wsUUFBUXRNLGFBQWE7UUFDekU7UUFDQTs7Ozs7U0FLQyxHQUNELE9BQU82ZCxLQUFLOUIsYUFBYSxFQUFFO1lBQ3ZCLE9BQU9ILG1CQUFtQkc7UUFDOUI7SUFDSjtJQUNBL2xCLE9BQU9zSixnQkFBZ0IsQ0FBQzJkLGdCQUFnQjtRQUNwQ1ksTUFBTTtZQUFFdGUsWUFBWTtRQUFLO0lBQzdCO0lBQ0F2SixPQUFPc0osZ0JBQWdCLENBQUMyZCxlQUFlem1CLFNBQVMsRUFBRTtRQUM5Q3FJLFFBQVE7WUFBRVUsWUFBWTtRQUFLO1FBQzNCb2MsV0FBVztZQUFFcGMsWUFBWTtRQUFLO1FBQzlCOGQsYUFBYTtZQUFFOWQsWUFBWTtRQUFLO1FBQ2hDaWUsUUFBUTtZQUFFamUsWUFBWTtRQUFLO1FBQzNCbWUsS0FBSztZQUFFbmUsWUFBWTtRQUFLO1FBQ3hCcWUsUUFBUTtZQUFFcmUsWUFBWTtRQUFLO1FBQzNCMlAsUUFBUTtZQUFFM1AsWUFBWTtRQUFLO0lBQy9CO0lBQ0ExSixnQkFBZ0JvbkIsZUFBZVksSUFBSSxFQUFFO0lBQ3JDaG9CLGdCQUFnQm9uQixlQUFlem1CLFNBQVMsQ0FBQ3FJLE1BQU0sRUFBRTtJQUNqRGhKLGdCQUFnQm9uQixlQUFlem1CLFNBQVMsQ0FBQ21sQixTQUFTLEVBQUU7SUFDcEQ5bEIsZ0JBQWdCb25CLGVBQWV6bUIsU0FBUyxDQUFDNm1CLFdBQVcsRUFBRTtJQUN0RHhuQixnQkFBZ0JvbkIsZUFBZXptQixTQUFTLENBQUNnbkIsTUFBTSxFQUFFO0lBQ2pEM25CLGdCQUFnQm9uQixlQUFlem1CLFNBQVMsQ0FBQ2tuQixHQUFHLEVBQUU7SUFDOUM3bkIsZ0JBQWdCb25CLGVBQWV6bUIsU0FBUyxDQUFDb25CLE1BQU0sRUFBRTtJQUNqRCxJQUFJLE9BQU94b0IsZUFBZW9LLFdBQVcsS0FBSyxVQUFVO1FBQ2hEeEosT0FBT0MsY0FBYyxDQUFDZ25CLGVBQWV6bUIsU0FBUyxFQUFFcEIsZUFBZW9LLFdBQVcsRUFBRTtZQUN4RXRKLE9BQU87WUFDUEMsY0FBYztRQUNsQjtJQUNKO0lBQ0EsSUFBSSxPQUFPZixlQUFlK04sYUFBYSxLQUFLLFVBQVU7UUFDbERuTixPQUFPQyxjQUFjLENBQUNnbkIsZUFBZXptQixTQUFTLEVBQUVwQixlQUFlK04sYUFBYSxFQUFFO1lBQzFFak4sT0FBTyttQixlQUFlem1CLFNBQVMsQ0FBQ29uQixNQUFNO1lBQ3RDckgsVUFBVTtZQUNWcGdCLGNBQWM7UUFDbEI7SUFDSjtJQUNBLDhDQUE4QztJQUM5QywrQ0FBK0M7SUFDL0MsU0FBU3drQixxQkFBcUJqUCxjQUFjLEVBQUVDLGFBQWEsRUFBRUMsZUFBZSxFQUFFQyxnQkFBZ0IsQ0FBQyxFQUFFbUQsZ0JBQWdCLElBQU0sQ0FBQztRQUNwSCxNQUFNblUsU0FBUzdFLE9BQU9rTCxNQUFNLENBQUMrYixlQUFlem1CLFNBQVM7UUFDckQybUIseUJBQXlCdGlCO1FBQ3pCLE1BQU1tTixhQUFhaFMsT0FBT2tMLE1BQU0sQ0FBQ3FYLGdDQUFnQy9oQixTQUFTO1FBQzFFNGlCLHFDQUFxQ3ZlLFFBQVFtTixZQUFZMEQsZ0JBQWdCQyxlQUFlQyxpQkFBaUJDLGVBQWVtRDtRQUN4SCxPQUFPblU7SUFDWDtJQUNBLCtDQUErQztJQUMvQyxTQUFTNGdCLHlCQUF5Qi9QLGNBQWMsRUFBRUMsYUFBYSxFQUFFQyxlQUFlO1FBQzVFLE1BQU0vUSxTQUFTN0UsT0FBT2tMLE1BQU0sQ0FBQytiLGVBQWV6bUIsU0FBUztRQUNyRDJtQix5QkFBeUJ0aUI7UUFDekIsTUFBTW1OLGFBQWFoUyxPQUFPa0wsTUFBTSxDQUFDNkUsNkJBQTZCdlAsU0FBUztRQUN2RWlWLGtDQUFrQzVRLFFBQVFtTixZQUFZMEQsZ0JBQWdCQyxlQUFlQyxpQkFBaUIsR0FBR25XO1FBQ3pHLE9BQU9vRjtJQUNYO0lBQ0EsU0FBU3NpQix5QkFBeUJ0aUIsTUFBTTtRQUNwQ0EsT0FBT0csTUFBTSxHQUFHO1FBQ2hCSCxPQUFPRSxPQUFPLEdBQUd0RjtRQUNqQm9GLE9BQU9PLFlBQVksR0FBRzNGO1FBQ3RCb0YsT0FBTzZFLFVBQVUsR0FBRztJQUN4QjtJQUNBLFNBQVM5QixpQkFBaUJqSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQ0QsYUFBYUMsSUFBSTtZQUNsQixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUNLLE9BQU9RLFNBQVMsQ0FBQ2lKLGNBQWMsQ0FBQ2xJLElBQUksQ0FBQzVCLEdBQUcsOEJBQThCO1lBQ3ZFLE9BQU87UUFDWDtRQUNBLE9BQU9BLGFBQWFzbkI7SUFDeEI7SUFDQSxTQUFTdmUsdUJBQXVCN0QsTUFBTTtRQUNsQyxJQUFJQSxPQUFPRSxPQUFPLEtBQUt0RixXQUFXO1lBQzlCLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBLDhDQUE4QztJQUM5QyxTQUFTNkYscUJBQXFCVCxNQUFNLEVBQUUzRCxNQUFNO1FBQ3hDMkQsT0FBTzZFLFVBQVUsR0FBRztRQUNwQixJQUFJN0UsT0FBT0csTUFBTSxLQUFLLFVBQVU7WUFDNUIsT0FBT2pFLG9CQUFvQnRCO1FBQy9CO1FBQ0EsSUFBSW9GLE9BQU9HLE1BQU0sS0FBSyxXQUFXO1lBQzdCLE9BQU8vRCxvQkFBb0I0RCxPQUFPTyxZQUFZO1FBQ2xEO1FBQ0E2TyxvQkFBb0JwUDtRQUNwQixNQUFNRCxTQUFTQyxPQUFPRSxPQUFPO1FBQzdCLElBQUlILFdBQVduRixhQUFhb1gsMkJBQTJCalMsU0FBUztZQUM1RCxNQUFNdVMsbUJBQW1CdlMsT0FBT2dTLGlCQUFpQjtZQUNqRGhTLE9BQU9nUyxpQkFBaUIsR0FBRyxJQUFJL1Q7WUFDL0JzVSxpQkFBaUJuVCxPQUFPLENBQUNzUSxDQUFBQTtnQkFDckJBLGdCQUFnQmpNLFdBQVcsQ0FBQzVJO1lBQ2hDO1FBQ0o7UUFDQSxNQUFNcW9CLHNCQUFzQmpqQixPQUFPYSx5QkFBeUIsQ0FBQ2xCLFlBQVksQ0FBQ3REO1FBQzFFLE9BQU9TLHFCQUFxQm1tQixxQkFBcUJ0b0I7SUFDckQ7SUFDQSxTQUFTeVUsb0JBQW9CcFAsTUFBTTtRQUMvQkEsT0FBT0csTUFBTSxHQUFHO1FBQ2hCLE1BQU1KLFNBQVNDLE9BQU9FLE9BQU87UUFDN0IsSUFBSUgsV0FBV25GLFdBQVc7WUFDdEI7UUFDSjtRQUNBc0csa0NBQWtDbkI7UUFDbEMsSUFBSTZELDhCQUE4QjdELFNBQVM7WUFDdkMsTUFBTWdGLGVBQWVoRixPQUFPcUQsYUFBYTtZQUN6Q3JELE9BQU9xRCxhQUFhLEdBQUcsSUFBSXBGO1lBQzNCK0csYUFBYTVGLE9BQU8sQ0FBQ2dFLENBQUFBO2dCQUNqQkEsWUFBWUssV0FBVztZQUMzQjtRQUNKO0lBQ0o7SUFDQSxTQUFTK00sb0JBQW9CdlEsTUFBTSxFQUFFcUUsQ0FBQztRQUNsQ3JFLE9BQU9HLE1BQU0sR0FBRztRQUNoQkgsT0FBT08sWUFBWSxHQUFHOEQ7UUFDdEIsTUFBTXRFLFNBQVNDLE9BQU9FLE9BQU87UUFDN0IsSUFBSUgsV0FBV25GLFdBQVc7WUFDdEI7UUFDSjtRQUNBK0YsaUNBQWlDWixRQUFRc0U7UUFDekMsSUFBSVQsOEJBQThCN0QsU0FBUztZQUN2QytFLDZDQUE2Qy9FLFFBQVFzRTtRQUN6RCxPQUNLO1lBQ0RnTyw4Q0FBOEN0UyxRQUFRc0U7UUFDMUQ7SUFDSjtJQUNBLDJDQUEyQztJQUMzQyxTQUFTa2UsNEJBQTRCcm5CLElBQUk7UUFDckMsT0FBTyxJQUFJeUMsVUFBVSxDQUFDLHlCQUF5QixFQUFFekMsS0FBSyxxQ0FBcUMsQ0FBQztJQUNoRztJQUVBLFNBQVNnb0IsMkJBQTJCdFEsSUFBSSxFQUFFN1EsT0FBTztRQUM3Q0YsaUJBQWlCK1EsTUFBTTdRO1FBQ3ZCLE1BQU1pUCxnQkFBZ0I0QixTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSzVCLGFBQWE7UUFDcEYzTyxvQkFBb0IyTyxlQUFlLGlCQUFpQjtRQUNwRCxPQUFPO1lBQ0hBLGVBQWV6TywwQkFBMEJ5TztRQUM3QztJQUNKO0lBRUEsNEVBQTRFO0lBQzVFLE1BQU1tUyx5QkFBeUIsQ0FBQzdmO1FBQzVCLE9BQU9BLE1BQU1tRSxVQUFVO0lBQzNCO0lBQ0F6TSxnQkFBZ0Jtb0Isd0JBQXdCO0lBQ3hDOzs7O0tBSUMsR0FDRCxNQUFNQztRQUNGbmxCLFlBQVl3VCxPQUFPLENBQUU7WUFDakJ0UCx1QkFBdUJzUCxTQUFTLEdBQUc7WUFDbkNBLFVBQVV5UiwyQkFBMkJ6UixTQUFTO1lBQzlDLElBQUksQ0FBQzRSLHVDQUF1QyxHQUFHNVIsUUFBUVQsYUFBYTtRQUN4RTtRQUNBOztTQUVDLEdBQ0QsSUFBSUEsZ0JBQWdCO1lBQ2hCLElBQUksQ0FBQ3NTLDRCQUE0QixJQUFJLEdBQUc7Z0JBQ3BDLE1BQU1DLDhCQUE4QjtZQUN4QztZQUNBLE9BQU8sSUFBSSxDQUFDRix1Q0FBdUM7UUFDdkQ7UUFDQTs7U0FFQyxHQUNELElBQUkzWixPQUFPO1lBQ1AsSUFBSSxDQUFDNFosNEJBQTRCLElBQUksR0FBRztnQkFDcEMsTUFBTUMsOEJBQThCO1lBQ3hDO1lBQ0EsT0FBT0o7UUFDWDtJQUNKO0lBQ0Fob0IsT0FBT3NKLGdCQUFnQixDQUFDMmUsMEJBQTBCem5CLFNBQVMsRUFBRTtRQUN6RHFWLGVBQWU7WUFBRXRNLFlBQVk7UUFBSztRQUNsQ2dGLE1BQU07WUFBRWhGLFlBQVk7UUFBSztJQUM3QjtJQUNBLElBQUksT0FBT25LLGVBQWVvSyxXQUFXLEtBQUssVUFBVTtRQUNoRHhKLE9BQU9DLGNBQWMsQ0FBQ2dvQiwwQkFBMEJ6bkIsU0FBUyxFQUFFcEIsZUFBZW9LLFdBQVcsRUFBRTtZQUNuRnRKLE9BQU87WUFDUEMsY0FBYztRQUNsQjtJQUNKO0lBQ0Esc0RBQXNEO0lBQ3RELFNBQVNpb0IsOEJBQThCcm9CLElBQUk7UUFDdkMsT0FBTyxJQUFJeUMsVUFBVSxDQUFDLG9DQUFvQyxFQUFFekMsS0FBSyxnREFBZ0QsQ0FBQztJQUN0SDtJQUNBLFNBQVNvb0IsNEJBQTRCeG9CLENBQUM7UUFDbEMsSUFBSSxDQUFDRCxhQUFhQyxJQUFJO1lBQ2xCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0ssT0FBT1EsU0FBUyxDQUFDaUosY0FBYyxDQUFDbEksSUFBSSxDQUFDNUIsR0FBRyw0Q0FBNEM7WUFDckYsT0FBTztRQUNYO1FBQ0EsT0FBT0EsYUFBYXNvQjtJQUN4QjtJQUVBLDRFQUE0RTtJQUM1RSxNQUFNSSxvQkFBb0I7UUFDdEIsT0FBTztJQUNYO0lBQ0F4b0IsZ0JBQWdCd29CLG1CQUFtQjtJQUNuQzs7OztLQUlDLEdBQ0QsTUFBTUM7UUFDRnhsQixZQUFZd1QsT0FBTyxDQUFFO1lBQ2pCdFAsdUJBQXVCc1AsU0FBUyxHQUFHO1lBQ25DQSxVQUFVeVIsMkJBQTJCelIsU0FBUztZQUM5QyxJQUFJLENBQUNpUyxrQ0FBa0MsR0FBR2pTLFFBQVFULGFBQWE7UUFDbkU7UUFDQTs7U0FFQyxHQUNELElBQUlBLGdCQUFnQjtZQUNoQixJQUFJLENBQUMyUyx1QkFBdUIsSUFBSSxHQUFHO2dCQUMvQixNQUFNQyx5QkFBeUI7WUFDbkM7WUFDQSxPQUFPLElBQUksQ0FBQ0Ysa0NBQWtDO1FBQ2xEO1FBQ0E7OztTQUdDLEdBQ0QsSUFBSWhhLE9BQU87WUFDUCxJQUFJLENBQUNpYSx1QkFBdUIsSUFBSSxHQUFHO2dCQUMvQixNQUFNQyx5QkFBeUI7WUFDbkM7WUFDQSxPQUFPSjtRQUNYO0lBQ0o7SUFDQXJvQixPQUFPc0osZ0JBQWdCLENBQUNnZixxQkFBcUI5bkIsU0FBUyxFQUFFO1FBQ3BEcVYsZUFBZTtZQUFFdE0sWUFBWTtRQUFLO1FBQ2xDZ0YsTUFBTTtZQUFFaEYsWUFBWTtRQUFLO0lBQzdCO0lBQ0EsSUFBSSxPQUFPbkssZUFBZW9LLFdBQVcsS0FBSyxVQUFVO1FBQ2hEeEosT0FBT0MsY0FBYyxDQUFDcW9CLHFCQUFxQjluQixTQUFTLEVBQUVwQixlQUFlb0ssV0FBVyxFQUFFO1lBQzlFdEosT0FBTztZQUNQQyxjQUFjO1FBQ2xCO0lBQ0o7SUFDQSxpREFBaUQ7SUFDakQsU0FBU3NvQix5QkFBeUIxb0IsSUFBSTtRQUNsQyxPQUFPLElBQUl5QyxVQUFVLENBQUMsK0JBQStCLEVBQUV6QyxLQUFLLDJDQUEyQyxDQUFDO0lBQzVHO0lBQ0EsU0FBU3lvQix1QkFBdUI3b0IsQ0FBQztRQUM3QixJQUFJLENBQUNELGFBQWFDLElBQUk7WUFDbEIsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDSyxPQUFPUSxTQUFTLENBQUNpSixjQUFjLENBQUNsSSxJQUFJLENBQUM1QixHQUFHLHVDQUF1QztZQUNoRixPQUFPO1FBQ1g7UUFDQSxPQUFPQSxhQUFhMm9CO0lBQ3hCO0lBRUEsU0FBU0ksbUJBQW1COVEsUUFBUSxFQUFFaFIsT0FBTztRQUN6Q0YsaUJBQWlCa1IsVUFBVWhSO1FBQzNCLE1BQU1pQyxTQUFTK08sYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVMvTyxNQUFNO1FBQ2xGLE1BQU04ZixRQUFRL1EsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVMrUSxLQUFLO1FBQ2hGLE1BQU1DLGVBQWVoUixhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU2dSLFlBQVk7UUFDOUYsTUFBTTFTLFFBQVEwQixhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBUzFCLEtBQUs7UUFDaEYsTUFBTXFSLFlBQVkzUCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBUzJQLFNBQVM7UUFDeEYsTUFBTXNCLGVBQWVqUixhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU2lSLFlBQVk7UUFDOUYsT0FBTztZQUNIaGdCLFFBQVFBLFdBQVdwSixZQUNmQSxZQUNBcXBCLGlDQUFpQ2pnQixRQUFRK08sVUFBVSxDQUFDLEVBQUVoUixRQUFRLHlCQUF5QixDQUFDO1lBQzVGK2hCLE9BQU9BLFVBQVVscEIsWUFDYkEsWUFDQXNwQixnQ0FBZ0NKLE9BQU8vUSxVQUFVLENBQUMsRUFBRWhSLFFBQVEsd0JBQXdCLENBQUM7WUFDekZnaUI7WUFDQTFTLE9BQU9BLFVBQVV6VyxZQUNiQSxZQUNBdXBCLGdDQUFnQzlTLE9BQU8wQixVQUFVLENBQUMsRUFBRWhSLFFBQVEsd0JBQXdCLENBQUM7WUFDekYyZ0IsV0FBV0EsY0FBYzluQixZQUNyQkEsWUFDQXdwQixvQ0FBb0MxQixXQUFXM1AsVUFBVSxDQUFDLEVBQUVoUixRQUFRLDRCQUE0QixDQUFDO1lBQ3JHaWlCO1FBQ0o7SUFDSjtJQUNBLFNBQVNFLGdDQUFnQ2pwQixFQUFFLEVBQUU4WCxRQUFRLEVBQUVoUixPQUFPO1FBQzFEQyxlQUFlL0csSUFBSThHO1FBQ25CLE9BQU8sQ0FBQ29MLGFBQWVyUCxZQUFZN0MsSUFBSThYLFVBQVU7Z0JBQUM1RjthQUFXO0lBQ2pFO0lBQ0EsU0FBU2dYLGdDQUFnQ2xwQixFQUFFLEVBQUU4WCxRQUFRLEVBQUVoUixPQUFPO1FBQzFEQyxlQUFlL0csSUFBSThHO1FBQ25CLE9BQU8sQ0FBQ29MLGFBQWU1UCxZQUFZdEMsSUFBSThYLFVBQVU7Z0JBQUM1RjthQUFXO0lBQ2pFO0lBQ0EsU0FBU2lYLG9DQUFvQ25wQixFQUFFLEVBQUU4WCxRQUFRLEVBQUVoUixPQUFPO1FBQzlEQyxlQUFlL0csSUFBSThHO1FBQ25CLE9BQU8sQ0FBQ3VCLE9BQU82SixhQUFlclAsWUFBWTdDLElBQUk4WCxVQUFVO2dCQUFDelA7Z0JBQU82SjthQUFXO0lBQy9FO0lBQ0EsU0FBUzhXLGlDQUFpQ2hwQixFQUFFLEVBQUU4WCxRQUFRLEVBQUVoUixPQUFPO1FBQzNEQyxlQUFlL0csSUFBSThHO1FBQ25CLE9BQU8sQ0FBQzFGLFNBQVd5QixZQUFZN0MsSUFBSThYLFVBQVU7Z0JBQUMxVzthQUFPO0lBQ3pEO0lBRUEsd0JBQXdCO0lBQ3hCOzs7Ozs7O0tBT0MsR0FDRCxNQUFNZ29CO1FBQ0ZwbUIsWUFBWXFtQixpQkFBaUIsQ0FBQyxDQUFDLEVBQUVDLHNCQUFzQixDQUFDLENBQUMsRUFBRUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFFO1lBQ2pGLElBQUlGLG1CQUFtQjFwQixXQUFXO2dCQUM5QjBwQixpQkFBaUI7WUFDckI7WUFDQSxNQUFNRyxtQkFBbUI5Uix1QkFBdUI0UixxQkFBcUI7WUFDckUsTUFBTUcsbUJBQW1CL1IsdUJBQXVCNlIscUJBQXFCO1lBQ3JFLE1BQU1HLGNBQWNkLG1CQUFtQlMsZ0JBQWdCO1lBQ3ZELElBQUlLLFlBQVlaLFlBQVksS0FBS25wQixXQUFXO2dCQUN4QyxNQUFNLElBQUlpUCxXQUFXO1lBQ3pCO1lBQ0EsSUFBSThhLFlBQVlYLFlBQVksS0FBS3BwQixXQUFXO2dCQUN4QyxNQUFNLElBQUlpUCxXQUFXO1lBQ3pCO1lBQ0EsTUFBTSthLHdCQUF3QnJTLHFCQUFxQm1TLGtCQUFrQjtZQUNyRSxNQUFNRyx3QkFBd0JuUyxxQkFBcUJnUztZQUNuRCxNQUFNSSx3QkFBd0J2UyxxQkFBcUJrUyxrQkFBa0I7WUFDckUsTUFBTU0sd0JBQXdCclMscUJBQXFCK1I7WUFDbkQsSUFBSU87WUFDSixNQUFNMUssZUFBZXRlLFdBQVdHLENBQUFBO2dCQUM1QjZvQix1QkFBdUI3b0I7WUFDM0I7WUFDQThvQiwwQkFBMEIsSUFBSSxFQUFFM0ssY0FBY3dLLHVCQUF1QkMsdUJBQXVCSCx1QkFBdUJDO1lBQ25ISyxxREFBcUQsSUFBSSxFQUFFUDtZQUMzRCxJQUFJQSxZQUFZdFQsS0FBSyxLQUFLelcsV0FBVztnQkFDakNvcUIscUJBQXFCTCxZQUFZdFQsS0FBSyxDQUFDLElBQUksQ0FBQzhULDBCQUEwQjtZQUMxRSxPQUNLO2dCQUNESCxxQkFBcUJwcUI7WUFDekI7UUFDSjtRQUNBOztTQUVDLEdBQ0QsSUFBSXVuQixXQUFXO1lBQ1gsSUFBSSxDQUFDaUQsa0JBQWtCLElBQUksR0FBRztnQkFDMUIsTUFBTUMsMEJBQTBCO1lBQ3BDO1lBQ0EsT0FBTyxJQUFJLENBQUNDLFNBQVM7UUFDekI7UUFDQTs7U0FFQyxHQUNELElBQUk1SixXQUFXO1lBQ1gsSUFBSSxDQUFDMEosa0JBQWtCLElBQUksR0FBRztnQkFDMUIsTUFBTUMsMEJBQTBCO1lBQ3BDO1lBQ0EsT0FBTyxJQUFJLENBQUNFLFNBQVM7UUFDekI7SUFDSjtJQUNBcHFCLE9BQU9zSixnQkFBZ0IsQ0FBQzRmLGdCQUFnQjFvQixTQUFTLEVBQUU7UUFDL0N3bUIsVUFBVTtZQUFFemQsWUFBWTtRQUFLO1FBQzdCZ1gsVUFBVTtZQUFFaFgsWUFBWTtRQUFLO0lBQ2pDO0lBQ0EsSUFBSSxPQUFPbkssZUFBZW9LLFdBQVcsS0FBSyxVQUFVO1FBQ2hEeEosT0FBT0MsY0FBYyxDQUFDaXBCLGdCQUFnQjFvQixTQUFTLEVBQUVwQixlQUFlb0ssV0FBVyxFQUFFO1lBQ3pFdEosT0FBTztZQUNQQyxjQUFjO1FBQ2xCO0lBQ0o7SUFDQSxTQUFTMnBCLDBCQUEwQmpsQixNQUFNLEVBQUVzYSxZQUFZLEVBQUV3SyxxQkFBcUIsRUFBRUMscUJBQXFCLEVBQUVILHFCQUFxQixFQUFFQyxxQkFBcUI7UUFDL0ksU0FBU2hVO1lBQ0wsT0FBT3lKO1FBQ1g7UUFDQSxTQUFTdkYsZUFBZXpSLEtBQUs7WUFDekIsT0FBT2tpQix5Q0FBeUN4bEIsUUFBUXNEO1FBQzVEO1FBQ0EsU0FBUzJSLGVBQWU1WSxNQUFNO1lBQzFCLE9BQU9vcEIseUNBQXlDemxCLFFBQVEzRDtRQUM1RDtRQUNBLFNBQVMyWTtZQUNMLE9BQU8wUSx5Q0FBeUMxbEI7UUFDcEQ7UUFDQUEsT0FBT3VsQixTQUFTLEdBQUd6USxxQkFBcUJqRSxnQkFBZ0JrRSxnQkFBZ0JDLGdCQUFnQkMsZ0JBQWdCNlAsdUJBQXVCQztRQUMvSCxTQUFTalU7WUFDTCxPQUFPNlUsMENBQTBDM2xCO1FBQ3JEO1FBQ0EsU0FBUytRLGdCQUFnQjFVLE1BQU07WUFDM0IsT0FBT3VwQiw0Q0FBNEM1bEIsUUFBUTNEO1FBQy9EO1FBQ0EyRCxPQUFPc2xCLFNBQVMsR0FBR3hGLHFCQUFxQmpQLGdCQUFnQkMsZUFBZUMsaUJBQWlCNlQsdUJBQXVCQztRQUMvRyxpSEFBaUg7UUFDakg3a0IsT0FBTzJWLGFBQWEsR0FBRy9hO1FBQ3ZCb0YsT0FBTzZsQiwwQkFBMEIsR0FBR2pyQjtRQUNwQ29GLE9BQU84bEIsa0NBQWtDLEdBQUdsckI7UUFDNUNtckIsK0JBQStCL2xCLFFBQVE7UUFDdkNBLE9BQU9tbEIsMEJBQTBCLEdBQUd2cUI7SUFDeEM7SUFDQSxTQUFTd3FCLGtCQUFrQnRxQixDQUFDO1FBQ3hCLElBQUksQ0FBQ0QsYUFBYUMsSUFBSTtZQUNsQixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUNLLE9BQU9RLFNBQVMsQ0FBQ2lKLGNBQWMsQ0FBQ2xJLElBQUksQ0FBQzVCLEdBQUcsK0JBQStCO1lBQ3hFLE9BQU87UUFDWDtRQUNBLE9BQU9BLGFBQWF1cEI7SUFDeEI7SUFDQSxxREFBcUQ7SUFDckQsU0FBUzJCLHFCQUFxQmhtQixNQUFNLEVBQUVxRSxDQUFDO1FBQ25DNFoscUNBQXFDamUsT0FBT3NsQixTQUFTLENBQUN6a0IseUJBQXlCLEVBQUV3RDtRQUNqRjRoQiw0Q0FBNENqbUIsUUFBUXFFO0lBQ3hEO0lBQ0EsU0FBUzRoQiw0Q0FBNENqbUIsTUFBTSxFQUFFcUUsQ0FBQztRQUMxRDZoQixnREFBZ0RsbUIsT0FBT21sQiwwQkFBMEI7UUFDakYxSyw2Q0FBNkN6YSxPQUFPdWxCLFNBQVMsQ0FBQ2xRLHlCQUF5QixFQUFFaFI7UUFDekY4aEIsNEJBQTRCbm1CO0lBQ2hDO0lBQ0EsU0FBU21tQiw0QkFBNEJubUIsTUFBTTtRQUN2QyxJQUFJQSxPQUFPMlYsYUFBYSxFQUFFO1lBQ3RCLG1IQUFtSDtZQUNuSCxvSEFBb0g7WUFDcEgsd0JBQXdCO1lBQ3hCb1EsK0JBQStCL2xCLFFBQVE7UUFDM0M7SUFDSjtJQUNBLFNBQVMrbEIsK0JBQStCL2xCLE1BQU0sRUFBRTJYLFlBQVk7UUFDeEQsK0NBQStDO1FBQy9DLElBQUkzWCxPQUFPNmxCLDBCQUEwQixLQUFLanJCLFdBQVc7WUFDakRvRixPQUFPOGxCLGtDQUFrQztRQUM3QztRQUNBOWxCLE9BQU82bEIsMEJBQTBCLEdBQUc3cEIsV0FBV0csQ0FBQUE7WUFDM0M2RCxPQUFPOGxCLGtDQUFrQyxHQUFHM3BCO1FBQ2hEO1FBQ0E2RCxPQUFPMlYsYUFBYSxHQUFHZ0M7SUFDM0I7SUFDQSx5Q0FBeUM7SUFDekM7Ozs7S0FJQyxHQUNELE1BQU15TztRQUNGbm9CLGFBQWM7WUFDVixNQUFNLElBQUlOLFVBQVU7UUFDeEI7UUFDQTs7U0FFQyxHQUNELElBQUk0TixjQUFjO1lBQ2QsSUFBSSxDQUFDOGEsbUNBQW1DLElBQUksR0FBRztnQkFDM0MsTUFBTUMscUNBQXFDO1lBQy9DO1lBQ0EsTUFBTUMscUJBQXFCLElBQUksQ0FBQ0MsMEJBQTBCLENBQUNsQixTQUFTLENBQUN6a0IseUJBQXlCO1lBQzlGLE9BQU9nZCw4Q0FBOEMwSTtRQUN6RDtRQUNBemEsUUFBUXhJLFFBQVExSSxTQUFTLEVBQUU7WUFDdkIsSUFBSSxDQUFDeXJCLG1DQUFtQyxJQUFJLEdBQUc7Z0JBQzNDLE1BQU1DLHFDQUFxQztZQUMvQztZQUNBRyx3Q0FBd0MsSUFBSSxFQUFFbmpCO1FBQ2xEO1FBQ0E7OztTQUdDLEdBQ0QwSSxNQUFNM1AsU0FBU3pCLFNBQVMsRUFBRTtZQUN0QixJQUFJLENBQUN5ckIsbUNBQW1DLElBQUksR0FBRztnQkFDM0MsTUFBTUMscUNBQXFDO1lBQy9DO1lBQ0FJLHNDQUFzQyxJQUFJLEVBQUVycUI7UUFDaEQ7UUFDQTs7O1NBR0MsR0FDRHNxQixZQUFZO1lBQ1IsSUFBSSxDQUFDTixtQ0FBbUMsSUFBSSxHQUFHO2dCQUMzQyxNQUFNQyxxQ0FBcUM7WUFDL0M7WUFDQU0sMENBQTBDLElBQUk7UUFDbEQ7SUFDSjtJQUNBenJCLE9BQU9zSixnQkFBZ0IsQ0FBQzJoQixpQ0FBaUN6cUIsU0FBUyxFQUFFO1FBQ2hFbVEsU0FBUztZQUFFcEgsWUFBWTtRQUFLO1FBQzVCc0gsT0FBTztZQUFFdEgsWUFBWTtRQUFLO1FBQzFCaWlCLFdBQVc7WUFBRWppQixZQUFZO1FBQUs7UUFDOUI2RyxhQUFhO1lBQUU3RyxZQUFZO1FBQUs7SUFDcEM7SUFDQTFKLGdCQUFnQm9yQixpQ0FBaUN6cUIsU0FBUyxDQUFDbVEsT0FBTyxFQUFFO0lBQ3BFOVEsZ0JBQWdCb3JCLGlDQUFpQ3pxQixTQUFTLENBQUNxUSxLQUFLLEVBQUU7SUFDbEVoUixnQkFBZ0JvckIsaUNBQWlDenFCLFNBQVMsQ0FBQ2dyQixTQUFTLEVBQUU7SUFDdEUsSUFBSSxPQUFPcHNCLGVBQWVvSyxXQUFXLEtBQUssVUFBVTtRQUNoRHhKLE9BQU9DLGNBQWMsQ0FBQ2dyQixpQ0FBaUN6cUIsU0FBUyxFQUFFcEIsZUFBZW9LLFdBQVcsRUFBRTtZQUMxRnRKLE9BQU87WUFDUEMsY0FBYztRQUNsQjtJQUNKO0lBQ0EsMERBQTBEO0lBQzFELFNBQVMrcUIsbUNBQW1DdnJCLENBQUM7UUFDekMsSUFBSSxDQUFDRCxhQUFhQyxJQUFJO1lBQ2xCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0ssT0FBT1EsU0FBUyxDQUFDaUosY0FBYyxDQUFDbEksSUFBSSxDQUFDNUIsR0FBRywrQkFBK0I7WUFDeEUsT0FBTztRQUNYO1FBQ0EsT0FBT0EsYUFBYXNyQjtJQUN4QjtJQUNBLFNBQVNTLHNDQUFzQzdtQixNQUFNLEVBQUVtTixVQUFVLEVBQUUyWixrQkFBa0IsRUFBRUMsY0FBYyxFQUFFaFcsZUFBZTtRQUNsSDVELFdBQVdxWiwwQkFBMEIsR0FBR3htQjtRQUN4Q0EsT0FBT21sQiwwQkFBMEIsR0FBR2hZO1FBQ3BDQSxXQUFXNlosbUJBQW1CLEdBQUdGO1FBQ2pDM1osV0FBVzhaLGVBQWUsR0FBR0Y7UUFDN0I1WixXQUFXaEIsZ0JBQWdCLEdBQUc0RTtRQUM5QjVELFdBQVcrWixjQUFjLEdBQUd0c0I7UUFDNUJ1UyxXQUFXZ2Esc0JBQXNCLEdBQUd2c0I7UUFDcEN1UyxXQUFXaWEscUJBQXFCLEdBQUd4c0I7SUFDdkM7SUFDQSxTQUFTc3FCLHFEQUFxRGxsQixNQUFNLEVBQUUya0IsV0FBVztRQUM3RSxNQUFNeFgsYUFBYWhTLE9BQU9rTCxNQUFNLENBQUMrZixpQ0FBaUN6cUIsU0FBUztRQUMzRSxJQUFJbXJCO1FBQ0osSUFBSUM7UUFDSixJQUFJaFc7UUFDSixJQUFJNFQsWUFBWWpDLFNBQVMsS0FBSzluQixXQUFXO1lBQ3JDa3NCLHFCQUFxQnhqQixDQUFBQSxRQUFTcWhCLFlBQVlqQyxTQUFTLENBQUNwZixPQUFPNko7UUFDL0QsT0FDSztZQUNEMloscUJBQXFCeGpCLENBQUFBO2dCQUNqQixJQUFJO29CQUNBbWpCLHdDQUF3Q3RaLFlBQVk3SjtvQkFDcEQsT0FBT3BILG9CQUFvQnRCO2dCQUMvQixFQUNBLE9BQU95c0Isa0JBQWtCO29CQUNyQixPQUFPanJCLG9CQUFvQmlyQjtnQkFDL0I7WUFDSjtRQUNKO1FBQ0EsSUFBSTFDLFlBQVliLEtBQUssS0FBS2xwQixXQUFXO1lBQ2pDbXNCLGlCQUFpQixJQUFNcEMsWUFBWWIsS0FBSyxDQUFDM1c7UUFDN0MsT0FDSztZQUNENFosaUJBQWlCLElBQU03cUIsb0JBQW9CdEI7UUFDL0M7UUFDQSxJQUFJK3BCLFlBQVkzZ0IsTUFBTSxLQUFLcEosV0FBVztZQUNsQ21XLGtCQUFrQjFVLENBQUFBLFNBQVVzb0IsWUFBWTNnQixNQUFNLENBQUMzSDtRQUNuRCxPQUNLO1lBQ0QwVSxrQkFBa0IsSUFBTTdVLG9CQUFvQnRCO1FBQ2hEO1FBQ0Fpc0Isc0NBQXNDN21CLFFBQVFtTixZQUFZMlosb0JBQW9CQyxnQkFBZ0JoVztJQUNsRztJQUNBLFNBQVNtVixnREFBZ0QvWSxVQUFVO1FBQy9EQSxXQUFXNlosbUJBQW1CLEdBQUdwc0I7UUFDakN1UyxXQUFXOFosZUFBZSxHQUFHcnNCO1FBQzdCdVMsV0FBV2hCLGdCQUFnQixHQUFHdlI7SUFDbEM7SUFDQSxTQUFTNnJCLHdDQUF3Q3RaLFVBQVUsRUFBRTdKLEtBQUs7UUFDOUQsTUFBTXRELFNBQVNtTixXQUFXcVosMEJBQTBCO1FBQ3BELE1BQU1ELHFCQUFxQnZtQixPQUFPc2xCLFNBQVMsQ0FBQ3prQix5QkFBeUI7UUFDckUsSUFBSSxDQUFDaWQsaURBQWlEeUkscUJBQXFCO1lBQ3ZFLE1BQU0sSUFBSTVvQixVQUFVO1FBQ3hCO1FBQ0Esa0dBQWtHO1FBQ2xHLDBEQUEwRDtRQUMxRCxJQUFJO1lBQ0FxZ0IsdUNBQXVDdUksb0JBQW9CampCO1FBQy9ELEVBQ0EsT0FBT2UsR0FBRztZQUNOLG9EQUFvRDtZQUNwRDRoQiw0Q0FBNENqbUIsUUFBUXFFO1lBQ3BELE1BQU1yRSxPQUFPc2xCLFNBQVMsQ0FBQy9rQixZQUFZO1FBQ3ZDO1FBQ0EsTUFBTW9YLGVBQWUyRywrQ0FBK0NpSTtRQUNwRSxJQUFJNU8saUJBQWlCM1gsT0FBTzJWLGFBQWEsRUFBRTtZQUN2Q29RLCtCQUErQi9sQixRQUFRO1FBQzNDO0lBQ0o7SUFDQSxTQUFTMG1CLHNDQUFzQ3ZaLFVBQVUsRUFBRTlJLENBQUM7UUFDeEQyaEIscUJBQXFCN1ksV0FBV3FaLDBCQUEwQixFQUFFbmlCO0lBQ2hFO0lBQ0EsU0FBU2lqQixpREFBaURuYSxVQUFVLEVBQUU3SixLQUFLO1FBQ3ZFLE1BQU1pa0IsbUJBQW1CcGEsV0FBVzZaLG1CQUFtQixDQUFDMWpCO1FBQ3hELE9BQU94RyxxQkFBcUJ5cUIsa0JBQWtCM3NCLFdBQVdzVyxDQUFBQTtZQUNyRDhVLHFCQUFxQjdZLFdBQVdxWiwwQkFBMEIsRUFBRXRWO1lBQzVELE1BQU1BO1FBQ1Y7SUFDSjtJQUNBLFNBQVMwViwwQ0FBMEN6WixVQUFVO1FBQ3pELE1BQU1uTixTQUFTbU4sV0FBV3FaLDBCQUEwQjtRQUNwRCxNQUFNRCxxQkFBcUJ2bUIsT0FBT3NsQixTQUFTLENBQUN6a0IseUJBQXlCO1FBQ3JFa2QscUNBQXFDd0k7UUFDckMsTUFBTXZhLFFBQVEsSUFBSXJPLFVBQVU7UUFDNUJzb0IsNENBQTRDam1CLFFBQVFnTTtJQUN4RDtJQUNBLHdDQUF3QztJQUN4QyxTQUFTd1oseUNBQXlDeGxCLE1BQU0sRUFBRXNELEtBQUs7UUFDM0QsTUFBTTZKLGFBQWFuTixPQUFPbWxCLDBCQUEwQjtRQUNwRCxJQUFJbmxCLE9BQU8yVixhQUFhLEVBQUU7WUFDdEIsTUFBTTZSLDRCQUE0QnhuQixPQUFPNmxCLDBCQUEwQjtZQUNuRSxPQUFPL29CLHFCQUFxQjBxQiwyQkFBMkI7Z0JBQ25ELE1BQU05TCxXQUFXMWIsT0FBT3VsQixTQUFTO2dCQUNqQyxNQUFNNVosUUFBUStQLFNBQVN2YixNQUFNO2dCQUM3QixJQUFJd0wsVUFBVSxZQUFZO29CQUN0QixNQUFNK1AsU0FBU25iLFlBQVk7Z0JBQy9CO2dCQUNBLE9BQU8rbUIsaURBQWlEbmEsWUFBWTdKO1lBQ3hFO1FBQ0o7UUFDQSxPQUFPZ2tCLGlEQUFpRG5hLFlBQVk3SjtJQUN4RTtJQUNBLFNBQVNtaUIseUNBQXlDemxCLE1BQU0sRUFBRTNELE1BQU07UUFDNUQsTUFBTThRLGFBQWFuTixPQUFPbWxCLDBCQUEwQjtRQUNwRCxJQUFJaFksV0FBVytaLGNBQWMsS0FBS3RzQixXQUFXO1lBQ3pDLE9BQU91UyxXQUFXK1osY0FBYztRQUNwQztRQUNBLHVHQUF1RztRQUN2RyxNQUFNL0UsV0FBV25pQixPQUFPc2xCLFNBQVM7UUFDakMsZ0dBQWdHO1FBQ2hHLDJDQUEyQztRQUMzQ25ZLFdBQVcrWixjQUFjLEdBQUdsckIsV0FBVyxDQUFDRyxTQUFTTDtZQUM3Q3FSLFdBQVdnYSxzQkFBc0IsR0FBR2hyQjtZQUNwQ2dSLFdBQVdpYSxxQkFBcUIsR0FBR3RyQjtRQUN2QztRQUNBLE1BQU15akIsZ0JBQWdCcFMsV0FBV2hCLGdCQUFnQixDQUFDOVA7UUFDbEQ2cEIsZ0RBQWdEL1k7UUFDaER4USxZQUFZNGlCLGVBQWU7WUFDdkIsSUFBSTRDLFNBQVNoaUIsTUFBTSxLQUFLLFdBQVc7Z0JBQy9Cc25CLHFDQUFxQ3RhLFlBQVlnVixTQUFTNWhCLFlBQVk7WUFDMUUsT0FDSztnQkFDRDBkLHFDQUFxQ2tFLFNBQVN0aEIseUJBQXlCLEVBQUV4RTtnQkFDekVxckIsc0NBQXNDdmE7WUFDMUM7WUFDQSxPQUFPO1FBQ1gsR0FBRytELENBQUFBO1lBQ0MrTSxxQ0FBcUNrRSxTQUFTdGhCLHlCQUF5QixFQUFFcVE7WUFDekV1VyxxQ0FBcUN0YSxZQUFZK0Q7WUFDakQsT0FBTztRQUNYO1FBQ0EsT0FBTy9ELFdBQVcrWixjQUFjO0lBQ3BDO0lBQ0EsU0FBU3hCLHlDQUF5QzFsQixNQUFNO1FBQ3BELE1BQU1tTixhQUFhbk4sT0FBT21sQiwwQkFBMEI7UUFDcEQsSUFBSWhZLFdBQVcrWixjQUFjLEtBQUt0c0IsV0FBVztZQUN6QyxPQUFPdVMsV0FBVytaLGNBQWM7UUFDcEM7UUFDQSx1R0FBdUc7UUFDdkcsTUFBTS9FLFdBQVduaUIsT0FBT3NsQixTQUFTO1FBQ2pDLCtGQUErRjtRQUMvRiwwQ0FBMEM7UUFDMUNuWSxXQUFXK1osY0FBYyxHQUFHbHJCLFdBQVcsQ0FBQ0csU0FBU0w7WUFDN0NxUixXQUFXZ2Esc0JBQXNCLEdBQUdockI7WUFDcENnUixXQUFXaWEscUJBQXFCLEdBQUd0ckI7UUFDdkM7UUFDQSxNQUFNNnJCLGVBQWV4YSxXQUFXOFosZUFBZTtRQUMvQ2YsZ0RBQWdEL1k7UUFDaER4USxZQUFZZ3JCLGNBQWM7WUFDdEIsSUFBSXhGLFNBQVNoaUIsTUFBTSxLQUFLLFdBQVc7Z0JBQy9Cc25CLHFDQUFxQ3RhLFlBQVlnVixTQUFTNWhCLFlBQVk7WUFDMUUsT0FDSztnQkFDRHdkLHFDQUFxQ29FLFNBQVN0aEIseUJBQXlCO2dCQUN2RTZtQixzQ0FBc0N2YTtZQUMxQztZQUNBLE9BQU87UUFDWCxHQUFHK0QsQ0FBQUE7WUFDQytNLHFDQUFxQ2tFLFNBQVN0aEIseUJBQXlCLEVBQUVxUTtZQUN6RXVXLHFDQUFxQ3RhLFlBQVkrRDtZQUNqRCxPQUFPO1FBQ1g7UUFDQSxPQUFPL0QsV0FBVytaLGNBQWM7SUFDcEM7SUFDQSwwQ0FBMEM7SUFDMUMsU0FBU3ZCLDBDQUEwQzNsQixNQUFNO1FBQ3JELHNFQUFzRTtRQUN0RStsQiwrQkFBK0IvbEIsUUFBUTtRQUN2Qyw0REFBNEQ7UUFDNUQsT0FBT0EsT0FBTzZsQiwwQkFBMEI7SUFDNUM7SUFDQSxTQUFTRCw0Q0FBNEM1bEIsTUFBTSxFQUFFM0QsTUFBTTtRQUMvRCxNQUFNOFEsYUFBYW5OLE9BQU9tbEIsMEJBQTBCO1FBQ3BELElBQUloWSxXQUFXK1osY0FBYyxLQUFLdHNCLFdBQVc7WUFDekMsT0FBT3VTLFdBQVcrWixjQUFjO1FBQ3BDO1FBQ0EsdUdBQXVHO1FBQ3ZHLE1BQU14TCxXQUFXMWIsT0FBT3VsQixTQUFTO1FBQ2pDLHFGQUFxRjtRQUNyRix5RkFBeUY7UUFDekYsbUJBQW1CO1FBQ25CcFksV0FBVytaLGNBQWMsR0FBR2xyQixXQUFXLENBQUNHLFNBQVNMO1lBQzdDcVIsV0FBV2dhLHNCQUFzQixHQUFHaHJCO1lBQ3BDZ1IsV0FBV2lhLHFCQUFxQixHQUFHdHJCO1FBQ3ZDO1FBQ0EsTUFBTXlqQixnQkFBZ0JwUyxXQUFXaEIsZ0JBQWdCLENBQUM5UDtRQUNsRDZwQixnREFBZ0QvWTtRQUNoRHhRLFlBQVk0aUIsZUFBZTtZQUN2QixJQUFJN0QsU0FBU3ZiLE1BQU0sS0FBSyxXQUFXO2dCQUMvQnNuQixxQ0FBcUN0YSxZQUFZdU8sU0FBU25iLFlBQVk7WUFDMUUsT0FDSztnQkFDRGthLDZDQUE2Q2lCLFNBQVNyRyx5QkFBeUIsRUFBRWhaO2dCQUNqRjhwQiw0QkFBNEJubUI7Z0JBQzVCMG5CLHNDQUFzQ3ZhO1lBQzFDO1lBQ0EsT0FBTztRQUNYLEdBQUcrRCxDQUFBQTtZQUNDdUosNkNBQTZDaUIsU0FBU3JHLHlCQUF5QixFQUFFbkU7WUFDakZpViw0QkFBNEJubUI7WUFDNUJ5bkIscUNBQXFDdGEsWUFBWStEO1lBQ2pELE9BQU87UUFDWDtRQUNBLE9BQU8vRCxXQUFXK1osY0FBYztJQUNwQztJQUNBLDZEQUE2RDtJQUM3RCxTQUFTWixxQ0FBcUNwckIsSUFBSTtRQUM5QyxPQUFPLElBQUl5QyxVQUFVLENBQUMsMkNBQTJDLEVBQUV6QyxLQUFLLHVEQUF1RCxDQUFDO0lBQ3BJO0lBQ0EsU0FBU3dzQixzQ0FBc0N2YSxVQUFVO1FBQ3JELElBQUlBLFdBQVdnYSxzQkFBc0IsS0FBS3ZzQixXQUFXO1lBQ2pEO1FBQ0o7UUFDQXVTLFdBQVdnYSxzQkFBc0I7UUFDakNoYSxXQUFXZ2Esc0JBQXNCLEdBQUd2c0I7UUFDcEN1UyxXQUFXaWEscUJBQXFCLEdBQUd4c0I7SUFDdkM7SUFDQSxTQUFTNnNCLHFDQUFxQ3RhLFVBQVUsRUFBRTlRLE1BQU07UUFDNUQsSUFBSThRLFdBQVdpYSxxQkFBcUIsS0FBS3hzQixXQUFXO1lBQ2hEO1FBQ0o7UUFDQXFDLDBCQUEwQmtRLFdBQVcrWixjQUFjO1FBQ25EL1osV0FBV2lhLHFCQUFxQixDQUFDL3FCO1FBQ2pDOFEsV0FBV2dhLHNCQUFzQixHQUFHdnNCO1FBQ3BDdVMsV0FBV2lhLHFCQUFxQixHQUFHeHNCO0lBQ3ZDO0lBQ0EsNENBQTRDO0lBQzVDLFNBQVN5cUIsMEJBQTBCbnFCLElBQUk7UUFDbkMsT0FBTyxJQUFJeUMsVUFBVSxDQUFDLDBCQUEwQixFQUFFekMsS0FBSyxzQ0FBc0MsQ0FBQztJQUNsRztJQUVBbEIsU0FBUW9wQix5QkFBeUIsR0FBR0E7SUFDcENwcEIsU0FBUXlwQixvQkFBb0IsR0FBR0E7SUFDL0J6cEIsU0FBUWtSLDRCQUE0QixHQUFHQTtJQUN2Q2xSLFNBQVFvb0IsY0FBYyxHQUFHQTtJQUN6QnBvQixTQUFROFgsd0JBQXdCLEdBQUdBO0lBQ25DOVgsU0FBUXVRLHlCQUF5QixHQUFHQTtJQUNwQ3ZRLFNBQVEwakIsK0JBQStCLEdBQUdBO0lBQzFDMWpCLFNBQVFpSiwyQkFBMkIsR0FBR0E7SUFDdENqSixTQUFRcXFCLGVBQWUsR0FBR0E7SUFDMUJycUIsU0FBUW9zQixnQ0FBZ0MsR0FBR0E7SUFDM0Nwc0IsU0FBUThaLGNBQWMsR0FBR0E7SUFDekI5WixTQUFRa2IsK0JBQStCLEdBQUdBO0lBQzFDbGIsU0FBUTZhLDJCQUEyQixHQUFHQTtBQUUxQyxJQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RlY2hmZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9kaXN0L3BvbnlmaWxsLmVzMjAxOC5qcz81YWMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIHdlYi1zdHJlYW1zLXBvbHlmaWxsIHYzLjMuMlxuICogQ29weXJpZ2h0IDIwMjQgTWF0dGlhcyBCdWVsZW5zLCBEaXdhbmsgU2luZ2ggVG9tZXIgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy5cbiAqIFRoaXMgY29kZSBpcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuV2ViU3RyZWFtc1BvbHlmaWxsID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuc3ltYm9sXCIgLz5cbiAgICBjb25zdCBTeW1ib2xQb2x5ZmlsbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcgP1xuICAgICAgICBTeW1ib2wgOlxuICAgICAgICBkZXNjcmlwdGlvbiA9PiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWA7XG5cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHR5cGVJc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBjb25zdCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24gPSBub29wO1xuICAgIGZ1bmN0aW9uIHNldEZ1bmN0aW9uTmFtZShmbiwgbmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlID0gUHJvbWlzZTtcbiAgICBjb25zdCBvcmlnaW5hbFByb21pc2VUaGVuID0gUHJvbWlzZS5wcm90b3R5cGUudGhlbjtcbiAgICBjb25zdCBvcmlnaW5hbFByb21pc2VSZWplY3QgPSBQcm9taXNlLnJlamVjdC5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG4gICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNhLW5ldy1wcm9taXNlXG4gICAgZnVuY3Rpb24gbmV3UHJvbWlzZShleGVjdXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IG9yaWdpbmFsUHJvbWlzZShleGVjdXRvcik7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jYS1wcm9taXNlLXJlc29sdmVkLXdpdGhcbiAgICBmdW5jdGlvbiBwcm9taXNlUmVzb2x2ZWRXaXRoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXdQcm9taXNlKHJlc29sdmUgPT4gcmVzb2x2ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2EtcHJvbWlzZS1yZWplY3RlZC13aXRoXG4gICAgZnVuY3Rpb24gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVJlamVjdChyZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgLy8gVGhlcmUgZG9lc24ndCBhcHBlYXIgdG8gYmUgYW55IHdheSB0byBjb3JyZWN0bHkgZW11bGF0ZSB0aGUgYmVoYXZpb3VyIGZyb20gSmF2YVNjcmlwdCwgc28gdGhpcyBpcyBqdXN0IGFuXG4gICAgICAgIC8vIGFwcHJveGltYXRpb24uXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VUaGVuLmNhbGwocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgICAvLyBCbHVlYmlyZCBsb2dzIGEgd2FybmluZyB3aGVuIGEgcHJvbWlzZSBpcyBjcmVhdGVkIHdpdGhpbiBhIGZ1bGZpbGxtZW50IGhhbmRsZXIsIGJ1dCB0aGVuIGlzbid0IHJldHVybmVkXG4gICAgLy8gZnJvbSB0aGF0IGhhbmRsZXIuIFRvIHByZXZlbnQgdGhpcywgcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB2b2lkIGZyb20gYWxsIGhhbmRsZXJzLlxuICAgIC8vIGh0dHA6Ly9ibHVlYmlyZGpzLmNvbS9kb2NzL3dhcm5pbmctZXhwbGFuYXRpb25zLmh0bWwjd2FybmluZy1hLXByb21pc2Utd2FzLWNyZWF0ZWQtaW4tYS1oYW5kbGVyLWJ1dC13YXMtbm90LXJldHVybmVkLWZyb20taXRcbiAgICBmdW5jdGlvbiB1cG9uUHJvbWlzZShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4oUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cG9uRnVsZmlsbG1lbnQocHJvbWlzZSwgb25GdWxmaWxsZWQpIHtcbiAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cG9uUmVqZWN0aW9uKHByb21pc2UsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgdW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUHJvbWlzZVdpdGgocHJvbWlzZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwcm9taXNlKSB7XG4gICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCB1bmRlZmluZWQsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XG4gICAgfVxuICAgIGxldCBfcXVldWVNaWNyb3Rhc2sgPSBjYWxsYmFjayA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9xdWV1ZU1pY3JvdGFzayA9IHF1ZXVlTWljcm90YXNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgX3F1ZXVlTWljcm90YXNrID0gY2IgPT4gUGVyZm9ybVByb21pc2VUaGVuKHJlc29sdmVkUHJvbWlzZSwgY2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVmbGVjdENhbGwoRiwgViwgYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIEYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKEYsIFYsIGFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9taXNlQ2FsbChGLCBWLCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChyZWZsZWN0Q2FsbChGLCBWLCBhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcmlnaW5hbCBmcm9tIENocm9taXVtXG4gICAgLy8gaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy8rLzBhZWU0NDM0YTRkYmE0MmE0MmFiYWVhOWJmYmMwY2QxOTZhNjNiYzEvdGhpcmRfcGFydHkvYmxpbmsvcmVuZGVyZXIvY29yZS9zdHJlYW1zL1NpbXBsZVF1ZXVlLmpzXG4gICAgY29uc3QgUVVFVUVfTUFYX0FSUkFZX1NJWkUgPSAxNjM4NDtcbiAgICAvKipcbiAgICAgKiBTaW1wbGUgcXVldWUgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogQXZvaWRzIHNjYWxhYmlsaXR5IGlzc3VlcyB3aXRoIHVzaW5nIGEgcGFja2VkIGFycmF5IGRpcmVjdGx5IGJ5IHVzaW5nXG4gICAgICogbXVsdGlwbGUgYXJyYXlzIGluIGEgbGlua2VkIGxpc3QgYW5kIGtlZXBpbmcgdGhlIGFycmF5IHNpemUgYm91bmRlZC5cbiAgICAgKi9cbiAgICBjbGFzcyBTaW1wbGVRdWV1ZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICAgICAgLy8gX2Zyb250IGFuZCBfYmFjayBhcmUgYWx3YXlzIGRlZmluZWQuXG4gICAgICAgICAgICB0aGlzLl9mcm9udCA9IHtcbiAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9iYWNrID0gdGhpcy5fZnJvbnQ7XG4gICAgICAgICAgICAvLyBUaGUgY3Vyc29yIGlzIHVzZWQgdG8gYXZvaWQgY2FsbGluZyBBcnJheS5zaGlmdCgpLlxuICAgICAgICAgICAgLy8gSXQgY29udGFpbnMgdGhlIGluZGV4IG9mIHRoZSBmcm9udCBlbGVtZW50IG9mIHRoZSBhcnJheSBpbnNpZGUgdGhlXG4gICAgICAgICAgICAvLyBmcm9udC1tb3N0IG5vZGUuIEl0IGlzIGFsd2F5cyBpbiB0aGUgcmFuZ2UgWzAsIFFVRVVFX01BWF9BUlJBWV9TSVpFKS5cbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IDA7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG9ubHkgb25lIG5vZGUsIHNpemUgPT09IGVsZW1lbnRzLmxlbmd0aCAtIGN1cnNvci5cbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgZXhjZXB0aW9uIHNhZmV0eSwgdGhpcyBtZXRob2QgaXMgc3RydWN0dXJlZCBpbiBvcmRlcjpcbiAgICAgICAgLy8gMS4gUmVhZCBzdGF0ZVxuICAgICAgICAvLyAyLiBDYWxjdWxhdGUgcmVxdWlyZWQgc3RhdGUgbXV0YXRpb25zXG4gICAgICAgIC8vIDMuIFBlcmZvcm0gc3RhdGUgbXV0YXRpb25zXG4gICAgICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkQmFjayA9IHRoaXMuX2JhY2s7XG4gICAgICAgICAgICBsZXQgbmV3QmFjayA9IG9sZEJhY2s7XG4gICAgICAgICAgICBpZiAob2xkQmFjay5fZWxlbWVudHMubGVuZ3RoID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSAtIDEpIHtcbiAgICAgICAgICAgICAgICBuZXdCYWNrID0ge1xuICAgICAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBfbmV4dDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHB1c2goKSBpcyB0aGUgbXV0YXRpb24gbW9zdCBsaWtlbHkgdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBpdFxuICAgICAgICAgICAgLy8gZ29lcyBmaXJzdC5cbiAgICAgICAgICAgIG9sZEJhY2suX2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAobmV3QmFjayAhPT0gb2xkQmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2sgPSBuZXdCYWNrO1xuICAgICAgICAgICAgICAgIG9sZEJhY2suX25leHQgPSBuZXdCYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKyt0aGlzLl9zaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIExpa2UgcHVzaCgpLCBzaGlmdCgpIGZvbGxvd3MgdGhlIHJlYWQgLT4gY2FsY3VsYXRlIC0+IG11dGF0ZSBwYXR0ZXJuIGZvclxuICAgICAgICAvLyBleGNlcHRpb24gc2FmZXR5LlxuICAgICAgICBzaGlmdCgpIHsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG4gICAgICAgICAgICBjb25zdCBvbGRGcm9udCA9IHRoaXMuX2Zyb250O1xuICAgICAgICAgICAgbGV0IG5ld0Zyb250ID0gb2xkRnJvbnQ7XG4gICAgICAgICAgICBjb25zdCBvbGRDdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG4gICAgICAgICAgICBsZXQgbmV3Q3Vyc29yID0gb2xkQ3Vyc29yICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gb2xkRnJvbnQuX2VsZW1lbnRzO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW29sZEN1cnNvcl07XG4gICAgICAgICAgICBpZiAobmV3Q3Vyc29yID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSkge1xuICAgICAgICAgICAgICAgIG5ld0Zyb250ID0gb2xkRnJvbnQuX25leHQ7XG4gICAgICAgICAgICAgICAgbmV3Q3Vyc29yID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIG11dGF0aW9ucyBiZWZvcmUgdGhpcyBwb2ludC5cbiAgICAgICAgICAgIC0tdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG5ld0N1cnNvcjtcbiAgICAgICAgICAgIGlmIChvbGRGcm9udCAhPT0gbmV3RnJvbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mcm9udCA9IG5ld0Zyb250O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGVybWl0IHNoaWZ0ZWQgZWxlbWVudCB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgICAgIGVsZW1lbnRzW29sZEN1cnNvcl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdHJpY2t5IHRoaW5nIGFib3V0IGZvckVhY2goKSBpcyB0aGF0IGl0IGNhbiBiZSBjYWxsZWRcbiAgICAgICAgLy8gcmUtZW50cmFudGx5LiBUaGUgcXVldWUgbWF5IGJlIG11dGF0ZWQgaW5zaWRlIHRoZSBjYWxsYmFjay4gSXQgaXMgZWFzeSB0b1xuICAgICAgICAvLyBzZWUgdGhhdCBwdXNoKCkgd2l0aGluIHRoZSBjYWxsYmFjayBoYXMgbm8gbmVnYXRpdmUgZWZmZWN0cyBzaW5jZSB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBxdWV1ZSBpcyBjaGVja2VkIGZvciBvbiBldmVyeSBpdGVyYXRpb24uIElmIHNoaWZ0KCkgaXMgY2FsbGVkXG4gICAgICAgIC8vIHJlcGVhdGVkbHkgd2l0aGluIHRoZSBjYWxsYmFjayB0aGVuIHRoZSBuZXh0IGl0ZXJhdGlvbiBtYXkgcmV0dXJuIGFuXG4gICAgICAgIC8vIGVsZW1lbnQgdGhhdCBoYXMgYmVlbiByZW1vdmVkLiBJbiB0aGlzIGNhc2UgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gICAgICAgIC8vIHdpdGggdW5kZWZpbmVkIHZhbHVlcyB1bnRpbCB3ZSBlaXRoZXIgXCJjYXRjaCB1cFwiIHdpdGggZWxlbWVudHMgdGhhdCBzdGlsbFxuICAgICAgICAvLyBleGlzdCBvciByZWFjaCB0aGUgYmFjayBvZiB0aGUgcXVldWUuXG4gICAgICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5fY3Vyc29yO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9mcm9udDtcbiAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuICAgICAgICAgICAgd2hpbGUgKGkgIT09IGVsZW1lbnRzLmxlbmd0aCB8fCBub2RlLl9uZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLl9uZXh0O1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIGVsZW1lbnQgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBpZiBzaGlmdCgpIHdhcyBjYWxsZWQgbm93LFxuICAgICAgICAvLyB3aXRob3V0IG1vZGlmeWluZyB0aGUgcXVldWUuXG4gICAgICAgIHBlZWsoKSB7IC8vIG11c3Qgbm90IGJlIGNhbGxlZCBvbiBhbiBlbXB0eSBxdWV1ZVxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuX2N1cnNvcjtcbiAgICAgICAgICAgIHJldHVybiBmcm9udC5fZWxlbWVudHNbY3Vyc29yXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IEFib3J0U3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tBYm9ydFN0ZXBzXV0nKTtcbiAgICBjb25zdCBFcnJvclN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbRXJyb3JTdGVwc11dJyk7XG4gICAgY29uc3QgQ2FuY2VsU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tDYW5jZWxTdGVwc11dJyk7XG4gICAgY29uc3QgUHVsbFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbUHVsbFN0ZXBzXV0nKTtcbiAgICBjb25zdCBSZWxlYXNlU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tSZWxlYXNlU3RlcHNdXScpO1xuXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZShyZWFkZXIsIHN0cmVhbSkge1xuICAgICAgICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHN0cmVhbS5fcmVhZGVyID0gcmVhZGVyO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBIGNsaWVudCBvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgYW5kIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGVcbiAgICAvLyBjaGVjay5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCByZWFzb24pIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIG5ldyBUeXBlRXJyb3IoYFJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQocmVhZGVyLCBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltSZWxlYXNlU3RlcHNdKCk7XG4gICAgICAgIHN0cmVhbS5fcmVhZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuICAgIGZ1bmN0aW9uIHJlYWRlckxvY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2Fubm90ICcgKyBuYW1lICsgJyBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHJlYWRlcicpO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHJlYXNvbikge1xuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcikge1xuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgcmVhc29uKSB7XG4gICAgICAgIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHJlYWRlci5fY2xvc2VkUHJvbWlzZSk7XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QocmVhc29uKTtcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgcmVhc29uKSB7XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKSB7XG4gICAgICAgIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc0Zpbml0ZSNQb2x5ZmlsbFxuICAgIGNvbnN0IE51bWJlcklzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoeCk7XG4gICAgfTtcblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jI1BvbHlmaWxsXG4gICAgY29uc3QgTWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdiA8IDAgPyBNYXRoLmNlaWwodikgOiBNYXRoLmZsb29yKHYpO1xuICAgIH07XG5cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtZGljdGlvbmFyaWVzXG4gICAgZnVuY3Rpb24gaXNEaWN0aW9uYXJ5KHgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0RGljdGlvbmFyeShvYmosIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkICYmICFpc0RpY3Rpb25hcnkob2JqKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1jYWxsYmFjay1mdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih4LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtb2JqZWN0XG4gICAgZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdCh4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoeCwgcG9zaXRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICR7cG9zaXRpb259IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEZpZWxkKHgsIGZpZWxkLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZmllbGR9IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5yZXN0cmljdGVkLWRvdWJsZVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnNvck5lZ2F0aXZlWmVybyh4KSB7XG4gICAgICAgIHJldHVybiB4ID09PSAwID8gMCA6IHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVnZXJQYXJ0KHgpIHtcbiAgICAgICAgcmV0dXJuIGNlbnNvck5lZ2F0aXZlWmVybyhNYXRoVHJ1bmMoeCkpO1xuICAgIH1cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5zaWduZWQtbG9uZy1sb25nXG4gICAgZnVuY3Rpb24gY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSAwO1xuICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGxldCB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgeCA9IGNlbnNvck5lZ2F0aXZlWmVybyh4KTtcbiAgICAgICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IGludGVnZXJQYXJ0KHgpO1xuICAgICAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgb3V0c2lkZSB0aGUgYWNjZXB0ZWQgcmFuZ2Ugb2YgJHtsb3dlckJvdW5kfSB0byAke3VwcGVyQm91bmR9LCBpbmNsdXNpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlcklzRmluaXRlKHgpIHx8IHggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gVXNlIEJpZ0ludCBpZiBzdXBwb3J0ZWQ/XG4gICAgICAgIC8vIGxldCB4QmlnSW50ID0gQmlnSW50KGludGVnZXJQYXJ0KHgpKTtcbiAgICAgICAgLy8geEJpZ0ludCA9IEJpZ0ludC5hc1VpbnROKDY0LCB4QmlnSW50KTtcbiAgICAgICAgLy8gcmV0dXJuIE51bWJlcih4QmlnSW50KTtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0UmVhZGFibGVTdHJlYW0oeCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0oeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgUmVhZGFibGVTdHJlYW0uYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICB9XG4gICAgLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCkge1xuICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZFJlcXVlc3RzLnB1c2gocmVhZFJlcXVlc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGNodW5rLCBkb25lKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHJlYWRlci5fcmVhZFJlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLl9yZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGRlZmF1bHQgcmVhZGVyIHZlbmRlZCBieSBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicpO1xuICAgICAgICAgICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgICAgICB0aGlzLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsXG4gICAgICAgICAqIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3IgdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgUmVhZGFibGVTdHJlYW0uY2FuY2VsIHwgc3RyZWFtLmNhbmNlbChyZWFzb24pfS5cbiAgICAgICAgICovXG4gICAgICAgIGNhbmNlbChyZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBhbGxvd3MgYWNjZXNzIHRvIHRoZSBuZXh0IGNodW5rIGZyb20gdGhlIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLCBpZiBhdmFpbGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHJlYWRpbmcgYSBjaHVuayBjYXVzZXMgdGhlIHF1ZXVlIHRvIGJlY29tZSBlbXB0eSwgbW9yZSBkYXRhIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHVuZGVybHlpbmcgc291cmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG4gICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiBlID0+IHJlamVjdFByb21pc2UoZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHRoaXMsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWxlYXNlcyB0aGUgcmVhZGVyJ3MgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAgICAgICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICogZnJvbSBub3cgb247IG90aGVyd2lzZSwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgcmVhZGVyJ3MgbG9jayBjYW5ub3QgYmUgcmVsZWFzZWQgd2hpbGUgaXQgc3RpbGwgaGFzIGEgcGVuZGluZyByZWFkIHJlcXVlc3QsIGkuZS4sIGlmIGEgcHJvbWlzZSByZXR1cm5lZCBieVxuICAgICAgICAgKiB0aGUgcmVhZGVyJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5yZWFkIHwgcmVhZCgpfSBtZXRob2QgaGFzIG5vdCB5ZXQgYmVlbiBzZXR0bGVkLiBBdHRlbXB0aW5nIHRvXG4gICAgICAgICAqIGRvIHNvIHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCBhbmQgbGVhdmUgdGhlIHJlYWRlciBsb2NrZWQgdG8gdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbGVhc2VMb2NrKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlbGVhc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwge1xuICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICByZWFkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuY2FuY2VsLCAnY2FuY2VsJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUucmVhZCwgJ3JlYWQnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZS5yZWxlYXNlTG9jaywgJ3JlbGVhc2VMb2NrJyk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRSZXF1ZXN0cycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWxlYXNlKHJlYWRlcikge1xuICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdSZWFkZXIgd2FzIHJlbGVhc2VkJyk7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlckVycm9yUmVhZFJlcXVlc3RzKHJlYWRlciwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlckVycm9yUmVhZFJlcXVlc3RzKHJlYWRlciwgZSkge1xuICAgICAgICBjb25zdCByZWFkUmVxdWVzdHMgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cztcbiAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgcmVhZFJlcXVlc3RzLmZvckVhY2gocmVhZFJlcXVlc3QgPT4ge1xuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyYCk7XG4gICAgfVxuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE4LmFzeW5jaXRlcmFibGVcIiAvPlxuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xuICAgIGNvbnN0IEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uKiAoKSB7IH0pLnByb3RvdHlwZSk7XG5cbiAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTguYXN5bmNpdGVyYWJsZVwiIC8+XG4gICAgY2xhc3MgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJlYWRlciwgcHJldmVudENhbmNlbCkge1xuICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50Q2FuY2VsID0gcHJldmVudENhbmNlbDtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFN0ZXBzID0gKCkgPT4gdGhpcy5fbmV4dFN0ZXBzKCk7XG4gICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHRoaXMuX29uZ29pbmdQcm9taXNlID9cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgbmV4dFN0ZXBzLCBuZXh0U3RlcHMpIDpcbiAgICAgICAgICAgICAgICBuZXh0U3RlcHMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHVyblN0ZXBzID0gKCkgPT4gdGhpcy5fcmV0dXJuU3RlcHModmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uZ29pbmdQcm9taXNlID9cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgcmV0dXJuU3RlcHMsIHJldHVyblN0ZXBzKSA6XG4gICAgICAgICAgICAgICAgcmV0dXJuU3RlcHMoKTtcbiAgICAgICAgfVxuICAgICAgICBfbmV4dFN0ZXBzKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcbiAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGJ5IG9uZSBtaWNyb3Rhc2ssIG90aGVyd2lzZSB3ZSBzdG9wIHB1bGxpbmcgdG9vIGVhcmx5IHdoaWNoIGJyZWFrcyBhIHRlc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIElzIHRoaXMgYSBidWcgaW4gdGhlIHNwZWNpZmljYXRpb24sIG9yIGluIHRoZSB0ZXN0P1xuICAgICAgICAgICAgICAgICAgICBfcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVhc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIF9yZXR1cm5TdGVwcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJldmVudENhbmNlbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbChyZWFkZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHJlc3VsdCwgKCkgPT4gKHsgdmFsdWUsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSB7XG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24oJ25leHQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXN5bmNJdGVyYXRvckltcGwubmV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbigncmV0dXJuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLnJldHVybih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChBc3luY0l0ZXJhdG9yUHJvdG90eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cbiAgICBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSwgcHJldmVudENhbmNlbCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IGltcGwgPSBuZXcgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbChyZWFkZXIsIHByZXZlbnRDYW5jZWwpO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgaXRlcmF0b3IuX2FzeW5jSXRlcmF0b3JJbXBsID0gaW1wbDtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19hc3luY0l0ZXJhdG9ySW1wbCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBTdXNwaWNpb3VzVHlwZU9mR3VhcmRcbiAgICAgICAgICAgIHJldHVybiB4Ll9hc3luY0l0ZXJhdG9ySW1wbCBpbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RlYW1Bc3luY0l0ZXJhdG9yYCk7XG4gICAgfVxuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc05hTiNQb2x5ZmlsbFxuICAgIGNvbnN0IE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgICAgcmV0dXJuIHggIT09IHg7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIENyZWF0ZUFycmF5RnJvbUxpc3QoZWxlbWVudHMpIHtcbiAgICAgICAgLy8gV2UgdXNlIGFycmF5cyB0byByZXByZXNlbnQgbGlzdHMsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgbm8tb3AuXG4gICAgICAgIC8vIERvIGEgc2xpY2UgdGhvdWdoIGp1c3QgaW4gY2FzZSB3ZSBoYXBwZW4gdG8gZGVwZW5kIG9uIHRoZSB1bmlxdWUtbmVzcy5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLnNsaWNlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvcHlEYXRhQmxvY2tCeXRlcyhkZXN0LCBkZXN0T2Zmc2V0LCBzcmMsIHNyY09mZnNldCwgbikge1xuICAgICAgICBuZXcgVWludDhBcnJheShkZXN0KS5zZXQobmV3IFVpbnQ4QXJyYXkoc3JjLCBzcmNPZmZzZXQsIG4pLCBkZXN0T2Zmc2V0KTtcbiAgICB9XG4gICAgbGV0IFRyYW5zZmVyQXJyYXlCdWZmZXIgPSAoTykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIE8udHJhbnNmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFRyYW5zZmVyQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gYnVmZmVyLnRyYW5zZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgVHJhbnNmZXJBcnJheUJ1ZmZlciA9IGJ1ZmZlciA9PiBzdHJ1Y3R1cmVkQ2xvbmUoYnVmZmVyLCB7IHRyYW5zZmVyOiBbYnVmZmVyXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIFRyYW5zZmVyQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUcmFuc2ZlckFycmF5QnVmZmVyKE8pO1xuICAgIH07XG4gICAgbGV0IElzRGV0YWNoZWRCdWZmZXIgPSAoTykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIE8uZGV0YWNoZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgSXNEZXRhY2hlZEJ1ZmZlciA9IGJ1ZmZlciA9PiBidWZmZXIuZGV0YWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG4gICAgICAgICAgICBJc0RldGFjaGVkQnVmZmVyID0gYnVmZmVyID0+IGJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJc0RldGFjaGVkQnVmZmVyKE8pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gQXJyYXlCdWZmZXJTbGljZShidWZmZXIsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgLy8gQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBhdmFpbGFibGUgb24gSUUxMFxuICAgICAgICAvLyBodHRwczovL3d3dy5jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19hcnJheWJ1ZmZlcl9zbGljZVxuICAgICAgICBpZiAoYnVmZmVyLnNsaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIGJlZ2luO1xuICAgICAgICBjb25zdCBzbGljZSA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuICAgICAgICBDb3B5RGF0YUJsb2NrQnl0ZXMoc2xpY2UsIDAsIGJ1ZmZlciwgYmVnaW4sIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gR2V0TWV0aG9kKHJlY2VpdmVyLCBwcm9wKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSByZWNlaXZlcltwcm9wXTtcbiAgICAgICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCB8fCBmdW5jID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtTdHJpbmcocHJvcCl9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENyZWF0ZUFzeW5jRnJvbVN5bmNJdGVyYXRvcihzeW5jSXRlcmF0b3JSZWNvcmQpIHtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiByZS1pbXBsZW1lbnRpbmcgQ3JlYXRlQXN5bmNGcm9tU3luY0l0ZXJhdG9yIGFuZCAlQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSxcbiAgICAgICAgLy8gd2UgdXNlIHlpZWxkKiBpbnNpZGUgYW4gYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGFjaGlldmUgdGhlIHNhbWUgcmVzdWx0LlxuICAgICAgICAvLyBXcmFwIHRoZSBzeW5jIGl0ZXJhdG9yIGluc2lkZSBhIHN5bmMgaXRlcmFibGUsIHNvIHdlIGNhbiB1c2UgaXQgd2l0aCB5aWVsZCouXG4gICAgICAgIGNvbnN0IHN5bmNJdGVyYWJsZSA9IHtcbiAgICAgICAgICAgIFtTeW1ib2xQb2x5ZmlsbC5pdGVyYXRvcl06ICgpID0+IHN5bmNJdGVyYXRvclJlY29yZC5pdGVyYXRvclxuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgYW4gYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFuZCBpbW1lZGlhdGVseSBpbnZva2UgaXQuXG4gICAgICAgIGNvbnN0IGFzeW5jSXRlcmF0b3IgPSAoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogc3luY0l0ZXJhYmxlO1xuICAgICAgICB9KCkpO1xuICAgICAgICAvLyBSZXR1cm4gYXMgYW4gYXN5bmMgaXRlcmF0b3IgcmVjb3JkLlxuICAgICAgICBjb25zdCBuZXh0TWV0aG9kID0gYXN5bmNJdGVyYXRvci5uZXh0O1xuICAgICAgICByZXR1cm4geyBpdGVyYXRvcjogYXN5bmNJdGVyYXRvciwgbmV4dE1ldGhvZCwgZG9uZTogZmFsc2UgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gR2V0SXRlcmF0b3Iob2JqLCBoaW50ID0gJ3N5bmMnLCBtZXRob2QpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaGludCA9PT0gJ2FzeW5jJykge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IEdldE1ldGhvZChvYmosIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW5jTWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgU3ltYm9sUG9seWZpbGwuaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW5jSXRlcmF0b3JSZWNvcmQgPSBHZXRJdGVyYXRvcihvYmosICdzeW5jJywgc3luY01ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDcmVhdGVBc3luY0Zyb21TeW5jSXRlcmF0b3Ioc3luY0l0ZXJhdG9yUmVjb3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBHZXRNZXRob2Qob2JqLCBTeW1ib2xQb2x5ZmlsbC5pdGVyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gcmVmbGVjdENhbGwobWV0aG9kLCBvYmosIFtdKTtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoaXRlcmF0b3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgaXRlcmF0b3IgbWV0aG9kIG11c3QgcmV0dXJuIGFuIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRNZXRob2QgPSBpdGVyYXRvci5uZXh0O1xuICAgICAgICByZXR1cm4geyBpdGVyYXRvciwgbmV4dE1ldGhvZCwgZG9uZTogZmFsc2UgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXRlcmF0b3JOZXh0KGl0ZXJhdG9yUmVjb3JkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmxlY3RDYWxsKGl0ZXJhdG9yUmVjb3JkLm5leHRNZXRob2QsIGl0ZXJhdG9yUmVjb3JkLml0ZXJhdG9yLCBbXSk7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBpdGVyYXRvci5uZXh0KCkgbWV0aG9kIG11c3QgcmV0dXJuIGFuIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yQ29tcGxldGUoaXRlclJlc3VsdCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihpdGVyUmVzdWx0LmRvbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQudmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSXNOb25OZWdhdGl2ZU51bWJlcih2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVySXNOYU4odikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ2xvbmVBc1VpbnQ4QXJyYXkoTykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBBcnJheUJ1ZmZlclNsaWNlKE8uYnVmZmVyLCBPLmJ5dGVPZmZzZXQsIE8uYnl0ZU9mZnNldCArIE8uYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERlcXVldWVWYWx1ZShjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGNvbnRhaW5lci5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBwYWlyLnNpemU7XG4gICAgICAgIGlmIChjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIDwgMCkge1xuICAgICAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhaXIudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRhaW5lciwgdmFsdWUsIHNpemUpIHtcbiAgICAgICAgaWYgKCFJc05vbk5lZ2F0aXZlTnVtYmVyKHNpemUpIHx8IHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignU2l6ZSBtdXN0IGJlIGEgZmluaXRlLCBub24tTmFOLCBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5fcXVldWUucHVzaCh7IHZhbHVlLCBzaXplIH0pO1xuICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplICs9IHNpemU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBlZWtRdWV1ZVZhbHVlKGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5wZWVrKCk7XG4gICAgICAgIHJldHVybiBwYWlyLnZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZXNldFF1ZXVlKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIuX3F1ZXVlID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0YVZpZXdDb25zdHJ1Y3RvcihjdG9yKSB7XG4gICAgICAgIHJldHVybiBjdG9yID09PSBEYXRhVmlldztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNEYXRhVmlldyh2aWV3KSB7XG4gICAgICAgIHJldHVybiBpc0RhdGFWaWV3Q29uc3RydWN0b3Iodmlldy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5QnVmZmVyVmlld0VsZW1lbnRTaXplKGN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGF0YVZpZXdDb25zdHJ1Y3RvcihjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0b3IuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBwdWxsLWludG8gcmVxdWVzdCBpbiBhIHtAbGluayBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyfS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHZpZXcgZm9yIHdyaXRpbmcgaW4gdG8sIG9yIGBudWxsYCBpZiB0aGUgQllPQiByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmVzcG9uZGVkIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHZpZXcoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigndmlldycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uZChieXRlc1dyaXR0ZW4pIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGJ5dGVzV3JpdHRlbiwgMSwgJ3Jlc3BvbmQnKTtcbiAgICAgICAgICAgIGJ5dGVzV3JpdHRlbiA9IGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShieXRlc1dyaXR0ZW4sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHRoaXMuX3ZpZXcuYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBCWU9CIHJlcXVlc3QncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzcG9uc2VgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbmRXaXRoTmV3Vmlldyh2aWV3KSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHZpZXcsIDEsICdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcbiAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbiBvbmx5IHJlc3BvbmQgd2l0aCBhcnJheSBidWZmZXIgdmlld3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBnaXZlbiB2aWV3XFwncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCB7XG4gICAgICAgIHJlc3BvbmQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICByZXNwb25kV2l0aE5ld1ZpZXc6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB2aWV3OiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25kLCAncmVzcG9uZCcpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25kV2l0aE5ld1ZpZXcsICdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QnLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIGJ5dGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgQllPQiBwdWxsIHJlcXVlc3QsIG9yIGBudWxsYCBpZiB0aGVyZSBpc24ndCBvbmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgYnlvYlJlcXVlc3QoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYnlvYlJlcXVlc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBjb250cm9sbGVkIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpc1xuICAgICAgICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuICAgICAgICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZDsgZG8gbm90IGNsb3NlIGl0IGFnYWluIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZW5xdWV1ZShjaHVuaykge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoY2h1bmssIDEsICdlbnF1ZXVlJyk7XG4gICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjaHVuaydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyZWFtIGlzIGNsb3NlZCBvciBkcmFpbmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgZW5xdWV1ZWQgdG9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXJyb3JzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFtDYW5jZWxTdGVwc10ocmVhc29uKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKHRoaXMpO1xuICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFJlYWRSZXF1ZXN0RnJvbVF1ZXVlKHRoaXMsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB0aGlzLl9hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gICAgICAgICAgICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoYnVmZmVyRSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhidWZmZXJFKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoOiBhdXRvQWxsb2NhdGVDaHVua1NpemUsXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzRmlsbGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtRmlsbDogMSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNpemU6IDEsXG4gICAgICAgICAgICAgICAgICAgIHZpZXdDb25zdHJ1Y3RvcjogVWludDhBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyVHlwZTogJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFtSZWxlYXNlU3RlcHNdKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0UHVsbEludG8gPSB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgICAgICAgICBmaXJzdFB1bGxJbnRvLnJlYWRlclR5cGUgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdQdWxsSW50b3MucHVzaChmaXJzdFB1bGxJbnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwge1xuICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGJ5b2JSZXF1ZXN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmNsb3NlLCAnY2xvc2UnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZW5xdWV1ZSwgJ2VucXVldWUnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IsICdlcnJvcicpO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFB1bGwgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XG4gICAgICAgIGlmICghc2hvdWxkUHVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsaW5nKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xuICAgICAgICAvLyBUT0RPOiBUZXN0IGNvbnRyb2xsZXIgYXJndW1lbnRcbiAgICAgICAgY29uc3QgcHVsbFByb21pc2UgPSBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtKCk7XG4gICAgICAgIHVwb25Qcm9taXNlKHB1bGxQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcikge1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3LCBkb25lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcihwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgY29uc3QgYnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICAgICAgICByZXR1cm4gbmV3IHB1bGxJbnRvRGVzY3JpcHRvci52aWV3Q29uc3RydWN0b3IocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIGJ5dGVzRmlsbGVkIC8gZWxlbWVudFNpemUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgY29udHJvbGxlci5fcXVldWUucHVzaCh7IGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCB9KTtcbiAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgKz0gYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDbG9uZWRDaHVua1RvUXVldWUoY29udHJvbGxlciwgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgICAgIGxldCBjbG9uZWRDaHVuaztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNsb25lZENodW5rID0gQXJyYXlCdWZmZXJTbGljZShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2xvbmVFKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgIHRocm93IGNsb25lRTtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCBjbG9uZWRDaHVuaywgMCwgYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlRGV0YWNoZWRQdWxsSW50b1RvUXVldWUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPiAwKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNsb25lZENodW5rVG9RdWV1ZShjb250cm9sbGVyLCBmaXJzdERlc2NyaXB0b3IuYnVmZmVyLCBmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCwgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuICAgICAgICBjb25zdCBtYXhCeXRlc1RvQ29weSA9IE1hdGgubWluKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG4gICAgICAgIGNvbnN0IG1heEJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgbWF4Qnl0ZXNUb0NvcHk7XG4gICAgICAgIGxldCB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4Qnl0ZXNUb0NvcHk7XG4gICAgICAgIGxldCByZWFkeSA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZW1haW5kZXJCeXRlcyA9IG1heEJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICAgICAgICBjb25zdCBtYXhBbGlnbmVkQnl0ZXMgPSBtYXhCeXRlc0ZpbGxlZCAtIHJlbWFpbmRlckJ5dGVzO1xuICAgICAgICAvLyBBIGRlc2NyaXB0b3IgZm9yIGEgcmVhZCgpIHJlcXVlc3QgdGhhdCBpcyBub3QgeWV0IGZpbGxlZCB1cCB0byBpdHMgbWluaW11bSBsZW5ndGggd2lsbCBzdGF5IGF0IHRoZSBoZWFkXG4gICAgICAgIC8vIG9mIHRoZSBxdWV1ZSwgc28gdGhlIHVuZGVybHlpbmcgc291cmNlIGNhbiBrZWVwIGZpbGxpbmcgaXQuXG4gICAgICAgIGlmIChtYXhBbGlnbmVkQnl0ZXMgPj0gcHVsbEludG9EZXNjcmlwdG9yLm1pbmltdW1GaWxsKSB7XG4gICAgICAgICAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4QWxpZ25lZEJ5dGVzIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgICAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gY29udHJvbGxlci5fcXVldWU7XG4gICAgICAgIHdoaWxlICh0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZE9mUXVldWUgPSBxdWV1ZS5wZWVrKCk7XG4gICAgICAgICAgICBjb25zdCBieXRlc1RvQ29weSA9IE1hdGgubWluKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcsIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZGVzdFN0YXJ0ID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgICAgICAgICBDb3B5RGF0YUJsb2NrQnl0ZXMocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZGVzdFN0YXJ0LCBoZWFkT2ZRdWV1ZS5idWZmZXIsIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQsIGJ5dGVzVG9Db3B5KTtcbiAgICAgICAgICAgIGlmIChoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoID09PSBieXRlc1RvQ29weSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0ICs9IGJ5dGVzVG9Db3B5O1xuICAgICAgICAgICAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggLT0gYnl0ZXNUb0NvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBieXRlc1RvQ29weTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1RvQ29weSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgLT0gYnl0ZXNUb0NvcHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWR5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgc2l6ZSwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArPSBzaXplO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCAmJiBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2UoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fdmlldyA9IG51bGw7XG4gICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKSB7XG4gICAgICAgIHdoaWxlIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICAgICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUmVhZFJlcXVlc3RzVXNpbmdRdWV1ZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0gcmVhZGVyLl9yZWFkUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUmVhZFJlcXVlc3RGcm9tUXVldWUoY29udHJvbGxlciwgcmVhZFJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byhjb250cm9sbGVyLCB2aWV3LCBtaW4sIHJlYWRJbnRvUmVxdWVzdCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgICAgICBjb25zdCBjdG9yID0gdmlldy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBhcnJheUJ1ZmZlclZpZXdFbGVtZW50U2l6ZShjdG9yKTtcbiAgICAgICAgY29uc3QgeyBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0gPSB2aWV3O1xuICAgICAgICBjb25zdCBtaW5pbXVtRmlsbCA9IG1pbiAqIGVsZW1lbnRTaXplO1xuICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBidWZmZXJCeXRlTGVuZ3RoOiBidWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGJ5dGVPZmZzZXQsXG4gICAgICAgICAgICBieXRlTGVuZ3RoLFxuICAgICAgICAgICAgYnl0ZXNGaWxsZWQ6IDAsXG4gICAgICAgICAgICBtaW5pbXVtRmlsbCxcbiAgICAgICAgICAgIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgdmlld0NvbnN0cnVjdG9yOiBjdG9yLFxuICAgICAgICAgICAgcmVhZGVyVHlwZTogJ2J5b2InXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgLy8gTm8gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoKSBjYWxsIHNpbmNlOlxuICAgICAgICAgICAgLy8gLSBObyBjaGFuZ2UgaGFwcGVucyBvbiBkZXNpcmVkU2l6ZVxuICAgICAgICAgICAgLy8gLSBUaGUgc291cmNlIGhhcyBhbHJlYWR5IGJlZW4gbm90aWZpZWQgb2YgdGhhdCB0aGVyZSdzIGF0IGxlYXN0IDEgcGVuZGluZyByZWFkKHZpZXcpXG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBlbXB0eVZpZXcgPSBuZXcgY3RvcihwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCwgMCk7XG4gICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHMoZW1wdHlWaWV3KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgICAgICAgICBpZiAoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxlZFZpZXcgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcihwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhmaWxsZWRWaWV3KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcbiAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pKSB7XG4gICAgICAgICAgICB3aGlsZSAoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZURldGFjaGVkUHVsbEludG9Ub1F1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IubWluaW11bUZpbGwpIHtcbiAgICAgICAgICAgIC8vIEEgZGVzY3JpcHRvciBmb3IgYSByZWFkKCkgcmVxdWVzdCB0aGF0IGlzIG5vdCB5ZXQgZmlsbGVkIHVwIHRvIGl0cyBtaW5pbXVtIGxlbmd0aCB3aWxsIHN0YXkgYXQgdGhlIGhlYWRcbiAgICAgICAgICAgIC8vIG9mIHRoZSBxdWV1ZSwgc28gdGhlIHVuZGVybHlpbmcgc291cmNlIGNhbiBrZWVwIGZpbGxpbmcgaXQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgICBjb25zdCByZW1haW5kZXJTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICAgICAgICBpZiAocmVtYWluZGVyU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDbG9uZWRDaHVua1RvUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZW5kIC0gcmVtYWluZGVyU2l6ZSwgcmVtYWluZGVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC09IHJlbWFpbmRlclNpemU7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pIHtcbiAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZShjb250cm9sbGVyLCBmaXJzdERlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBmaXJzdERlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCB8fCBzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8uYnl0ZXNGaWxsZWQgJSBmaXJzdFBlbmRpbmdQdWxsSW50by5lbGVtZW50U2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuaykge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgfHwgc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0gPSBjaHVuaztcbiAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmtcXCdzIGJ1ZmZlciBpcyBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIGVucXVldWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmZXJyZWRCdWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIEJZT0IgcmVxdWVzdFxcJ3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgZmlsbGVkIHdpdGggYW4gZW5xdWV1ZWQgY2h1bmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG4gICAgICAgICAgICBmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8ucmVhZGVyVHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVEZXRhY2hlZFB1bGxJbnRvVG9RdWV1ZShjb250cm9sbGVyLCBmaXJzdFBlbmRpbmdQdWxsSW50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1JlYWRSZXF1ZXN0c1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gICAgICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlcnJlZFZpZXcgPSBuZXcgVWludDhBcnJheSh0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCB0cmFuc2ZlcnJlZFZpZXcsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogSWRlYWxseSBpbiB0aGlzIGJyYW5jaCBkZXRhY2hpbmcgc2hvdWxkIGhhcHBlbiBvbmx5IGlmIHRoZSBidWZmZXIgaXMgbm90IGNvbnN1bWVkIGZ1bGx5LlxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUmVhZFJlcXVlc3RGcm9tUXVldWUoY29udHJvbGxlciwgcmVhZFJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBjb250cm9sbGVyLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBlbnRyeS5ieXRlTGVuZ3RoO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGVudHJ5LmJ1ZmZlciwgZW50cnkuYnl0ZU9mZnNldCwgZW50cnkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKHZpZXcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwgJiYgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShmaXJzdERlc2NyaXB0b3IuYnVmZmVyLCBmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCwgZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlKTtcbiAgICAgICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChieW9iUmVxdWVzdCwgY29udHJvbGxlciwgdmlldyk7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IGJ5b2JSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLl9ieW9iUmVxdWVzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pIHtcbiAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIGlmIChieXRlc1dyaXR0ZW4gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNXcml0dGVuIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmQoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIGJ5dGVzV3JpdHRlbiA+IGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2J5dGVzV3JpdHRlbiBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdERlc2NyaXB0b3IuYnVmZmVyKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGNvbnRyb2xsZXIsIHZpZXcpIHtcbiAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmlld1xcJ3MgbGVuZ3RoIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmlldy5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAhPT0gdmlldy5ieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBkb2VzIG5vdCBtYXRjaCBieW9iUmVxdWVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnVmZmVyQnl0ZUxlbmd0aCAhPT0gdmlldy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBidWZmZXIgb2YgdmlldyBoYXMgZGlmZmVyZW50IGNhcGFjaXR5IHRoYW4gYnlvYlJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgdmlldy5ieXRlTGVuZ3RoID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGlzIGxhcmdlciB0aGFuIGJ5b2JSZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld0J5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG4gICAgICAgIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCB2aWV3Qnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSkge1xuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCByID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Uoc3RyZWFtLCB1bmRlcmx5aW5nQnl0ZVNvdXJjZSwgaGlnaFdhdGVyTWFyaykge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSk7XG4gICAgICAgIGxldCBzdGFydEFsZ29yaXRobTtcbiAgICAgICAgbGV0IHB1bGxBbGdvcml0aG07XG4gICAgICAgIGxldCBjYW5jZWxBbGdvcml0aG07XG4gICAgICAgIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0KGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5jYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdCeXRlU291cmNlLmNhbmNlbChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IHVuZGVybHlpbmdCeXRlU291cmNlLmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgICAgICAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXV0b0FsbG9jYXRlQ2h1bmtTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QocmVxdWVzdCwgY29udHJvbGxlciwgdmlldykge1xuICAgICAgICByZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHJlcXVlc3QuX3ZpZXcgPSB2aWV3O1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5cbiAgICBmdW5jdGlvbiBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdGApO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcmApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkZXJPcHRpb25zKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgbW9kZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kZTogbW9kZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZShtb2RlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdtb2RlJyB0aGF0YClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZShtb2RlLCBjb250ZXh0KSB7XG4gICAgICAgIG1vZGUgPSBgJHttb2RlfWA7XG4gICAgICAgIGlmIChtb2RlICE9PSAnYnlvYicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gJyR7bW9kZX0nIGlzIG5vdCBhIHZhbGlkIGVudW1lcmF0aW9uIHZhbHVlIGZvciBSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGVgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydEJ5b2JSZWFkT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgbWluID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKG1pbiwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnbWluJyB0aGF0YClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcbiAgICB9XG4gICAgLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KSB7XG4gICAgICAgIHN0cmVhbS5fcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLnB1c2gocmVhZEludG9SZXF1ZXN0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGRvbmUpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBCWU9CIHJlYWRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW19LlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInKTtcbiAgICAgICAgICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBmb3IgYSBzdHJlYW0gbm90IGNvbnN0cnVjdGVkIHdpdGggYSBieXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAnc291cmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgICAgICB0aGlzLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLCBvciByZWplY3RlZCBpZiB0aGUgc3RyZWFtIGV2ZXIgZXJyb3JzIG9yXG4gICAgICAgICAqIHRoZSByZWFkZXIncyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFJlYWRhYmxlU3RyZWFtLmNhbmNlbCB8IHN0cmVhbS5jYW5jZWwocmVhc29uKX0uXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWwocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmVhZCh2aWV3LCByYXdPcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlldyBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlldy5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoYHZpZXcncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3XFwncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRCeW9iUmVhZE9wdGlvbnMocmF3T3B0aW9ucywgJ29wdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW4gPSBvcHRpb25zLm1pbjtcbiAgICAgICAgICAgIGlmIChtaW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdvcHRpb25zLm1pbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0RhdGFWaWV3KHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA+IHZpZXcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLm1pbiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB2aWV3XFwncyBsZW5ndGgnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWluID4gdmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFJhbmdlRXJyb3IoJ29wdGlvbnMubWluIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHZpZXdcXCdzIGJ5dGVMZW5ndGgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbigncmVhZCBmcm9tJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc29sdmVQcm9taXNlO1xuICAgICAgICAgICAgbGV0IHJlamVjdFByb21pc2U7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogZSA9PiByZWplY3RQcm9taXNlKGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCh0aGlzLCB2aWV3LCBtaW4sIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVsZWFzZXMgdGhlIHJlYWRlcidzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgICAgICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICAgICAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuICAgICAgICAgKiBkbyBzbyB3aWxsIHRocm93IGEgYFR5cGVFcnJvcmAgYW5kIGxlYXZlIHRoZSByZWFkZXIgbG9ja2VkIHRvIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICByZWxlYXNlTG9jaygpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLmNhbmNlbCwgJ2NhbmNlbCcpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLnJlYWQsICdyZWFkJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUucmVsZWFzZUxvY2ssICdyZWxlYXNlTG9jaycpO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkSW50b1JlcXVlc3RzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZChyZWFkZXIsIHZpZXcsIG1pbiwgcmVhZEludG9SZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcsIG1pbiwgcmVhZEludG9SZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWxlYXNlKHJlYWRlcikge1xuICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdSZWFkZXIgd2FzIHJlbGVhc2VkJyk7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlckVycm9yUmVhZEludG9SZXF1ZXN0cyhyZWFkZXIsIGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJFcnJvclJlYWRJbnRvUmVxdWVzdHMocmVhZGVyLCBlKSB7XG4gICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdHMgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHM7XG4gICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICByZWFkSW50b1JlcXVlc3RzLmZvckVhY2gocmVhZEludG9SZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIuXG4gICAgZnVuY3Rpb24gYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgZGVmYXVsdEhXTSkge1xuICAgICAgICBjb25zdCB7IGhpZ2hXYXRlck1hcmsgfSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAoaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEhXTTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVySXNOYU4oaGlnaFdhdGVyTWFyaykgfHwgaGlnaFdhdGVyTWFyayA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGhpZ2hXYXRlck1hcmsnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaFdhdGVyTWFyaztcbiAgICB9XG4gICAgZnVuY3Rpb24gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpIHtcbiAgICAgICAgY29uc3QgeyBzaXplIH0gPSBzdHJhdGVneTtcbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KGluaXQsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5oaWdoV2F0ZXJNYXJrO1xuICAgICAgICBjb25zdCBzaXplID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LnNpemU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBoaWdoV2F0ZXJNYXJrID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoc2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2l6ZScgdGhhdGApXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNodW5rID0+IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoZm4oY2h1bmspKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1Npbmsob3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGFib3J0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmFib3J0O1xuICAgICAgICBjb25zdCBjbG9zZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5jbG9zZTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcbiAgICAgICAgY29uc3Qgd3JpdGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwud3JpdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogYWJvcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGFib3J0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYWJvcnQnIHRoYXRgKSxcbiAgICAgICAgICAgIGNsb3NlOiBjbG9zZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2soY2xvc2UsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjbG9zZScgdGhhdGApLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgICAgICAgICB3cml0ZTogd3JpdGUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKHdyaXRlLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnd3JpdGUnIHRoYXRgKSxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKHJlYXNvbikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NodW5rLCBjb250cm9sbGVyXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0V3JpdGFibGVTdHJlYW0oeCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0oeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgV3JpdGFibGVTdHJlYW0uYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Fib3J0U2lnbmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUuYWJvcnRlZCA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgLy8gQWJvcnRTaWduYWwucHJvdG90eXBlLmFib3J0ZWQgdGhyb3dzIGlmIGl0cyBicmFuZCBjaGVjayBmYWlsc1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN1cHBvcnRzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgQWJvcnRDb250cm9sbGVyLCBpZiBzdXBwb3J0ZWQgYnkgdGhlIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKCkge1xuICAgICAgICBpZiAoc3VwcG9ydHNBYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHdyaXRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgZGVzdGluYXRpb24gZm9yIGRhdGEsIGludG8gd2hpY2ggeW91IGNhbiB3cml0ZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBXcml0YWJsZVN0cmVhbSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTaW5rID0ge30sIHJhd1N0cmF0ZWd5ID0ge30pIHtcbiAgICAgICAgICAgIGlmIChyYXdVbmRlcmx5aW5nU2luayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmF3VW5kZXJseWluZ1NpbmsgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3U3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBjb25zdCB1bmRlcmx5aW5nU2luayA9IGNvbnZlcnRVbmRlcmx5aW5nU2luayhyYXdVbmRlcmx5aW5nU2luaywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHVuZGVybHlpbmdTaW5rLnR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZSBpcyBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuICAgICAgICAgICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHRoaXMsIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgd3JpdGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHdyaXRlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBsb2NrZWQoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2xvY2tlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFib3J0cyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgdGhhdCB0aGUgcHJvZHVjZXIgY2FuIG5vIGxvbmdlciBzdWNjZXNzZnVsbHkgd3JpdGUgdG8gdGhlIHN0cmVhbSBhbmQgaXQgaXMgdG8gYmVcbiAgICAgICAgICogaW1tZWRpYXRlbHkgbW92ZWQgdG8gYW4gZXJyb3JlZCBzdGF0ZSwgd2l0aCBhbnkgcXVldWVkLXVwIHdyaXRlcyBkaXNjYXJkZWQuIFRoaXMgd2lsbCBhbHNvIGV4ZWN1dGUgYW55IGFib3J0XG4gICAgICAgICAqIG1lY2hhbmlzbSBvZiB0aGUgdW5kZXJseWluZyBzaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGZ1bGZpbGwgaWYgdGhlIHN0cmVhbSBzaHV0cyBkb3duIHN1Y2Nlc3NmdWxseSwgb3IgcmVqZWN0IGlmIHRoZSB1bmRlcmx5aW5nIHNpbmsgc2lnbmFsZWRcbiAgICAgICAgICogdGhhdCB0aGVyZSB3YXMgYW4gZXJyb3IgZG9pbmcgc28uIEFkZGl0aW9uYWxseSwgaXQgd2lsbCByZWplY3Qgd2l0aCBhIGBUeXBlRXJyb3JgICh3aXRob3V0IGF0dGVtcHRpbmcgdG8gY2FuY2VsXG4gICAgICAgICAqIHRoZSBzdHJlYW0pIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGxvY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIGFib3J0KHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdhYm9ydCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGFib3J0IGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydCh0aGlzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIHN0cmVhbS4gVGhlIHVuZGVybHlpbmcgc2luayB3aWxsIGZpbmlzaCBwcm9jZXNzaW5nIGFueSBwcmV2aW91c2x5LXdyaXR0ZW4gY2h1bmtzLCBiZWZvcmUgaW52b2tpbmcgaXRzXG4gICAgICAgICAqIGNsb3NlIGJlaGF2aW9yLiBEdXJpbmcgdGhpcyB0aW1lIGFueSBmdXJ0aGVyIGF0dGVtcHRzIHRvIHdyaXRlIHdpbGwgZmFpbCAod2l0aG91dCBlcnJvcmluZyB0aGUgc3RyZWFtKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG1ldGhvZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCBpZiBhbGwgcmVtYWluaW5nIGNodW5rcyBhcmUgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gYW5kIHRoZSBzdHJlYW1cbiAgICAgICAgICogc3VjY2Vzc2Z1bGx5IGNsb3Nlcywgb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCBkdXJpbmcgdGhpcyBwcm9jZXNzLiBBZGRpdGlvbmFsbHksIGl0IHdpbGwgcmVqZWN0IHdpdGhcbiAgICAgICAgICogYSBgVHlwZUVycm9yYCAod2l0aG91dCBhdHRlbXB0aW5nIHRvIGNhbmNlbCB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignY2xvc2UnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgfCB3cml0ZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgd3JpdGVyLiBXaGlsZSB0aGUgc3RyZWFtXG4gICAgICAgICAqIGlzIGxvY2tlZCwgbm8gb3RoZXIgd3JpdGVyIGNhbiBiZSBhY3F1aXJlZCB1bnRpbCB0aGlzIG9uZSBpcyByZWxlYXNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBjcmVhdGluZyBhYnN0cmFjdGlvbnMgdGhhdCBkZXNpcmUgdGhlIGFiaWxpdHkgdG8gd3JpdGUgdG8gYSBzdHJlYW1cbiAgICAgICAgICogd2l0aG91dCBpbnRlcnJ1cHRpb24gb3IgaW50ZXJsZWF2aW5nLiBCeSBnZXR0aW5nIGEgd3JpdGVyIGZvciB0aGUgc3RyZWFtLCB5b3UgY2FuIGVuc3VyZSBub2JvZHkgZWxzZSBjYW4gd3JpdGUgYXRcbiAgICAgICAgICogdGhlIHNhbWUgdGltZSwgd2hpY2ggd291bGQgY2F1c2UgdGhlIHJlc3VsdGluZyB3cml0dGVuIGRhdGEgdG8gYmUgdW5wcmVkaWN0YWJsZSBhbmQgcHJvYmFibHkgdXNlbGVzcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldFdyaXRlcigpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignZ2V0V3JpdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICAgICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGdldFdyaXRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmFib3J0LCAnYWJvcnQnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmNsb3NlLCAnY2xvc2UnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmdldFdyaXRlciwgJ2dldFdyaXRlcicpO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSk7XG4gICAgfVxuICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG4gICAgZnVuY3Rpb24gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmsgPSAxLCBzaXplQWxnb3JpdGhtID0gKCkgPT4gMSkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gICAgICAgIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ3dyaXRhYmxlJztcbiAgICAgICAgLy8gVGhlIGVycm9yIHRoYXQgd2lsbCBiZSByZXBvcnRlZCBieSBuZXcgbWV0aG9kIGNhbGxzIG9uY2UgdGhlIHN0YXRlIGJlY29tZXMgZXJyb3JlZC4gT25seSBzZXQgd2hlbiBbW3N0YXRlXV0gaXNcbiAgICAgICAgLy8gJ2Vycm9yaW5nJyBvciAnZXJyb3JlZCcuIE1heSBiZSBzZXQgdG8gYW4gdW5kZWZpbmVkIHZhbHVlLlxuICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byB1bmRlZmluZWQgZmlyc3QgYmVjYXVzZSB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNvbnRyb2xsZXIgY2hlY2tzIHRoaXNcbiAgICAgICAgLy8gdmFyaWFibGUgdG8gdmFsaWRhdGUgdGhlIGNhbGxlci5cbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoaXMgcXVldWUgaXMgcGxhY2VkIGhlcmUgaW5zdGVhZCBvZiB0aGUgd3JpdGVyIGNsYXNzIGluIG9yZGVyIHRvIGFsbG93IGZvciBwYXNzaW5nIGEgd3JpdGVyIHRvIHRoZSBuZXh0IGRhdGFcbiAgICAgICAgLy8gcHJvZHVjZXIgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgcXVldWVkIHdyaXRlcyB0byBmaW5pc2guXG4gICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICAvLyBXcml0ZSByZXF1ZXN0cyBhcmUgcmVtb3ZlZCBmcm9tIF93cml0ZVJlcXVlc3RzIHdoZW4gd3JpdGUoKSBpcyBjYWxsZWQgb24gdGhlIHVuZGVybHlpbmcgc2luay4gVGhpcyBwcmV2ZW50c1xuICAgICAgICAvLyB0aGVtIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgd3JpdGUoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmNsb3NlKCkuIFN0b3JlZCBoZXJlIGJlY2F1c2UgaXQgbWF5IGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyXG4gICAgICAgIC8vIGhhcyBiZWVuIGRldGFjaGVkLlxuICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2xvc2UgcmVxdWVzdCBpcyByZW1vdmVkIGZyb20gX2Nsb3NlUmVxdWVzdCB3aGVuIGNsb3NlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHMgaXRcbiAgICAgICAgLy8gZnJvbSBiZWluZyBlcnJvbmVvdXNseSByZWplY3RlZCBvbiBlcnJvci4gSWYgYSBjbG9zZSgpIGNhbGwgaXMgaW4tZmxpZ2h0LCB0aGUgcmVxdWVzdCBpcyBzdG9yZWQgaGVyZS5cbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVGhlIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB3cml0ZXIuYWJvcnQoKS4gVGhpcyBtYXkgYWxzbyBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhlIHdyaXRlciBoYXMgZGV0YWNoZWQuXG4gICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVGhlIGJhY2twcmVzc3VyZSBzaWduYWwgc2V0IGJ5IHRoZSBjb250cm9sbGVyLlxuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5fd3JpdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAoX2EgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQocmVhc29uKTtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBuYXJyb3dzIHRoZSB0eXBlIG9mIGBzdHJlYW0uX3N0YXRlYCBkb3duIHRvICd3cml0YWJsZScgfCAnZXJyb3JpbmcnLFxuICAgICAgICAvLyBidXQgaXQgZG9lc24ndCBrbm93IHRoYXQgc2lnbmFsaW5nIGFib3J0IHJ1bnMgYXV0aG9yIGNvZGUgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQgdGhlIHN0YXRlLlxuICAgICAgICAvLyBXaWRlbiB0aGUgdHlwZSBhZ2FpbiBieSBjYXN0aW5nIHRvIFdyaXRhYmxlU3RyZWFtU3RhdGUuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2FzQWxyZWFkeUVycm9yaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgd2FzQWxyZWFkeUVycm9yaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlYXNvbiB3aWxsIG5vdCBiZSB1c2VkLCBzbyBkb24ndCBrZWVwIGEgcmVmZXJlbmNlIHRvIGl0LlxuICAgICAgICAgICAgcmVhc29uID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfcHJvbWlzZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIF9yZWplY3Q6IHJlamVjdCxcbiAgICAgICAgICAgICAgICBfcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgX3dhc0FscmVhZHlFcnJvcmluZzogd2FzQWxyZWFkeUVycm9yaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgaWYgKCF3YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSB3cml0YWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbG9zZVJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSBjbG9zZVJlcXVlc3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlICYmIHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvLyBXcml0YWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBfcmVqZWN0OiByZWplY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMucHVzaCh3cml0ZVJlcXVlc3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmluZyc7XG4gICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSAmJiBjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmVkJztcbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbRXJyb3JTdGVwc10oKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuZm9yRWFjaCh3cml0ZVJlcXVlc3QgPT4ge1xuICAgICAgICAgICAgd3JpdGVSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFib3J0UmVxdWVzdCA9IHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdDtcbiAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoYWJvcnRSZXF1ZXN0Ll93YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgICAgICAgICAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbQWJvcnRTdGVwc10oYWJvcnRSZXF1ZXN0Ll9yZWFzb24pO1xuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBhYm9ydFJlcXVlc3QuX3JlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgZXJyb3IpIHtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXJyb3Igd2FzIHRvbyBsYXRlIHRvIGRvIGFueXRoaW5nLCBzbyBpdCBpcyBpZ25vcmVkLlxuICAgICAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIE5ldmVyIGV4ZWN1dGUgc2luayBhYm9ydCgpIGFmdGVyIHNpbmsgY2xvc2UoKS5cbiAgICAgICAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbiAgICB9XG4gICAgLy8gVE9ETyhyaWNlYSk6IEZpeCBhbHBoYWJldGljYWwgb3JkZXIuXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHN0cmVhbS5fY2xvc2VSZXF1ZXN0O1xuICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5zaGlmdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QuX3JlamVjdChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICBpZiAoYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0KHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGRlZmF1bHQgd3JpdGVyIHZlbmRlZCBieSBhIHtAbGluayBXcml0YWJsZVN0cmVhbX0uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcicpO1xuICAgICAgICAgICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSB3cml0aW5nIGJ5IGFub3RoZXIgd3JpdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuICAgICAgICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHN0cmVhbeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cbiAgICAgICAgICogQSBwcm9kdWNlciBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSByaWdodCBhbW91bnQgb2YgZGF0YSB0byB3cml0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIHN0cmVhbSBjYW5ub3QgYmUgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gKGR1ZSB0byBlaXRoZXIgYmVpbmcgZXJyb3JlZCwgb3IgaGF2aW5nIGFuIGFib3J0XG4gICAgICAgICAqIHF1ZXVlZCB1cCkuIEl0IHdpbGwgcmV0dXJuIHplcm8gaWYgdGhlIHN0cmVhbSBpcyBjbG9zZWQuIEFuZCB0aGUgZ2V0dGVyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGludm9rZWQgd2hlblxuICAgICAgICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBzdHJlYW3igJlzIGludGVybmFsIHF1ZXVlIHRyYW5zaXRpb25zXG4gICAgICAgICAqIGZyb20gbm9uLXBvc2l0aXZlIHRvIHBvc2l0aXZlLCBzaWduYWxpbmcgdGhhdCBpdCBpcyBubyBsb25nZXIgYXBwbHlpbmcgYmFja3ByZXNzdXJlLiBPbmNlIHRoZSBkZXNpcmVkIHNpemUgZGlwc1xuICAgICAgICAgKiBiYWNrIHRvIHplcm8gb3IgYmVsb3csIHRoZSBnZXR0ZXIgd2lsbCByZXR1cm4gYSBuZXcgcHJvbWlzZSB0aGF0IHN0YXlzIHBlbmRpbmcgdW50aWwgdGhlIG5leHQgdHJhbnNpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIHN0cmVhbSBiZWNvbWVzIGVycm9yZWQgb3IgYWJvcnRlZCwgb3IgdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZWNvbWVcbiAgICAgICAgICogcmVqZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWR5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFdyaXRhYmxlU3RyZWFtLmFib3J0IHwgc3RyZWFtLmFib3J0KHJlYXNvbil9LlxuICAgICAgICAgKi9cbiAgICAgICAgYWJvcnQocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh0aGlzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uY2xvc2UgfCBzdHJlYW0uY2xvc2UoKX0uXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVsZWFzZXMgdGhlIHdyaXRlcuKAmXMgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgd3JpdGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAgICAgICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSB3cml0ZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXkgZnJvbVxuICAgICAgICAgKiBub3cgb247IG90aGVyd2lzZSwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgbG9jayBjYW4gc3RpbGwgYmUgcmVsZWFzZWQgZXZlbiBpZiBzb21lIG9uZ29pbmcgd3JpdGVzIGhhdmUgbm90IHlldCBmaW5pc2hlZCAoaS5lLiBldmVuIGlmIHRoZVxuICAgICAgICAgKiBwcm9taXNlcyByZXR1cm5lZCBmcm9tIHByZXZpb3VzIGNhbGxzIHRvIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIud3JpdGUgfCB3cml0ZSgpfSBoYXZlIG5vdCB5ZXQgc2V0dGxlZCkuXG4gICAgICAgICAqIEl04oCZcyBub3QgbmVjZXNzYXJ5IHRvIGhvbGQgdGhlIGxvY2sgb24gdGhlIHdyaXRlciBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSB3cml0ZTsgdGhlIGxvY2sgaW5zdGVhZCBzaW1wbHkgcHJldmVudHNcbiAgICAgICAgICogb3RoZXIgcHJvZHVjZXJzIGZyb20gd3JpdGluZyBpbiBhbiBpbnRlcmxlYXZlZCBtYW5uZXIuXG4gICAgICAgICAqL1xuICAgICAgICByZWxlYXNlTG9jaygpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgICAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlKGNodW5rID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwge1xuICAgICAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB3cml0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVhZHk6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUuYWJvcnQsICdhYm9ydCcpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLmNsb3NlLCAnY2xvc2UnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS5yZWxlYXNlTG9jaywgJ3JlbGVhc2VMb2NrJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUud3JpdGUsICd3cml0ZScpO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLlxuICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX293bmVyV3JpdGFibGVTdHJlYW0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyO1xuICAgIH1cbiAgICAvLyBBIGNsaWVudCBvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uKHdyaXRlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcbiAgICAgICAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCBlcnJvcikge1xuICAgICAgICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh3cml0ZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICBjb25zdCByZWxlYXNlZEVycm9yID0gbmV3IFR5cGVFcnJvcihgV3JpdGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcbiAgICAgICAgLy8gVGhlIHN0YXRlIHRyYW5zaXRpb25zIHRvIFwiZXJyb3JlZFwiIGJlZm9yZSB0aGUgc2luayBhYm9ydCgpIG1ldGhvZCBydW5zLCBidXQgdGhlIHdyaXRlci5jbG9zZWQgcHJvbWlzZSBpcyBub3RcbiAgICAgICAgLy8gcmVqZWN0ZWQgdW50aWwgYWZ0ZXJ3YXJkcy4gVGhpcyBtZWFucyB0aGF0IHNpbXBseSB0ZXN0aW5nIHN0YXRlIHdpbGwgbm90IHdvcmsuXG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xuICAgICAgICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgaWYgKHN0cmVhbSAhPT0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIGNsb3Npbmcgb3IgY2xvc2VkIGFuZCBjYW5ub3QgYmUgd3JpdHRlbiB0bycpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdChzdHJlYW0pO1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBjbG9zZVNlbnRpbmVsID0ge307XG4gICAgLyoqXG4gICAgICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgV3JpdGFibGVTdHJlYW0gfCB3cml0YWJsZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlYXNvbiB3aGljaCB3YXMgcGFzc2VkIHRvIGBXcml0YWJsZVN0cmVhbS5hYm9ydChyZWFzb24pYCB3aGVuIHRoZSBzdHJlYW0gd2FzIGFib3J0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqICBUaGlzIHByb3BlcnR5IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgc3BlY2lmaWNhdGlvbiwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvc3RyZWFtcy9wdWxsLzExNzcuXG4gICAgICAgICAqICBVc2Uge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuc2lnbmFsfSdzIGByZWFzb25gIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgYWJvcnRSZWFzb24oKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdhYm9ydFJlYXNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0UmVhc29uO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBgQWJvcnRTaWduYWxgIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWJvcnQgdGhlIHBlbmRpbmcgd3JpdGUgb3IgY2xvc2Ugb3BlcmF0aW9uIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm9ydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHNpZ25hbCgpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIoJ3NpZ25hbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2Fib3J0Q29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gT2xkZXIgYnJvd3NlcnMgb3Igb2xkZXIgTm9kZSB2ZXJzaW9ucyBtYXkgbm90IHN1cHBvcnQgYEFib3J0Q29udHJvbGxlcmAgb3IgYEFib3J0U2lnbmFsYC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGJ1bmRsZSBhbmQgc2hpcCBhbiBgQWJvcnRDb250cm9sbGVyYCBwb2x5ZmlsbCB0b2dldGhlciB3aXRoIG91ciBwb2x5ZmlsbCxcbiAgICAgICAgICAgICAgICAvLyBzbyBpbnN0ZWFkIHdlIG9ubHkgaW1wbGVtZW50IHN1cHBvcnQgZm9yIGBzaWduYWxgIGlmIHdlIGZpbmQgYSBnbG9iYWwgYEFib3J0Q29udHJvbGxlcmAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuc2lnbmFsIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgd3JpdGFibGUgc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgcmFyZWx5IHVzZWQsIHNpbmNlIHVzdWFsbHkgaXQgc3VmZmljZXMgdG8gcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBmcm9tIG9uZSBvZiB0aGUgdW5kZXJseWluZ1xuICAgICAgICAgKiBzaW5rJ3MgbWV0aG9kcy4gSG93ZXZlciwgaXQgY2FuIGJlIHVzZWZ1bCBmb3Igc3VkZGVubHkgc2h1dHRpbmcgZG93biBhIHN0cmVhbSBpbiByZXNwb25zZSB0byBhbiBldmVudCBvdXRzaWRlIHRoZVxuICAgICAgICAgKiBub3JtYWwgbGlmZWN5Y2xlIG9mIGludGVyYWN0aW9ucyB3aXRoIHRoZSB1bmRlcmx5aW5nIHNpbmsuXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcihlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlO1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHN0cmVhbSBpcyBjbG9zZWQsIGVycm9yZWQgb3Igd2lsbCBiZSBzb29uLiBUaGUgc2luayBjYW4ndCBkbyBhbnl0aGluZyB1c2VmdWwgaWYgaXQgZ2V0cyBhbiBlcnJvciBoZXJlLCBzb1xuICAgICAgICAgICAgICAgIC8vIGp1c3QgdHJlYXQgaXQgYXMgYSBuby1vcC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbQWJvcnRTdGVwc10ocmVhc29uKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9hYm9ydEFsZ29yaXRobShyZWFzb24pO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbRXJyb3JTdGVwc10oKSB7XG4gICAgICAgICAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gICAgICAgIGFib3J0UmVhc29uOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgc2lnbmFsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBpbXBsZW1lbnRpbmcgaW50ZXJmYWNlIHJlcXVpcmVkIGJ5IHRoZSBXcml0YWJsZVN0cmVhbS5cbiAgICBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAvLyBOZWVkIHRvIHNldCB0aGUgc2xvdHMgc28gdGhhdCB0aGUgYXNzZXJ0IGRvZXNuJ3QgZmlyZS4gSW4gdGhlIHNwZWMgdGhlIHNsb3RzIGFscmVhZHkgZXhpc3QgaW1wbGljaXRseS5cbiAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuICAgICAgICBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobSA9IHdyaXRlQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IGNsb3NlQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IGFib3J0QWxnb3JpdGhtO1xuICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgICAgICAgY29uc3Qgc3RhcnRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCk7XG4gICAgICAgIHVwb25Qcm9taXNlKHN0YXJ0UHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgciA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCByKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHN0cmVhbSwgdW5kZXJseWluZ1NpbmssIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG07XG4gICAgICAgIGxldCB3cml0ZUFsZ29yaXRobTtcbiAgICAgICAgbGV0IGNsb3NlQWxnb3JpdGhtO1xuICAgICAgICBsZXQgYWJvcnRBbGdvcml0aG07XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTaW5rLnN0YXJ0KGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVybHlpbmdTaW5rLndyaXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdyaXRlQWxnb3JpdGhtID0gY2h1bmsgPT4gdW5kZXJseWluZ1Npbmsud3JpdGUoY2h1bmssIGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3JpdGVBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVybHlpbmdTaW5rLmNsb3NlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsb3NlQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NpbmsuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYm9ydEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nU2luay5hYm9ydChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgIH1cbiAgICAvLyBDbGVhckFsZ29yaXRobXMgbWF5IGJlIGNhbGxlZCB0d2ljZS4gRXJyb3JpbmcgdGhlIHNhbWUgc3RyZWFtIGluIG11bHRpcGxlIHdheXMgd2lsbCBvZnRlbiByZXN1bHQgaW4gcmVkdW5kYW50IGNhbGxzLlxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0QWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyKSB7XG4gICAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNsb3NlU2VudGluZWwsIDApO1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0oY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChjaHVua1NpemVFKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBjaHVua1NpemVFKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKSB7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVucXVldWVFKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBlbnF1ZXVlRSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gUGVla1F1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gY2xvc2VTZW50aW5lbCkge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZShjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGUoY29udHJvbGxlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVycm9yKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSk7XG4gICAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgICAgICAgY29uc3Qgc2lua0Nsb3NlUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtKCk7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgIHVwb25Qcm9taXNlKHNpbmtDbG9zZVByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZShzdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIHJlYXNvbiA9PiB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuICAgICAgICBjb25zdCBzaW5rV3JpdGVQcm9taXNlID0gY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0oY2h1bmspO1xuICAgICAgICB1cG9uUHJvbWlzZShzaW5rV3JpdGVQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIHJlYXNvbiA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgZGVzaXJlZFNpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBkZXNpcmVkU2l6ZSA8PSAwO1xuICAgIH1cbiAgICAvLyBBIGNsaWVudCBvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCBlcnJvcik7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbS5cbiAgICBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtYCk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcmApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgd3JpdGVyJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpIHtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncGVuZGluZyc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUod3JpdGVyLl9jbG9zZWRQcm9taXNlKTtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcikge1xuICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZXNvbHZlZCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcikge1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXIpIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fcmVhZHlQcm9taXNlKTtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpIHtcbiAgICAgICAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ2Z1bGZpbGxlZCc7XG4gICAgfVxuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbiAgICBmdW5jdGlvbiBnZXRHbG9iYWxzKCkge1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGdsb2JhbHMgPSBnZXRHbG9iYWxzKCk7XG5cbiAgICAvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIm5vZGVcIiAvPlxuICAgIGZ1bmN0aW9uIGlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IoY3Rvcikge1xuICAgICAgICBpZiAoISh0eXBlb2YgY3RvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY3RvciA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0b3IubmFtZSAhPT0gJ0RPTUV4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IGN0b3IoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQ6XG4gICAgICogLSBXZWIgYnJvd3NlcnNcbiAgICAgKiAtIE5vZGUgMTggYW5kIGhpZ2hlciAoaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC9lNGIxZmI1ZTY0MjJjMWZmMTUxMjM0YmI5ZGU3OTJkNDVkZDg4ZDg3KVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZyb21HbG9iYWwoKSB7XG4gICAgICAgIGNvbnN0IGN0b3IgPSBnbG9iYWxzID09PSBudWxsIHx8IGdsb2JhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbHMuRE9NRXhjZXB0aW9uO1xuICAgICAgICByZXR1cm4gaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihjdG9yKSA/IGN0b3IgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQ6XG4gICAgICogLSBBbGwgcGxhdGZvcm1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUG9seWZpbGwoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgICAgIGNvbnN0IGN0b3IgPSBmdW5jdGlvbiBET01FeGNlcHRpb24obWVzc2FnZSwgbmFtZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJ0Vycm9yJztcbiAgICAgICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXRGdW5jdGlvbk5hbWUoY3RvciwgJ0RPTUV4Y2VwdGlvbicpO1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gY3RvcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmVcbiAgICBjb25zdCBET01FeGNlcHRpb24gPSBnZXRGcm9tR2xvYmFsKCkgfHwgY3JlYXRlUG9seWZpbGwoKTtcblxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHNvdXJjZSwgZGVzdCwgcHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwsIHNpZ25hbCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoZGVzdCk7XG4gICAgICAgIHNvdXJjZS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IHNodXR0aW5nRG93biA9IGZhbHNlO1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgc3BlYydzIHJlcXVpcmVtZW50IHRoYXQgd2Ugd2FpdCBmb3Igb25nb2luZyB3cml0ZXMgZHVyaW5nIHNodXRkb3duLlxuICAgICAgICBsZXQgY3VycmVudFdyaXRlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgYWJvcnRBbGdvcml0aG07XG4gICAgICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBzaWduYWwucmVhc29uICE9PSB1bmRlZmluZWQgPyBzaWduYWwucmVhc29uIDogbmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoYWN0aW9uID0+IGFjdGlvbigpKSksIHRydWUsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzaW5nIHJlYWRlciBhbmQgd3JpdGVyLCByZWFkIGFsbCBjaHVua3MgZnJvbSB0aGlzIGFuZCB3cml0ZSB0aGVtIHRvIGRlc3RcbiAgICAgICAgICAgIC8vIC0gQmFja3ByZXNzdXJlIG11c3QgYmUgZW5mb3JjZWRcbiAgICAgICAgICAgIC8vIC0gU2h1dGRvd24gbXVzdCBzdG9wIGFsbCBhY3Rpdml0eVxuICAgICAgICAgICAgZnVuY3Rpb24gcGlwZUxvb3AoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmVMb29wLCByZWplY3RMb29wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5leHQoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlTG9vcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGBQZXJmb3JtUHJvbWlzZVRoZW5gIGluc3RlYWQgb2YgYHVwb25Qcm9taXNlYCB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGluZyB1bm5lY2Vzc2FyeSBgLmNhdGNoKHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbilgIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUGVyZm9ybVByb21pc2VUaGVuKHBpcGVTdGVwKCksIG5leHQsIHJlamVjdExvb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcGlwZVN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbih3cml0ZXIuX3JlYWR5UHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZVJlYWQsIHJlamVjdFJlYWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdyaXRlID0gUGVyZm9ybVByb21pc2VUaGVuKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspLCB1bmRlZmluZWQsIG5vb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlUmVhZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVJlYWQodHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IHJlamVjdFJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVycm9ycyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuICAgICAgICAgICAgaXNPckJlY29tZXNFcnJvcmVkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCBzdG9yZWRFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgc3RvcmVkRXJyb3IpLCB0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGJhY2t3YXJkXG4gICAgICAgICAgICBpc09yQmVjb21lc0Vycm9yZWQoZGVzdCwgd3JpdGVyLl9jbG9zZWRQcm9taXNlLCBzdG9yZWRFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuICAgICAgICAgICAgaXNPckJlY29tZXNDbG9zZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDbG9zaW5nIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpIHx8IGRlc3QuX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RDbG9zZWQgPSBuZXcgVHlwZUVycm9yKCd0aGUgZGVzdGluYXRpb24gd3JpdGFibGUgc3RyZWFtIGNsb3NlZCBiZWZvcmUgYWxsIGRhdGEgY291bGQgYmUgcGlwZWQgdG8gaXQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZGVzdENsb3NlZCksIHRydWUsIGRlc3RDbG9zZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgZGVzdENsb3NlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwaXBlTG9vcCgpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIHtcbiAgICAgICAgICAgICAgICAvLyBBbm90aGVyIHdyaXRlIG1heSBoYXZlIHN0YXJ0ZWQgd2hpbGUgd2Ugd2VyZSB3YWl0aW5nIG9uIHRoaXMgY3VycmVudFdyaXRlLCBzbyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gd2FpdFxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGF0IHRvby5cbiAgICAgICAgICAgICAgICBjb25zdCBvbGRDdXJyZW50V3JpdGUgPSBjdXJyZW50V3JpdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihjdXJyZW50V3JpdGUsICgpID0+IG9sZEN1cnJlbnRXcml0ZSAhPT0gY3VycmVudFdyaXRlID8gd2FpdEZvcldyaXRlc1RvRmluaXNoKCkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNPckJlY29tZXNFcnJvcmVkKHN0cmVhbSwgcHJvbWlzZSwgYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24oc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cG9uUmVqZWN0aW9uKHByb21pc2UsIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNPckJlY29tZXNDbG9zZWQoc3RyZWFtLCBwcm9taXNlLCBhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQocHJvbWlzZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bldpdGhBY3Rpb24oYWN0aW9uLCBvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgZG9UaGVSZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvVGhlUmVzdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb1RoZVJlc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwb25Qcm9taXNlKGFjdGlvbigpLCAoKSA9PiBmaW5hbGl6ZShvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpLCBuZXdFcnJvciA9PiBmaW5hbGl6ZSh0cnVlLCBuZXdFcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bihpc0Vycm9yLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaHV0dGluZ0Rvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyAmJiAhV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpLCAoKSA9PiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemUoaXNFcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIGNvbnRyb2xsZWQgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzXG4gICAgICAgICAqIG92ZXItZnVsbC4gQW4gdW5kZXJseWluZyBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdkZXNpcmVkU2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbS4gQ29uc3VtZXJzIHdpbGwgc3RpbGwgYmUgYWJsZSB0byByZWFkIGFueSBwcmV2aW91c2x5LWVucXVldWVkIGNodW5rcyBmcm9tXG4gICAgICAgICAqIHRoZSBzdHJlYW0sIGJ1dCBvbmNlIHRob3NlIGFyZSByZWFkLCB0aGUgc3RyZWFtIHdpbGwgYmVjb21lIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnY2xvc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgY2xvc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlKGNodW5rID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdlbnF1ZXVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IoZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFtDYW5jZWxTdGVwc10ocmVhc29uKSB7XG4gICAgICAgICAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFtQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gICAgICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gRGVxdWV1ZVZhbHVlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbUmVsZWFzZVN0ZXBzXSgpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuY2xvc2UsICdjbG9zZScpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5lbnF1ZXVlLCAnZW5xdWV1ZScpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5lcnJvciwgJ2Vycm9yJyk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFB1bGwgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XG4gICAgICAgIGlmICghc2hvdWxkUHVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsaW5nKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcbiAgICAgICAgdXBvblByb21pc2UocHVsbFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuaykge1xuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNodW5rU2l6ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2h1bmtTaXplID0gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjaHVua1NpemVFKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuICAgICAgICAgICAgICAgIHRocm93IGNodW5rU2l6ZUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVucXVldWVFKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlbnF1ZXVlRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdXNlZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVHJhbnNmb3JtU3RyZWFtLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xuICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCAmJiBzdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHNpemVBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcbiAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gICAgICAgIHVwb25Qcm9taXNlKHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpLCAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIHIgPT4ge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShzdHJlYW0sIHVuZGVybHlpbmdTb3VyY2UsIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG07XG4gICAgICAgIGxldCBwdWxsQWxnb3JpdGhtO1xuICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtO1xuICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS5wdWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU291cmNlLnB1bGwoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NvdXJjZS5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtVGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKSB7XG4gICAgICAgIGlmIChJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZShzdHJlYW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUoc3RyZWFtLCBjbG9uZUZvckJyYW5jaDIpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgICAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVhZEFnYWluID0gZmFsc2U7XG4gICAgICAgIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVhc29uMTtcbiAgICAgICAgbGV0IHJlYXNvbjI7XG4gICAgICAgIGxldCBicmFuY2gxO1xuICAgICAgICBsZXQgYnJhbmNoMjtcbiAgICAgICAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlO1xuICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgICAgIHJlYWRBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgIF9xdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsyID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyB3YXkgdG8gYWNjZXNzIHRoZSBjbG9uaW5nIGNvZGUgcmlnaHQgbm93IGluIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhZGQgb25lIHRoZW4gd2UnbGwgbmVlZCBhbiBpbXBsZW1lbnRhdGlvbiBmb3Igc2VyaWFsaXphYmxlIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIWNhbmNlbGVkMiAmJiBjbG9uZUZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY2h1bmsyID0gU3RydWN0dXJlZERlc2VyaWFsaXplKFN0cnVjdHVyZWRTZXJpYWxpemUoY2h1bmsyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRBZ2Fpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5jZWwxQWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgY2FuY2VsZWQxID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlYXNvbjEgPSByZWFzb247XG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgIGNhbmNlbGVkMiA9IHRydWU7XG4gICAgICAgICAgICByZWFzb24yID0gcmVhc29uO1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGJyYW5jaDEgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XG4gICAgICAgIGJyYW5jaDIgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG4gICAgICAgIHVwb25SZWplY3Rpb24ocmVhZGVyLl9jbG9zZWRQcm9taXNlLCAocikgPT4ge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtKSB7XG4gICAgICAgIGxldCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gICAgICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgIGxldCByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XG4gICAgICAgIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVhc29uMTtcbiAgICAgICAgbGV0IHJlYXNvbjI7XG4gICAgICAgIGxldCBicmFuY2gxO1xuICAgICAgICBsZXQgYnJhbmNoMjtcbiAgICAgICAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlO1xuICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmRSZWFkZXJFcnJvcih0aGlzUmVhZGVyKSB7XG4gICAgICAgICAgICB1cG9uUmVqZWN0aW9uKHRoaXNSZWFkZXIuX2Nsb3NlZFByb21pc2UsIHIgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzUmVhZGVyICE9PSByZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKSB7XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgX3F1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgJiYgIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rMiA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGNsb25lRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwdWxsV2l0aEJZT0JSZWFkZXIodmlldywgZm9yQnJhbmNoMikge1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnlvYkJyYW5jaCA9IGZvckJyYW5jaDIgPyBicmFuY2gyIDogYnJhbmNoMTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyQnJhbmNoID0gZm9yQnJhbmNoMiA/IGJyYW5jaDEgOiBicmFuY2gyO1xuICAgICAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBhIG1pY3JvdGFzayBiZWNhdXNlIGl0IHRha2VzIGF0IGxlYXN0IGEgbWljcm90YXNrIHRvIGRldGVjdCBlcnJvcnMgKHVzaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICBfcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQxIDogY2FuY2VsZWQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsb25lZENodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZENodW5rID0gQ2xvbmVBc1VpbnQ4QXJyYXkoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoY2xvbmVFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lZENodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMUFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVhZEFnYWluRm9yQnJhbmNoMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieW9iQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQyIDogY2FuY2VsZWQxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQgJiYgb3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQgfHwgIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZChyZWFkZXIsIHZpZXcsIDEsIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVsbDFBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICBpZiAoYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwdWxsMkFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVsbFdpdGhCWU9CUmVhZGVyKGJ5b2JSZXF1ZXN0Ll92aWV3LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsMUFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgIGNhbmNlbGVkMSA9IHRydWU7XG4gICAgICAgICAgICByZWFzb24xID0gcmVhc29uO1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbDJBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICBjYW5jZWxlZDIgPSB0cnVlO1xuICAgICAgICAgICAgcmVhc29uMiA9IHJlYXNvbjtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmFuY2gxID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMUFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XG4gICAgICAgIGJyYW5jaDIgPSBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGwyQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcbiAgICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG4gICAgICAgIHJldHVybiBbYnJhbmNoMSwgYnJhbmNoMl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbUxpa2Uoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB0eXBlSXNPYmplY3Qoc3RyZWFtKSAmJiB0eXBlb2Ygc3RyZWFtLmdldFJlYWRlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tKHNvdXJjZSkge1xuICAgICAgICBpZiAoaXNSZWFkYWJsZVN0cmVhbUxpa2Uoc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRnJvbURlZmF1bHRSZWFkZXIoc291cmNlLmdldFJlYWRlcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1Gcm9tSXRlcmFibGUoc291cmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tSXRlcmFibGUoYXN5bmNJdGVyYWJsZSkge1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICBjb25zdCBpdGVyYXRvclJlY29yZCA9IEdldEl0ZXJhdG9yKGFzeW5jSXRlcmFibGUsICdhc3luYycpO1xuICAgICAgICBjb25zdCBzdGFydEFsZ29yaXRobSA9IG5vb3A7XG4gICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICBsZXQgbmV4dFJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV4dFJlc3VsdCA9IEl0ZXJhdG9yTmV4dChpdGVyYXRvclJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKG5leHRSZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKG5leHRQcm9taXNlLCBpdGVyUmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGVJc09iamVjdChpdGVyUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgaXRlcmF0b3IubmV4dCgpIG1ldGhvZCBtdXN0IGZ1bGZpbGwgd2l0aCBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZG9uZSA9IEl0ZXJhdG9yQ29tcGxldGUoaXRlclJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhdG9yUmVjb3JkLml0ZXJhdG9yO1xuICAgICAgICAgICAgbGV0IHJldHVybk1ldGhvZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuTWV0aG9kID0gR2V0TWV0aG9kKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXR1cm5SZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdCA9IHJlZmxlY3RDYWxsKHJldHVybk1ldGhvZCwgaXRlcmF0b3IsIFtyZWFzb25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXR1cm5Qcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aChyZXR1cm5SZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHJldHVyblByb21pc2UsIGl0ZXJSZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdHlwZUlzT2JqZWN0KGl0ZXJSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBpdGVyYXRvci5yZXR1cm4oKSBtZXRob2QgbXVzdCBmdWxmaWxsIHdpdGggYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0gPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCAwKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tRGVmYXVsdFJlYWRlcihyZWFkZXIpIHtcbiAgICAgICAgbGV0IHN0cmVhbTtcbiAgICAgICAgY29uc3Qgc3RhcnRBbGdvcml0aG0gPSBub29wO1xuICAgICAgICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgbGV0IHJlYWRQcm9taXNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZWFkUHJvbWlzZSA9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHJlYWRQcm9taXNlLCByZWFkUmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGVJc09iamVjdChyZWFkUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgcmVhZGVyLnJlYWQoKSBtZXRob2QgbXVzdCBmdWxmaWxsIHdpdGggYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWFkUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVhZFJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHJlYWRlci5jYW5jZWwocmVhc29uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIDApO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZShzb3VyY2UsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShzb3VyY2UsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmNhbmNlbDtcbiAgICAgICAgY29uc3QgcHVsbCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5wdWxsO1xuICAgICAgICBjb25zdCBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC50eXBlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXV0b0FsbG9jYXRlQ2h1bmtTaXplOiBhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYXV0b0FsbG9jYXRlQ2h1bmtTaXplLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhdXRvQWxsb2NhdGVDaHVua1NpemUnIHRoYXRgKSxcbiAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayhjYW5jZWwsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjYW5jZWwnIHRoYXRgKSxcbiAgICAgICAgICAgIHB1bGw6IHB1bGwgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayhwdWxsLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAncHVsbCcgdGhhdGApLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUodHlwZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHlwZScgdGhhdGApXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChyZWFzb24pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGUsIGNvbnRleHQpIHtcbiAgICAgICAgdHlwZSA9IGAke3R5cGV9YDtcbiAgICAgICAgaWYgKHR5cGUgIT09ICdieXRlcycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gJyR7dHlwZX0nIGlzIG5vdCBhIHZhbGlkIGVudW1lcmF0aW9uIHZhbHVlIGZvciBSZWFkYWJsZVN0cmVhbVR5cGVgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgcHJldmVudENhbmNlbCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50Q2FuY2VsO1xuICAgICAgICByZXR1cm4geyBwcmV2ZW50Q2FuY2VsOiBCb29sZWFuKHByZXZlbnRDYW5jZWwpIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFBpcGVPcHRpb25zKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgcHJldmVudEFib3J0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRBYm9ydDtcbiAgICAgICAgY29uc3QgcHJldmVudENhbmNlbCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50Q2FuY2VsO1xuICAgICAgICBjb25zdCBwcmV2ZW50Q2xvc2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENsb3NlO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2lnbmFsJyB0aGF0YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXZlbnRBYm9ydDogQm9vbGVhbihwcmV2ZW50QWJvcnQpLFxuICAgICAgICAgICAgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSxcbiAgICAgICAgICAgIHByZXZlbnRDbG9zZTogQm9vbGVhbihwcmV2ZW50Q2xvc2UpLFxuICAgICAgICAgICAgc2lnbmFsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gQWJvcnRTaWduYWwuYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXIocGFpciwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KHBhaXIsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCByZWFkYWJsZSA9IHBhaXIgPT09IG51bGwgfHwgcGFpciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFpci5yZWFkYWJsZTtcbiAgICAgICAgYXNzZXJ0UmVxdWlyZWRGaWVsZChyZWFkYWJsZSwgJ3JlYWRhYmxlJywgJ1JlYWRhYmxlV3JpdGFibGVQYWlyJyk7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdyZWFkYWJsZScgdGhhdGApO1xuICAgICAgICBjb25zdCB3cml0YWJsZSA9IHBhaXIgPT09IG51bGwgfHwgcGFpciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFpci53cml0YWJsZTtcbiAgICAgICAgYXNzZXJ0UmVxdWlyZWRGaWVsZCh3cml0YWJsZSwgJ3dyaXRhYmxlJywgJ1JlYWRhYmxlV3JpdGFibGVQYWlyJyk7XG4gICAgICAgIGFzc2VydFdyaXRhYmxlU3RyZWFtKHdyaXRhYmxlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0YWJsZScgdGhhdGApO1xuICAgICAgICByZXR1cm4geyByZWFkYWJsZSwgd3JpdGFibGUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHJlYWRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgc291cmNlIG9mIGRhdGEsIGZyb20gd2hpY2ggeW91IGNhbiByZWFkLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtIHtcbiAgICAgICAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1NvdXJjZSA9IHt9LCByYXdTdHJhdGVneSA9IHt9KSB7XG4gICAgICAgICAgICBpZiAocmF3VW5kZXJseWluZ1NvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmF3VW5kZXJseWluZ1NvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRPYmplY3QocmF3VW5kZXJseWluZ1NvdXJjZSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgY29uc3QgdW5kZXJseWluZ1NvdXJjZSA9IGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZShyYXdVbmRlcmx5aW5nU291cmNlLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0odGhpcyk7XG4gICAgICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS50eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmF0ZWd5LnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHN0cmF0ZWd5IGZvciBhIGJ5dGUgc3RyZWFtIGNhbm5vdCBoYXZlIGEgc2l6ZSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDApO1xuICAgICAgICAgICAgICAgIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHRoaXMsIHVuZGVybHlpbmdTb3VyY2UsIGhpZ2hXYXRlck1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuICAgICAgICAgICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHRoaXMsIHVuZGVybHlpbmdTb3VyY2UsIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmVhZGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgfCByZWFkZXJ9LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGxvY2tlZCgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnbG9ja2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuY2VscyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgYSBsb3NzIG9mIGludGVyZXN0IGluIHRoZSBzdHJlYW0gYnkgYSBjb25zdW1lci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHN1cHBsaWVkIGByZWFzb25gIGFyZ3VtZW50IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIHVuZGVybHlpbmcgc291cmNlJ3Mge0BsaW5rIFVuZGVybHlpbmdTb3VyY2UuY2FuY2VsIHwgY2FuY2VsKCl9XG4gICAgICAgICAqIG1ldGhvZCwgd2hpY2ggbWlnaHQgb3IgbWlnaHQgbm90IHVzZSBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGNhbmNlbChyZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnY2FuY2VsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FuY2VsIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSByZWFkZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwodGhpcywgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRSZWFkZXIocmF3T3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdnZXRSZWFkZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0UmVhZGVyT3B0aW9ucyhyYXdPcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHBpcGVUaHJvdWdoKHJhd1RyYW5zZm9ybSwgcmF3T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3BpcGVUaHJvdWdoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHJhd1RyYW5zZm9ybSwgMSwgJ3BpcGVUaHJvdWdoJyk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXIocmF3VHJhbnNmb3JtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBSZWFkYWJsZVN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodHJhbnNmb3JtLndyaXRhYmxlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IFJlYWRhYmxlU3RyZWFtUGlwZVRvKHRoaXMsIHRyYW5zZm9ybS53cml0YWJsZSwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtLnJlYWRhYmxlO1xuICAgICAgICB9XG4gICAgICAgIHBpcGVUbyhkZXN0aW5hdGlvbiwgcmF3T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3BpcGVUbycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYFBhcmFtZXRlciAxIGlzIHJlcXVpcmVkIGluICdwaXBlVG8nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8ncyBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgV3JpdGFibGVTdHJlYW1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRQaXBlT3B0aW9ucyhyYXdPcHRpb25zLCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbyBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBSZWFkYWJsZVN0cmVhbScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1QaXBlVG8odGhpcywgZGVzdGluYXRpb24sIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlZXMgdGhpcyByZWFkYWJsZSBzdHJlYW0sIHJldHVybmluZyBhIHR3by1lbGVtZW50IGFycmF5IGNvbnRhaW5pbmcgdGhlIHR3byByZXN1bHRpbmcgYnJhbmNoZXMgYXNcbiAgICAgICAgICogbmV3IHtAbGluayBSZWFkYWJsZVN0cmVhbX0gaW5zdGFuY2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUZWVpbmcgYSBzdHJlYW0gd2lsbCBsb2NrIGl0LCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tIGFjcXVpcmluZyBhIHJlYWRlci5cbiAgICAgICAgICogVG8gY2FuY2VsIHRoZSBzdHJlYW0sIGNhbmNlbCBib3RoIG9mIHRoZSByZXN1bHRpbmcgYnJhbmNoZXM7IGEgY29tcG9zaXRlIGNhbmNlbGxhdGlvbiByZWFzb24gd2lsbCB0aGVuIGJlXG4gICAgICAgICAqIHByb3BhZ2F0ZWQgdG8gdGhlIHN0cmVhbSdzIHVuZGVybHlpbmcgc291cmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGNodW5rcyBzZWVuIGluIGVhY2ggYnJhbmNoIHdpbGwgYmUgdGhlIHNhbWUgb2JqZWN0LiBJZiB0aGUgY2h1bmtzIGFyZSBub3QgaW1tdXRhYmxlLFxuICAgICAgICAgKiB0aGlzIGNvdWxkIGFsbG93IGludGVyZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gYnJhbmNoZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0ZWUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3RlZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnJhbmNoZXMgPSBSZWFkYWJsZVN0cmVhbVRlZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVBcnJheUZyb21MaXN0KGJyYW5jaGVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMocmF3T3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCd2YWx1ZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMsIG9wdGlvbnMucHJldmVudENhbmNlbCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgUmVhZGFibGVTdHJlYW0gd3JhcHBpbmcgdGhlIHByb3ZpZGVkIGl0ZXJhYmxlIG9yIGFzeW5jIGl0ZXJhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFkYXB0IHZhcmlvdXMga2luZHMgb2Ygb2JqZWN0cyBpbnRvIGEgcmVhZGFibGUgc3RyZWFtLFxuICAgICAgICAgKiBzdWNoIGFzIGFuIGFycmF5LCBhbiBhc3luYyBnZW5lcmF0b3IsIG9yIGEgTm9kZS5qcyByZWFkYWJsZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbShhc3luY0l0ZXJhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1Gcm9tKGFzeW5jSXRlcmFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtLCB7XG4gICAgICAgIGZyb206IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGdldFJlYWRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHBpcGVUaHJvdWdoOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcGlwZVRvOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgdGVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgdmFsdWVzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5mcm9tLCAnZnJvbScpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuY2FuY2VsLCAnY2FuY2VsJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5nZXRSZWFkZXIsICdnZXRSZWFkZXInKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoLCAncGlwZVRocm91Z2gnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbywgJ3BpcGVUbycpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUudGVlLCAndGVlJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsICd2YWx1ZXMnKTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwuYXN5bmNJdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwuYXN5bmNJdGVyYXRvciwge1xuICAgICAgICAgICAgdmFsdWU6IFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG4gICAgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyayA9IDEsIHNpemVBbGdvcml0aG0gPSAoKSA9PiAxKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlKTtcbiAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIC8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG4gICAgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICAgICAgICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCAwLCB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAncmVhZGFibGUnO1xuICAgICAgICBzdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RyZWFtLl9kaXN0dXJiZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbSh4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uX3JlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIHJlYXNvbikge1xuICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBpZiAocmVhZGVyICE9PSB1bmRlZmluZWQgJiYgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0cyA9IHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cztcbiAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VDYW5jZWxQcm9taXNlID0gc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbQ2FuY2VsU3RlcHNdKHJlYXNvbik7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChzb3VyY2VDYW5jZWxQcm9taXNlLCBub29wKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdjbG9zZWQnO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcik7XG4gICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdHMgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cztcbiAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgICAgICByZWFkUmVxdWVzdHMuZm9yRWFjaChyZWFkUmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKSB7XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XG4gICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSBlO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBlKTtcbiAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlckVycm9yUmVhZFJlcXVlc3RzKHJlYWRlciwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJFcnJvclJlYWRJbnRvUmVxdWVzdHMocmVhZGVyLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbWApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KGluaXQsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5oaWdoV2F0ZXJNYXJrO1xuICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKGhpZ2hXYXRlck1hcmssICdoaWdoV2F0ZXJNYXJrJywgJ1F1ZXVpbmdTdHJhdGVneUluaXQnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyaylcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2l6ZSBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG5vciBiZSBhIGNvbnN0cnVjdG9yXG4gICAgY29uc3QgYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiA9IChjaHVuaykgPT4ge1xuICAgICAgICByZXR1cm4gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9O1xuICAgIHNldEZ1bmN0aW9uTmFtZShieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uLCAnc2l6ZScpO1xuICAgIC8qKlxuICAgICAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIGVhY2ggY2h1bmsuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3knKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChvcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuICAgICAgICAgICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignaGlnaFdhdGVyTWFyaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IHJldHVybmluZyB0aGUgdmFsdWUgb2YgaXRzIGBieXRlTGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVMZW5ndGhTaXplRnVuY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIHtcbiAgICAgICAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5JyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kuXG4gICAgZnVuY3Rpb24gYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneWApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3koeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2l6ZSBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG5vciBiZSBhIGNvbnN0cnVjdG9yXG4gICAgY29uc3QgY291bnRTaXplRnVuY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH07XG4gICAgc2V0RnVuY3Rpb25OYW1lKGNvdW50U2l6ZUZ1bmN0aW9uLCAnc2l6ZScpO1xuICAgIC8qKlxuICAgICAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGNodW5rcy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBDb3VudFF1ZXVpbmdTdHJhdGVneSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0NvdW50UXVldWluZ1N0cmF0ZWd5Jyk7XG4gICAgICAgICAgICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBoaWdoIHdhdGVyIG1hcmsgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGhpZ2hXYXRlck1hcmsoKSB7XG4gICAgICAgICAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lYXN1cmVzIHRoZSBzaXplIG9mIGBjaHVua2AgYnkgYWx3YXlzIHJldHVybmluZyAxLlxuICAgICAgICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdG90YWwgcXVldWUgc2l6ZSBpcyBhIGNvdW50IG9mIHRoZSBudW1iZXIgb2YgY2h1bmtzIGluIHRoZSBxdWV1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKCdzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY291bnRTaXplRnVuY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XG4gICAgICAgIGhpZ2hXYXRlck1hcms6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ0NvdW50UXVldWluZ1N0cmF0ZWd5JyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIENvdW50UXVldWluZ1N0cmF0ZWd5LlxuICAgIGZ1bmN0aW9uIGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQ291bnRRdWV1aW5nU3RyYXRlZ3lgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgQ291bnRRdWV1aW5nU3RyYXRlZ3k7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyKG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkob3JpZ2luYWwsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2FuY2VsO1xuICAgICAgICBjb25zdCBmbHVzaCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5mbHVzaDtcbiAgICAgICAgY29uc3QgcmVhZGFibGVUeXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnJlYWRhYmxlVHlwZTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlVHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC53cml0YWJsZVR5cGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYW5jZWw6IGNhbmNlbCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lckNhbmNlbENhbGxiYWNrKGNhbmNlbCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2NhbmNlbCcgdGhhdGApLFxuICAgICAgICAgICAgZmx1c2g6IGZsdXNoID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbHVzaCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2ZsdXNoJyB0aGF0YCksXG4gICAgICAgICAgICByZWFkYWJsZVR5cGUsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2sodHJhbnNmb3JtLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHJhbnNmb3JtJyB0aGF0YCksXG4gICAgICAgICAgICB3cml0YWJsZVR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjaHVuaywgY29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyQ2FuY2VsQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChyZWFzb24pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xuICAgIH1cblxuICAgIC8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbVxuICAgIC8qKlxuICAgICAqIEEgdHJhbnNmb3JtIHN0cmVhbSBjb25zaXN0cyBvZiBhIHBhaXIgb2Ygc3RyZWFtczogYSB7QGxpbmsgV3JpdGFibGVTdHJlYW0gfCB3cml0YWJsZSBzdHJlYW19LFxuICAgICAqIGtub3duIGFzIGl0cyB3cml0YWJsZSBzaWRlLCBhbmQgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBzdHJlYW19LCBrbm93biBhcyBpdHMgcmVhZGFibGUgc2lkZS5cbiAgICAgKiBJbiBhIG1hbm5lciBzcGVjaWZpYyB0byB0aGUgdHJhbnNmb3JtIHN0cmVhbSBpbiBxdWVzdGlvbiwgd3JpdGVzIHRvIHRoZSB3cml0YWJsZSBzaWRlIHJlc3VsdCBpbiBuZXcgZGF0YSBiZWluZ1xuICAgICAqIG1hZGUgYXZhaWxhYmxlIGZvciByZWFkaW5nIGZyb20gdGhlIHJlYWRhYmxlIHNpZGUuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgVHJhbnNmb3JtU3RyZWFtIHtcbiAgICAgICAgY29uc3RydWN0b3IocmF3VHJhbnNmb3JtZXIgPSB7fSwgcmF3V3JpdGFibGVTdHJhdGVneSA9IHt9LCByYXdSZWFkYWJsZVN0cmF0ZWd5ID0ge30pIHtcbiAgICAgICAgICAgIGlmIChyYXdUcmFuc2Zvcm1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmF3VHJhbnNmb3JtZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd3JpdGFibGVTdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3V3JpdGFibGVTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1JlYWRhYmxlU3RyYXRlZ3ksICdUaGlyZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gY29udmVydFRyYW5zZm9ybWVyKHJhd1RyYW5zZm9ybWVyLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIucmVhZGFibGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIud3JpdGFibGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB3cml0YWJsZVR5cGUgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhyZWFkYWJsZVN0cmF0ZWd5LCAwKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHJlYWRhYmxlU3RyYXRlZ3kpO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGFibGVIaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsod3JpdGFibGVTdHJhdGVneSwgMSk7XG4gICAgICAgICAgICBjb25zdCB3cml0YWJsZVNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobSh3cml0YWJsZVN0cmF0ZWd5KTtcbiAgICAgICAgICAgIGxldCBzdGFydFByb21pc2VfcmVzb2x2ZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ld1Byb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKHRoaXMsIHN0YXJ0UHJvbWlzZSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcbiAgICAgICAgICAgIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIodGhpcywgdHJhbnNmb3JtZXIpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSh0cmFuc2Zvcm1lci5zdGFydCh0aGlzLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgdHJhbnNmb3JtIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldCByZWFkYWJsZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgdHJhbnNmb3JtIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldCB3cml0YWJsZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0YWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVhZGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB3cml0YWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNmb3JtU3RyZWFtJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbShzdHJlYW0sIHN0YXJ0UHJvbWlzZSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKSB7XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0UHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cml0ZUFsZ29yaXRobShjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG0oc3RyZWFtLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWJvcnRBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobShzdHJlYW0sIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xvc2VBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGUgPSBDcmVhdGVXcml0YWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0pO1xuICAgICAgICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsQWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VDYW5jZWxBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5fcmVhZGFibGUgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG4gICAgICAgIC8vIFRoZSBbW2JhY2twcmVzc3VyZV1dIHNsb3QgaXMgc2V0IHRvIHVuZGVmaW5lZCBzbyB0aGF0IGl0IGNhbiBiZSBpbml0aWFsaXNlZCBieSBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUuXG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gdW5kZWZpbmVkO1xuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcbiAgICAgICAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbSh4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ190cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbTtcbiAgICB9XG4gICAgLy8gVGhpcyBpcyBhIG5vLW9wIGlmIGJvdGggc2lkZXMgYXJlIGFscmVhZHkgZXJyb3JlZC5cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIGUpIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpIHtcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoc3RyZWFtLl93cml0YWJsZS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLCBlKTtcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtVW5ibG9ja1dyaXRlKHN0cmVhbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbVVuYmxvY2tXcml0ZShzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICAvLyBQcmV0ZW5kIHRoYXQgcHVsbCgpIHdhcyBjYWxsZWQgdG8gcGVybWl0IGFueSBwZW5kaW5nIHdyaXRlKCkgY2FsbHMgdG8gY29tcGxldGUuIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZSgpXG4gICAgICAgICAgICAvLyBjYW5ub3QgYmUgY2FsbGVkIGZyb20gZW5xdWV1ZSgpIG9yIHB1bGwoKSBvbmNlIHRoZSBSZWFkYWJsZVN0cmVhbSBpcyBlcnJvcmVkLCBzbyB0aGlzIHdpbGwgd2lsbCBiZSB0aGUgZmluYWwgdGltZVxuICAgICAgICAgICAgLy8gX2JhY2twcmVzc3VyZSBpcyBzZXQuXG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XG4gICAgICAgIC8vIFBhc3NlcyBhbHNvIHdoZW4gY2FsbGVkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXG4gICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG4gICAgfVxuICAgIC8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGNvbnRyb2wgb2YgdGhlIHtAbGluayBSZWFkYWJsZVN0cmVhbX0gYW5kIHtAbGluayBXcml0YWJsZVN0cmVhbX0gb2YgdGhlIGFzc29jaWF0ZWQge0BsaW5rIFRyYW5zZm9ybVN0cmVhbX0uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHJlYWRhYmxlIHNpZGXigJlzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpcyBvdmVyLWZ1bGwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVucXVldWUoY2h1bmsgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZW5xdWV1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXJyb3JzIGJvdGggdGhlIHJlYWRhYmxlIHNpZGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlXG4gICAgICAgICAqIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLiBBbnkgY2h1bmtzIHF1ZXVlZCBmb3IgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBkaXNjYXJkZWQuXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvcihyZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSByZWFkYWJsZSBzaWRlIGFuZCBlcnJvcnMgdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIGNvbnRyb2xsZWQgdHJhbnNmb3JtIHN0cmVhbS4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0aGVcbiAgICAgICAgICogdHJhbnNmb3JtZXIgb25seSBuZWVkcyB0byBjb25zdW1lIGEgcG9ydGlvbiBvZiB0aGUgY2h1bmtzIHdyaXR0ZW4gdG8gdGhlIHdyaXRhYmxlIHNpZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Rlcm1pbmF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gICAgICAgIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHRlcm1pbmF0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIHNldEZ1bmN0aW9uTmFtZShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZW5xdWV1ZSwgJ2VucXVldWUnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVycm9yLCAnZXJyb3InKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLnRlcm1pbmF0ZSwgJ3Rlcm1pbmF0ZScpO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVHJhbnNmb3JtIFN0cmVhbSBEZWZhdWx0IENvbnRyb2xsZXIgQWJzdHJhY3QgT3BlcmF0aW9uc1xuICAgIGZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHRyYW5zZm9ybUFsZ29yaXRobSwgZmx1c2hBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSkge1xuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB0cmFuc2Zvcm1BbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gZmx1c2hBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcihzdHJlYW0sIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1BbGdvcml0aG07XG4gICAgICAgIGxldCBmbHVzaEFsZ29yaXRobTtcbiAgICAgICAgbGV0IGNhbmNlbEFsZ29yaXRobTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVyLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1BbGdvcml0aG0gPSBjaHVuayA9PiB0cmFuc2Zvcm1lci50cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNmb3JtQWxnb3JpdGhtID0gY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoICh0cmFuc2Zvcm1SZXN1bHRFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHRyYW5zZm9ybVJlc3VsdEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybWVyLmZsdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZsdXNoQWxnb3JpdGhtID0gKCkgPT4gdHJhbnNmb3JtZXIuZmx1c2goY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNmb3JtZXIuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9IHJlYXNvbiA9PiB0cmFuc2Zvcm1lci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuaykge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSBzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlIHNpZGUgaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB0aHJvdHRsZSB0cmFuc2Zvcm0gaW52b2NhdGlvbnMgYmFzZWQgb24gdGhlIGJhY2twcmVzc3VyZSBvZiB0aGUgUmVhZGFibGVTdHJlYW0sIGJ1dCB3ZSBzdGlsbFxuICAgICAgICAvLyBhY2NlcHQgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKCkgY2FsbHMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gcmVhZGFibGVTdHJhdGVneS5zaXplKCkgdGhyb3dzLlxuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xuICAgICAgICAgICAgdGhyb3cgc3RyZWFtLl9yZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoYmFja3ByZXNzdXJlICE9PSBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0oY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobShjaHVuayk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0cmFuc2Zvcm1Qcm9taXNlLCB1bmRlZmluZWQsIHIgPT4ge1xuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgcik7XG4gICAgICAgICAgICB0aHJvdyByO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuICAgICAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSBzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoJ1RyYW5zZm9ybVN0cmVhbSB0ZXJtaW5hdGVkJyk7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlcnJvcik7XG4gICAgfVxuICAgIC8vIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rIEFsZ29yaXRobXNcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtKHN0cmVhbSwgY2h1bmspIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB3cml0YWJsZS5fc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHdyaXRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobShzdHJlYW0sIHJlYXNvbikge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBpZiAoY29udHJvbGxlci5fZmluaXNoUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5fZmluaXNoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHJlYW0uX3JlYWRhYmxlIGNhbm5vdCBjaGFuZ2UgYWZ0ZXIgY29uc3RydWN0aW9uLCBzbyBjYWNoaW5nIGl0IGFjcm9zcyBhIGNhbGwgdG8gdXNlciBjb2RlIGlzIHNhZmUuXG4gICAgICAgIGNvbnN0IHJlYWRhYmxlID0gc3RyZWFtLl9yZWFkYWJsZTtcbiAgICAgICAgLy8gQXNzaWduIHRoZSBfZmluaXNoUHJvbWlzZSBub3cgc28gdGhhdCBpZiBfY2FuY2VsQWxnb3JpdGhtIGNhbGxzIHJlYWRhYmxlLmNhbmNlbCgpIGludGVybmFsbHksXG4gICAgICAgIC8vIHdlIGRvbid0IHJ1biB0aGUgX2NhbmNlbEFsZ29yaXRobSBhZ2Fpbi5cbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgdXBvblByb21pc2UoY2FuY2VsUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlYWRhYmxlLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHJlYWRhYmxlLl9zdG9yZWRFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZXNvbHZlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIHIgPT4ge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHJlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fZmluaXNoUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobShzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyZWFtLl9yZWFkYWJsZSBjYW5ub3QgY2hhbmdlIGFmdGVyIGNvbnN0cnVjdGlvbiwgc28gY2FjaGluZyBpdCBhY3Jvc3MgYSBjYWxsIHRvIHVzZXIgY29kZSBpcyBzYWZlLlxuICAgICAgICBjb25zdCByZWFkYWJsZSA9IHN0cmVhbS5fcmVhZGFibGU7XG4gICAgICAgIC8vIEFzc2lnbiB0aGUgX2ZpbmlzaFByb21pc2Ugbm93IHNvIHRoYXQgaWYgX2ZsdXNoQWxnb3JpdGhtIGNhbGxzIHJlYWRhYmxlLmNhbmNlbCgpIGludGVybmFsbHksXG4gICAgICAgIC8vIHdlIGRvbid0IGFsc28gcnVuIHRoZSBfY2FuY2VsQWxnb3JpdGhtLlxuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmbHVzaFByb21pc2UgPSBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSgpO1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgdXBvblByb21pc2UoZmx1c2hQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVhZGFibGUuX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZWplY3QoY29udHJvbGxlciwgcmVhZGFibGUuX3N0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZXNvbHZlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIHIgPT4ge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHJlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fZmluaXNoUHJvbWlzZTtcbiAgICB9XG4gICAgLy8gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZSBBbGdvcml0aG1zXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0oc3RyZWFtKSB7XG4gICAgICAgIC8vIEludmFyaWFudC4gRW5mb3JjZWQgYnkgdGhlIHByb21pc2VzIHJldHVybmVkIGJ5IHN0YXJ0KCkgYW5kIHB1bGwoKS5cbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuICAgICAgICAvLyBQcmV2ZW50IHRoZSBuZXh0IHB1bGwoKSBjYWxsIHVudGlsIHRoZXJlIGlzIGJhY2twcmVzc3VyZS5cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZUNhbmNlbEFsZ29yaXRobShzdHJlYW0sIHJlYXNvbikge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBpZiAoY29udHJvbGxlci5fZmluaXNoUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5fZmluaXNoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHJlYW0uX3dyaXRhYmxlIGNhbm5vdCBjaGFuZ2UgYWZ0ZXIgY29uc3RydWN0aW9uLCBzbyBjYWNoaW5nIGl0IGFjcm9zcyBhIGNhbGwgdG8gdXNlciBjb2RlIGlzIHNhZmUuXG4gICAgICAgIGNvbnN0IHdyaXRhYmxlID0gc3RyZWFtLl93cml0YWJsZTtcbiAgICAgICAgLy8gQXNzaWduIHRoZSBfZmluaXNoUHJvbWlzZSBub3cgc28gdGhhdCBpZiBfZmx1c2hBbGdvcml0aG0gY2FsbHMgd3JpdGFibGUuYWJvcnQoKSBvclxuICAgICAgICAvLyB3cml0YWJsZS5jYW5jZWwoKSBpbnRlcm5hbGx5LCB3ZSBkb24ndCBydW4gdGhlIF9jYW5jZWxBbGdvcml0aG0gYWdhaW4sIG9yIGFsc28gcnVuIHRoZVxuICAgICAgICAvLyBfZmx1c2hBbGdvcml0aG0uXG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgIHVwb25Qcm9taXNlKGNhbmNlbFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh3cml0YWJsZS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdChjb250cm9sbGVyLCB3cml0YWJsZS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQod3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1VbmJsb2NrV3JpdGUoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZXNvbHZlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIHIgPT4ge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQod3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1VbmJsb2NrV3JpdGUoc3RyZWFtKTtcbiAgICAgICAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdChjb250cm9sbGVyLCByKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlc29sdmUoY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3Jlc29sdmUoKTtcbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHJlYXNvbikge1xuICAgICAgICBpZiAoY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUoY29udHJvbGxlci5fZmluaXNoUHJvbWlzZSk7XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW0uXG4gICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbWApO1xuICAgIH1cblxuICAgIGV4cG9ydHMuQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSA9IEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5Db3VudFF1ZXVpbmdTdHJhdGVneSA9IENvdW50UXVldWluZ1N0cmF0ZWd5O1xuICAgIGV4cG9ydHMuUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtO1xuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyID0gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCA9IFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Q7XG4gICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjtcbiAgICBleHBvcnRzLlRyYW5zZm9ybVN0cmVhbSA9IFRyYW5zZm9ybVN0cmVhbTtcbiAgICBleHBvcnRzLlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbSA9IFdyaXRhYmxlU3RyZWFtO1xuICAgIGV4cG9ydHMuV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbnlmaWxsLmVzMjAxOC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJzZWxmIiwiV2ViU3RyZWFtc1BvbHlmaWxsIiwiU3ltYm9sUG9seWZpbGwiLCJTeW1ib2wiLCJpdGVyYXRvciIsImRlc2NyaXB0aW9uIiwibm9vcCIsInVuZGVmaW5lZCIsInR5cGVJc09iamVjdCIsIngiLCJyZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24iLCJzZXRGdW5jdGlvbk5hbWUiLCJmbiIsIm5hbWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiX2EiLCJvcmlnaW5hbFByb21pc2UiLCJQcm9taXNlIiwib3JpZ2luYWxQcm9taXNlVGhlbiIsInByb3RvdHlwZSIsInRoZW4iLCJvcmlnaW5hbFByb21pc2VSZWplY3QiLCJyZWplY3QiLCJiaW5kIiwibmV3UHJvbWlzZSIsImV4ZWN1dG9yIiwicHJvbWlzZVJlc29sdmVkV2l0aCIsInJlc29sdmUiLCJwcm9taXNlUmVqZWN0ZWRXaXRoIiwicmVhc29uIiwiUGVyZm9ybVByb21pc2VUaGVuIiwicHJvbWlzZSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsImNhbGwiLCJ1cG9uUHJvbWlzZSIsInVwb25GdWxmaWxsbWVudCIsInVwb25SZWplY3Rpb24iLCJ0cmFuc2Zvcm1Qcm9taXNlV2l0aCIsImZ1bGZpbGxtZW50SGFuZGxlciIsInJlamVjdGlvbkhhbmRsZXIiLCJzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlIiwiX3F1ZXVlTWljcm90YXNrIiwiY2FsbGJhY2siLCJxdWV1ZU1pY3JvdGFzayIsInJlc29sdmVkUHJvbWlzZSIsImNiIiwicmVmbGVjdENhbGwiLCJGIiwiViIsImFyZ3MiLCJUeXBlRXJyb3IiLCJGdW5jdGlvbiIsImFwcGx5IiwicHJvbWlzZUNhbGwiLCJRVUVVRV9NQVhfQVJSQVlfU0laRSIsIlNpbXBsZVF1ZXVlIiwiY29uc3RydWN0b3IiLCJfY3Vyc29yIiwiX3NpemUiLCJfZnJvbnQiLCJfZWxlbWVudHMiLCJfbmV4dCIsIl9iYWNrIiwibGVuZ3RoIiwicHVzaCIsImVsZW1lbnQiLCJvbGRCYWNrIiwibmV3QmFjayIsInNoaWZ0Iiwib2xkRnJvbnQiLCJuZXdGcm9udCIsIm9sZEN1cnNvciIsIm5ld0N1cnNvciIsImVsZW1lbnRzIiwiZm9yRWFjaCIsImkiLCJub2RlIiwicGVlayIsImZyb250IiwiY3Vyc29yIiwiQWJvcnRTdGVwcyIsIkVycm9yU3RlcHMiLCJDYW5jZWxTdGVwcyIsIlB1bGxTdGVwcyIsIlJlbGVhc2VTdGVwcyIsIlJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUiLCJyZWFkZXIiLCJzdHJlYW0iLCJfb3duZXJSZWFkYWJsZVN0cmVhbSIsIl9yZWFkZXIiLCJfc3RhdGUiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCIsIl9zdG9yZWRFcnJvciIsIlJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCIsIlJlYWRhYmxlU3RyZWFtQ2FuY2VsIiwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0IiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQiLCJfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIiwicmVhZGVyTG9ja0V4Y2VwdGlvbiIsIl9jbG9zZWRQcm9taXNlIiwiX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSIsIl9jbG9zZWRQcm9taXNlX3JlamVjdCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSIsIk51bWJlcklzRmluaXRlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJNYXRoVHJ1bmMiLCJNYXRoIiwidHJ1bmMiLCJ2IiwiY2VpbCIsImZsb29yIiwiaXNEaWN0aW9uYXJ5IiwiYXNzZXJ0RGljdGlvbmFyeSIsIm9iaiIsImNvbnRleHQiLCJhc3NlcnRGdW5jdGlvbiIsImlzT2JqZWN0IiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCIsInBvc2l0aW9uIiwiYXNzZXJ0UmVxdWlyZWRGaWVsZCIsImZpZWxkIiwiY29udmVydFVucmVzdHJpY3RlZERvdWJsZSIsImNlbnNvck5lZ2F0aXZlWmVybyIsImludGVnZXJQYXJ0IiwiY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXNzZXJ0UmVhZGFibGVTdHJlYW0iLCJJc1JlYWRhYmxlU3RyZWFtIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3QiLCJyZWFkUmVxdWVzdCIsIl9yZWFkUmVxdWVzdHMiLCJSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdCIsImNodW5rIiwiZG9uZSIsIl9jbG9zZVN0ZXBzIiwiX2NodW5rU3RlcHMiLCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyIsIlJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlciIsIklzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCIsImNsb3NlZCIsImRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiY2FuY2VsIiwicmVhZCIsInJlc29sdmVQcm9taXNlIiwicmVqZWN0UHJvbWlzZSIsIl9lcnJvclN0ZXBzIiwiZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQiLCJyZWxlYXNlTG9jayIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlbGVhc2UiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZW51bWVyYWJsZSIsInRvU3RyaW5nVGFnIiwiaGFzT3duUHJvcGVydHkiLCJfZGlzdHVyYmVkIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyRXJyb3JSZWFkUmVxdWVzdHMiLCJyZWFkUmVxdWVzdHMiLCJBc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsIiwicHJldmVudENhbmNlbCIsIl9vbmdvaW5nUHJvbWlzZSIsIl9pc0ZpbmlzaGVkIiwiX3ByZXZlbnRDYW5jZWwiLCJuZXh0IiwibmV4dFN0ZXBzIiwiX25leHRTdGVwcyIsInJldHVybiIsInJldHVyblN0ZXBzIiwiX3JldHVyblN0ZXBzIiwicmVzdWx0IiwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbiIsIl9hc3luY0l0ZXJhdG9ySW1wbCIsInNldFByb3RvdHlwZU9mIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsImltcGwiLCJjcmVhdGUiLCJOdW1iZXJJc05hTiIsImlzTmFOIiwiQ3JlYXRlQXJyYXlGcm9tTGlzdCIsInNsaWNlIiwiQ29weURhdGFCbG9ja0J5dGVzIiwiZGVzdCIsImRlc3RPZmZzZXQiLCJzcmMiLCJzcmNPZmZzZXQiLCJuIiwiVWludDhBcnJheSIsInNldCIsIlRyYW5zZmVyQXJyYXlCdWZmZXIiLCJPIiwidHJhbnNmZXIiLCJidWZmZXIiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJJc0RldGFjaGVkQnVmZmVyIiwiZGV0YWNoZWQiLCJieXRlTGVuZ3RoIiwiQXJyYXlCdWZmZXJTbGljZSIsImJlZ2luIiwiZW5kIiwiQXJyYXlCdWZmZXIiLCJHZXRNZXRob2QiLCJyZWNlaXZlciIsInByb3AiLCJmdW5jIiwiU3RyaW5nIiwiQ3JlYXRlQXN5bmNGcm9tU3luY0l0ZXJhdG9yIiwic3luY0l0ZXJhdG9yUmVjb3JkIiwic3luY0l0ZXJhYmxlIiwiYXN5bmNJdGVyYXRvciIsIm5leHRNZXRob2QiLCJHZXRJdGVyYXRvciIsImhpbnQiLCJtZXRob2QiLCJzeW5jTWV0aG9kIiwiSXRlcmF0b3JOZXh0IiwiaXRlcmF0b3JSZWNvcmQiLCJJdGVyYXRvckNvbXBsZXRlIiwiaXRlclJlc3VsdCIsIkJvb2xlYW4iLCJJdGVyYXRvclZhbHVlIiwiSXNOb25OZWdhdGl2ZU51bWJlciIsIkNsb25lQXNVaW50OEFycmF5IiwiYnl0ZU9mZnNldCIsIkRlcXVldWVWYWx1ZSIsImNvbnRhaW5lciIsInBhaXIiLCJfcXVldWUiLCJfcXVldWVUb3RhbFNpemUiLCJzaXplIiwiRW5xdWV1ZVZhbHVlV2l0aFNpemUiLCJJbmZpbml0eSIsIlJhbmdlRXJyb3IiLCJQZWVrUXVldWVWYWx1ZSIsIlJlc2V0UXVldWUiLCJpc0RhdGFWaWV3Q29uc3RydWN0b3IiLCJjdG9yIiwiRGF0YVZpZXciLCJpc0RhdGFWaWV3IiwidmlldyIsImFycmF5QnVmZmVyVmlld0VsZW1lbnRTaXplIiwiQllURVNfUEVSX0VMRU1FTlQiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwiYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uIiwiX3ZpZXciLCJyZXNwb25kIiwiYnl0ZXNXcml0dGVuIiwiX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQiLCJyZXNwb25kV2l0aE5ld1ZpZXciLCJpc1ZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsImJ5b2JSZXF1ZXN0IiwiSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0IiwiZGVzaXJlZFNpemUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUiLCJjbG9zZSIsIl9jbG9zZVJlcXVlc3RlZCIsInN0YXRlIiwiX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UiLCJlbnF1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUiLCJlcnJvciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MiLCJfY2FuY2VsQWxnb3JpdGhtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUmVhZFJlcXVlc3RGcm9tUXVldWUiLCJhdXRvQWxsb2NhdGVDaHVua1NpemUiLCJfYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiYnVmZmVyRSIsInB1bGxJbnRvRGVzY3JpcHRvciIsImJ1ZmZlckJ5dGVMZW5ndGgiLCJieXRlc0ZpbGxlZCIsIm1pbmltdW1GaWxsIiwiZWxlbWVudFNpemUiLCJ2aWV3Q29uc3RydWN0b3IiLCJyZWFkZXJUeXBlIiwiX3BlbmRpbmdQdWxsSW50b3MiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCIsImZpcnN0UHVsbEludG8iLCJjb250cm9sbGVyIiwic2hvdWxkUHVsbCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbCIsIl9wdWxsaW5nIiwiX3B1bGxBZ2FpbiIsInB1bGxQcm9taXNlIiwiX3B1bGxBbGdvcml0aG0iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvciIsImZpbGxlZFZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvciIsIlJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDbG9uZWRDaHVua1RvUXVldWUiLCJjbG9uZWRDaHVuayIsImNsb25lRSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlRGV0YWNoZWRQdWxsSW50b1RvUXVldWUiLCJmaXJzdERlc2NyaXB0b3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8iLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZSIsIm1heEJ5dGVzVG9Db3B5IiwibWluIiwibWF4Qnl0ZXNGaWxsZWQiLCJ0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIiwicmVhZHkiLCJyZW1haW5kZXJCeXRlcyIsIm1heEFsaWduZWRCeXRlcyIsInF1ZXVlIiwiaGVhZE9mUXVldWUiLCJieXRlc1RvQ29weSIsImRlc3RTdGFydCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluIiwiUmVhZGFibGVTdHJlYW1DbG9zZSIsIl9ieW9iUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1JlYWRSZXF1ZXN0c1VzaW5nUXVldWUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8iLCJyZWFkSW50b1JlcXVlc3QiLCJSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdCIsImVtcHR5VmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZSIsIlJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlciIsIlJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlIiwicmVtYWluZGVyU2l6ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwiLCJkZXNjcmlwdG9yIiwiX3N0YXJ0ZWQiLCJmaXJzdFBlbmRpbmdQdWxsSW50byIsInRyYW5zZmVycmVkQnVmZmVyIiwidHJhbnNmZXJyZWRWaWV3IiwiUmVhZGFibGVTdHJlYW1FcnJvciIsImVudHJ5IiwiU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwiX3N0cmF0ZWd5SFdNIiwidmlld0J5dGVMZW5ndGgiLCJTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCJzdGFydEFsZ29yaXRobSIsInB1bGxBbGdvcml0aG0iLCJjYW5jZWxBbGdvcml0aG0iLCJoaWdoV2F0ZXJNYXJrIiwic3RhcnRSZXN1bHQiLCJyIiwiU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UiLCJ1bmRlcmx5aW5nQnl0ZVNvdXJjZSIsInN0YXJ0IiwicHVsbCIsInJlcXVlc3QiLCJjb252ZXJ0UmVhZGVyT3B0aW9ucyIsIm9wdGlvbnMiLCJtb2RlIiwiY29udmVydFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZSIsImNvbnZlcnRCeW9iUmVhZE9wdGlvbnMiLCJBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiX3JlYWRJbnRvUmVxdWVzdHMiLCJJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlciIsImJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwicmF3T3B0aW9ucyIsIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWxlYXNlIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyRXJyb3JSZWFkSW50b1JlcXVlc3RzIiwicmVhZEludG9SZXF1ZXN0cyIsIkV4dHJhY3RIaWdoV2F0ZXJNYXJrIiwic3RyYXRlZ3kiLCJkZWZhdWx0SFdNIiwiRXh0cmFjdFNpemVBbGdvcml0aG0iLCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5IiwiaW5pdCIsImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplIiwiY29udmVydFVuZGVybHlpbmdTaW5rIiwib3JpZ2luYWwiLCJhYm9ydCIsInR5cGUiLCJ3cml0ZSIsImNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2siLCJhc3NlcnRXcml0YWJsZVN0cmVhbSIsIklzV3JpdGFibGVTdHJlYW0iLCJpc0Fib3J0U2lnbmFsIiwiYWJvcnRlZCIsInN1cHBvcnRzQWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiY3JlYXRlQWJvcnRDb250cm9sbGVyIiwiV3JpdGFibGVTdHJlYW0iLCJyYXdVbmRlcmx5aW5nU2luayIsInJhd1N0cmF0ZWd5IiwidW5kZXJseWluZ1NpbmsiLCJJbml0aWFsaXplV3JpdGFibGVTdHJlYW0iLCJzaXplQWxnb3JpdGhtIiwiU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rIiwibG9ja2VkIiwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyIiwiSXNXcml0YWJsZVN0cmVhbUxvY2tlZCIsIldyaXRhYmxlU3RyZWFtQWJvcnQiLCJXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodCIsIldyaXRhYmxlU3RyZWFtQ2xvc2UiLCJnZXRXcml0ZXIiLCJBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIiwiQ3JlYXRlV3JpdGFibGVTdHJlYW0iLCJ3cml0ZUFsZ29yaXRobSIsImNsb3NlQWxnb3JpdGhtIiwiYWJvcnRBbGdvcml0aG0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiX3dyaXRlciIsIl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIiLCJfd3JpdGVSZXF1ZXN0cyIsIl9pbkZsaWdodFdyaXRlUmVxdWVzdCIsIl9jbG9zZVJlcXVlc3QiLCJfaW5GbGlnaHRDbG9zZVJlcXVlc3QiLCJfcGVuZGluZ0Fib3J0UmVxdWVzdCIsIl9iYWNrcHJlc3N1cmUiLCJfYWJvcnRSZWFzb24iLCJfYWJvcnRDb250cm9sbGVyIiwiX3Byb21pc2UiLCJ3YXNBbHJlYWR5RXJyb3JpbmciLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJfcmVhc29uIiwiX3dhc0FscmVhZHlFcnJvcmluZyIsIldyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyIsImNsb3NlUmVxdWVzdCIsIndyaXRlciIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlIiwiV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3QiLCJ3cml0ZVJlcXVlc3QiLCJXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uIiwiV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkIiwiV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodCIsInN0b3JlZEVycm9yIiwiV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZCIsImFib3J0UmVxdWVzdCIsIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZSIsIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvciIsIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZSIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSIsIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvciIsIldyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0IiwiV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0IiwiV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUiLCJiYWNrcHJlc3N1cmUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQiLCJfb3duZXJXcml0YWJsZVN0cmVhbSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQiLCJJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsImRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSIsIl9yZWFkeVByb21pc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbiIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCIsIl9jbG9zZWRQcm9taXNlU3RhdGUiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsIl9yZWFkeVByb21pc2VTdGF0ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3QiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplIiwicmVsZWFzZWRFcnJvciIsImNodW5rU2l6ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyV3JpdGUiLCJjbG9zZVNlbnRpbmVsIiwiYWJvcnRSZWFzb24iLCJJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMiIsInNpZ25hbCIsIl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IiLCJfYWJvcnRBbGdvcml0aG0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zIiwiX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSIsIl93cml0ZUFsZ29yaXRobSIsIl9jbG9zZUFsZ29yaXRobSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUiLCJzdGFydFByb21pc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQiLCJjaHVua1NpemVFIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQiLCJlbnF1ZXVlRSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlIiwic2lua0Nsb3NlUHJvbWlzZSIsInNpbmtXcml0ZVByb21pc2UiLCJfcmVhZHlQcm9taXNlX3Jlc29sdmUiLCJfcmVhZHlQcm9taXNlX3JlamVjdCIsImdldEdsb2JhbHMiLCJnbG9iYWxzIiwiaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvciIsImdldEZyb21HbG9iYWwiLCJET01FeGNlcHRpb24iLCJjcmVhdGVQb2x5ZmlsbCIsIm1lc3NhZ2UiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwid3JpdGFibGUiLCJSZWFkYWJsZVN0cmVhbVBpcGVUbyIsInNvdXJjZSIsInByZXZlbnRDbG9zZSIsInByZXZlbnRBYm9ydCIsInNodXR0aW5nRG93biIsImN1cnJlbnRXcml0ZSIsImFjdGlvbnMiLCJzaHV0ZG93bldpdGhBY3Rpb24iLCJhbGwiLCJtYXAiLCJhY3Rpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicGlwZUxvb3AiLCJyZXNvbHZlTG9vcCIsInJlamVjdExvb3AiLCJwaXBlU3RlcCIsInJlc29sdmVSZWFkIiwicmVqZWN0UmVhZCIsImlzT3JCZWNvbWVzRXJyb3JlZCIsInNodXRkb3duIiwiaXNPckJlY29tZXNDbG9zZWQiLCJkZXN0Q2xvc2VkIiwid2FpdEZvcldyaXRlc1RvRmluaXNoIiwib2xkQ3VycmVudFdyaXRlIiwib3JpZ2luYWxJc0Vycm9yIiwib3JpZ2luYWxFcnJvciIsImRvVGhlUmVzdCIsImZpbmFsaXplIiwibmV3RXJyb3IiLCJpc0Vycm9yIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0iLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSIsInVuZGVybHlpbmdTb3VyY2UiLCJSZWFkYWJsZVN0cmVhbVRlZSIsImNsb25lRm9yQnJhbmNoMiIsIlJlYWRhYmxlQnl0ZVN0cmVhbVRlZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZSIsInJlYWRpbmciLCJyZWFkQWdhaW4iLCJjYW5jZWxlZDEiLCJjYW5jZWxlZDIiLCJyZWFzb24xIiwicmVhc29uMiIsImJyYW5jaDEiLCJicmFuY2gyIiwicmVzb2x2ZUNhbmNlbFByb21pc2UiLCJjYW5jZWxQcm9taXNlIiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FuY2VsMUFsZ29yaXRobSIsImNvbXBvc2l0ZVJlYXNvbiIsImNhbmNlbFJlc3VsdCIsImNhbmNlbDJBbGdvcml0aG0iLCJDcmVhdGVSZWFkYWJsZVN0cmVhbSIsInJlYWRBZ2FpbkZvckJyYW5jaDEiLCJyZWFkQWdhaW5Gb3JCcmFuY2gyIiwiZm9yd2FyZFJlYWRlckVycm9yIiwidGhpc1JlYWRlciIsInB1bGxXaXRoRGVmYXVsdFJlYWRlciIsInB1bGwxQWxnb3JpdGhtIiwicHVsbDJBbGdvcml0aG0iLCJwdWxsV2l0aEJZT0JSZWFkZXIiLCJmb3JCcmFuY2gyIiwiYnlvYkJyYW5jaCIsIm90aGVyQnJhbmNoIiwiYnlvYkNhbmNlbGVkIiwib3RoZXJDYW5jZWxlZCIsIkNyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbSIsImlzUmVhZGFibGVTdHJlYW1MaWtlIiwiZ2V0UmVhZGVyIiwiUmVhZGFibGVTdHJlYW1Gcm9tIiwiUmVhZGFibGVTdHJlYW1Gcm9tRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtRnJvbUl0ZXJhYmxlIiwiYXN5bmNJdGVyYWJsZSIsIm5leHRSZXN1bHQiLCJuZXh0UHJvbWlzZSIsInJldHVybk1ldGhvZCIsInJldHVyblJlc3VsdCIsInJldHVyblByb21pc2UiLCJyZWFkUHJvbWlzZSIsInJlYWRSZXN1bHQiLCJjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UiLCJjb252ZXJ0VW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2siLCJjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlIiwiY29udmVydEl0ZXJhdG9yT3B0aW9ucyIsImNvbnZlcnRQaXBlT3B0aW9ucyIsImFzc2VydEFib3J0U2lnbmFsIiwiY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyIiwicmVhZGFibGUiLCJSZWFkYWJsZVN0cmVhbSIsInJhd1VuZGVybHlpbmdTb3VyY2UiLCJJbml0aWFsaXplUmVhZGFibGVTdHJlYW0iLCJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEiLCJwaXBlVGhyb3VnaCIsInJhd1RyYW5zZm9ybSIsInRyYW5zZm9ybSIsInBpcGVUbyIsImRlc3RpbmF0aW9uIiwidGVlIiwiYnJhbmNoZXMiLCJ2YWx1ZXMiLCJmcm9tIiwic291cmNlQ2FuY2VsUHJvbWlzZSIsImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0IiwiYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiIsIkJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kiLCJfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsiLCJJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kiLCJieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbiIsImNvdW50U2l6ZUZ1bmN0aW9uIiwiQ291bnRRdWV1aW5nU3RyYXRlZ3kiLCJfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrIiwiSXNDb3VudFF1ZXVpbmdTdHJhdGVneSIsImNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbiIsImNvbnZlcnRUcmFuc2Zvcm1lciIsImZsdXNoIiwicmVhZGFibGVUeXBlIiwid3JpdGFibGVUeXBlIiwiY29udmVydFRyYW5zZm9ybWVyQ2FuY2VsQ2FsbGJhY2siLCJjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrIiwiY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayIsImNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrIiwiVHJhbnNmb3JtU3RyZWFtIiwicmF3VHJhbnNmb3JtZXIiLCJyYXdXcml0YWJsZVN0cmF0ZWd5IiwicmF3UmVhZGFibGVTdHJhdGVneSIsIndyaXRhYmxlU3RyYXRlZ3kiLCJyZWFkYWJsZVN0cmF0ZWd5IiwidHJhbnNmb3JtZXIiLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJyZWFkYWJsZVNpemVBbGdvcml0aG0iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJ3cml0YWJsZVNpemVBbGdvcml0aG0iLCJzdGFydFByb21pc2VfcmVzb2x2ZSIsIkluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0iLCJTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyIiwiX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIiLCJJc1RyYW5zZm9ybVN0cmVhbSIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24iLCJfcmVhZGFibGUiLCJfd3JpdGFibGUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VDYW5jZWxBbGdvcml0aG0iLCJfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSIsIl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUiLCJUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUiLCJUcmFuc2Zvcm1TdHJlYW1FcnJvciIsIlRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIlRyYW5zZm9ybVN0cmVhbVVuYmxvY2tXcml0ZSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsInJlYWRhYmxlQ29udHJvbGxlciIsIl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvciIsInRlcm1pbmF0ZSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlIiwiU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsInRyYW5zZm9ybUFsZ29yaXRobSIsImZsdXNoQWxnb3JpdGhtIiwiX3RyYW5zZm9ybUFsZ29yaXRobSIsIl9mbHVzaEFsZ29yaXRobSIsIl9maW5pc2hQcm9taXNlIiwiX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSIsIl9maW5pc2hQcm9taXNlX3JlamVjdCIsInRyYW5zZm9ybVJlc3VsdEUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1Qcm9taXNlIiwiYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSIsImRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdCIsImRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlc29sdmUiLCJmbHVzaFByb21pc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\n");

/***/ })

};
;